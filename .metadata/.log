!SESSION 2023-12-24 22:14:16.663 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

This is a continuation of log file C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.bak_0.log
Created Time: 2023-12-24 23:20:52.656

!ENTRY org.eclipse.jdt.ui 4 2 2023-12-24 23:20:52.657
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-12-24 23:20:52.659
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-12-24 23:20:53.109
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.pract;

import java.lang.reflect.InvocationTargetException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.springframework.jdbc.core.metadata.OracleCallMetaDataProvider;

interface DD {

}

class AB implements Comparable<AB> {
	int id = 0;
	String name = "rohit";

	@Override
	public int compareTo(AB o) {
		if (this.id < o.id)
			return 1;

		return -1;
	}

	@Override
	public String toString() {
		return "AB [id=" + id + ", name=" + name + "]";
	}

}

abstract class kd {

}

class Foodsystem {
	public String count;
	public Map<String, Integer> food = new LinkedHashMap<>();

	public String toString() {
		return count + " =" + food;
	}

}

public class Test {

	public Test(int a) {

	}

	public static void main(String[] args) throws Exception {
		// fibonacci(0,1,20);
		// Class<?> clas = Class.forName("com.pract.Test");

		// Constructor<?> to = clas.getConstructor(int.class);
		// Test t = (Test) to.newInstance();
		var a = new Test(8);

		// System.out.println(Integer.toBinaryString(2));

		// new Random().ints(1,999).limit(20).sorted().forEach(System.out::println);
		// List<Integer> list = List.of(1,2,3,4,5);
		// System.out.println(list.stream().mapToInt(v->v).max().getAsInt());
		// list.stream().max(Integer::compare);

//		
//		longestPolindrom("bcac");
//	
//	majorityElement(new  int []{1,2,3,4,5,5});
//		
//	anagram("abcda","bcdaa");
//	String sp="TEST@$QWES 89";
//	sp = sp.replaceAll("\\d+","");
//	System.out.println(sp);

//arrayLeftRotation(new int[] {1,2,3,4,5},4);
//arrayRightRotation(new int[] {1,2,3,4,5},2);
//arraySum(new int[] {1,2,3,4},new int[] {1,2,3});
//uniqueFromArrays(new int[] {1,2,4},new int[] {1,2,3,5});
//wordCount("Hello what are you doing here you fucking bitch bastard");
//String s[]=textToWordsArray("Hello what are you doing here you fucking bitch bastard ab bcd");

//char arr[]=stringToArrayOfCharacters("hello what");

//twoSum(new int[] {2,7,11,15},9);
//		System.out.println(medianOfTwoSortedArray(new int[] {3},new int[] {-2,-1}));
//		System.out.println(longestPolindromSubtString("cbbd"));
		// zigzapConversion("PAYPALISHIRING",4);
//		Date d = new Date();
//		SimpleDateFormat f = new SimpleDateFormat("dd/MM/yyyy");
//		Date parse = f.parse("12/9/2023");
//		//LocalDate.now().
//		LocalDate l = LocalDate.now();
//		LocalDate l2 = LocalDate.of(2024, 10, 11);
//		Period period = Period.between(l, l2);
//		period.between(l, l2);
//		DayOfWeek dayOfWeek = l2.getDayOfWeek();
//		System.out.println(dayOfWeek.toString());

//		int arr[] = new int[] { 1, 2, 4 };
//		int arr2[] = new int[] { 1, 3, 4 };
		// righRotation(arr, 2);
//inserAtNthPos(arr,3,3);

//arr=insertInSortedArray(arr,6);
//System.out.println(2%5);
//arr=mergeSortedArrays(arr,arr2);
//System.out.println(Arrays.toString(arr))
		// reverserInteger(-1234);
//convertToInteger("  -1234");

		// AB.main(new String[] {"a","b"});
		// AB ab = new AB();
//		ab.hello();
//Comparator<Integer> com = new Comparator<Integer>() {
//
//	@Override
//	public int compare(Integer o1, Integer o2) {
//	   
//		return o1.intValue()>o2.intValue()?o2:o1;
//	}
//	
//};
//com = (c,b) -> c<b?1:-1;
//
//TreeSet<AB>  t = new TreeSet<>(); 
//		AB a1 = new AB();
//		a1.id=10;
//		AB a2 = new AB();
//		a2.id=20;
//		AB a3 = new AB();
//		a3.id=30;
//		AB a4 = new AB();
//		a4.id=40;
//		AB a5 = new AB();
//		a5.id=50;
//		
//		t.add(a1);
//		t.add(a2);
//		t.add(a3);
//		t.add(a4);
//		t.add(a5);
//		System.out.println(t);
		// System.out.println(integerToRoman(400));
		// System.out.println(romanToInteger("D"));
		// System.out.println(nonRepeatingChar("abcabc"));
		// System.out.println(longestPrefix(new String[] {"flow","flowight","flower"}));
//		int arr1[] = { 10, 8, 7, 5, 4, 11, 78 };
//		int arr3[] = { -1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4 };
//		Arrays.sort(arr3);
		// System.out.println(threeSum(arr3));
//		recursionBubbleSort(arr1,0,0);
//		System.out.println(Arrays.toString(arr1));
//		List.of(arr);

//		System.out.println(Arrays.toString(mergeTwoSortedArray(new int[] {1,3,5,7,9},new int[] {2,4,6,7,8})));
//		System.out.println(Arrays.toString(selectionSortRecu(new int[] {7,9,4,3,2,1,54,3},0,1,0)));

//		System.out.println(Arrays.toString(insertionSort(new int[] {9,8,6,5,4,3,5})));
		// System.out.println(uniqueOccurance(new int[] {1,1,1,2,2,2,3,4,4,5,4,5}));;
//		System.out.println(reverseKElements(new int[] {1,2,3,4,5,6,7,8,9},2));

		// System.out.println(isArraySortedOrRotated(new int[] {5,6,7,8,1}));
		// System.out.println(Arrays.toString(twoSum2(new int[] {2 ,7,8,5,2,1},9)));
		// System.out.println(longestPrefixs(new String[] {"ab","aba","ad"}));
		// System.out.println(Arrays.toString(removeDuplicatess(new int[]
		// {1,1,2,2,3,4,4,5,55,5})));
		// System.out.println(firstOccurances("hadbadhad","had"));
		// String s[]= {"aaa","aec","adc","ae"};
//		Arrays.sort(s);
//		System.out.println(lastWordLength("hello world jav   "));
		// System.out.println(Arrays.toString(plusOneOptimized(new int[] {9,9,})));
		// System.out.println(isPolindrom("5?6?7?876?5"));
		// System.out.println(reverseWords("A man, a plan, a canal: Panama"));
//		System.out.println(mostOccurrance("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(mostOccurranceInString("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(replaceString("a man is one the street"));
//	System.out.println(replaceAllDigitsWithCharacter("a1b2c3"));
		// System.out.println(removeAllSubstring("aabababa","aba"));
//System.out.println(removeAllDuplicates("aabbccdeffghill"));
		// System.out.println(1%2);
//		char ch[]=new char[] {'a','a','a','b','b','a','a'};
//		int n=countLetters(ch);
//		for(int i=0;i<n;i++) {
//			System.out.print(ch[i]+",");
// 		System.out.println(System.currentTimeMillis());
//		}
//		System.out.println(Arrays.toString(mergeSorted(new int[] {1,2,3,4},3,new int[] {2,5,6},2)));
		// int arr[][] = new int[][] { { 1, 2, 3} ,{ 4, 5, 6} ,{7,8,9}};
//		printWave(arr,2,3);
		// System.out.println(reverseVowels("hello"));
//		printSprial(arr);
//		generateMatrix(5);
//		arr = rotateArray90(arr);
//		for(int i=0;i<arr.length;i++) {
//			for(int j=0;j<arr[0].length;j++)
//				System.out.print(arr[i][j]+" ");
//			System.out.println();
//		}

//		int arr []= {1,2};
		// rotateArrayWithK(arr, 3);
//		int arr[][] = {{1,2,3},{4,5,6},{7,8,9}};  
//		List<List<Integer>> shiftGrid = shiftGrid(arr, 2);
//		for(int i =0 ;i<shiftGrid.size();i++) {
//			System.out.println(shiftGrid.get(i));
//		}

//		System.out.println(maximumSumOfTwoSubStringScore("00111"));
//		System.out.println(convertArrayIn2DArray(new int[] {1,2,3,4,5,5,6,200,200}));
//	System.out.println(missingNumber(new int[] {9,6,4,2,3,5,7,0,1}));	
//		System.out.println(unique(new int[] {1,1,2,2,3,3,9}));
		// System.out.println(Arrays.toString(findErrorNums(new int[] {1,2,2,4})));
		//	kajuKatli(10);
		System.out.println(System.currentTimeMillis());
		System.out.println(minOperations("1000"));
		System.out.println(System.currentTimeMillis());
	}

	public static int minOperations(String s) {
		int count[] = new int[2];
		for(int i=0;i<s.length();i++) {
			count[s.charAt(i)-'0']++;
		}
		if(count[0]>count[1]) {
			(count[0]-count[1])/2;
		}
			
		System.out.println(Arrays.toString(count));
		return 0;
	}
	
	
	public static int[] findErrorNums(int[] arr) {
		Set<Integer> value = new HashSet<>();
		int[] ar = new int[2];
		for (int i = 0; i < arr.length; i++) {
			if (value.contains(arr[i])) {
				ar[0] = arr[i];
				arr[1] = arr[i] + 1;
				System.out.println(arr[i] + 1);
				return ar;
			}
			value.add(arr[i]);
		}
		return ar;
	}

	public static int[] selectionSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			int min = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[j] < arr[min])
					min = j;
			}
			int temp = arr[i];
			arr[i] = arr[min];
			arr[min] = temp;

		}
		return arr;
	}

	public static int[] bubbleSortPr(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}

			}
		}
		return arr;
	}

	public static int unique(int arr[]) {
		int xor = 0;
		for (int i = 0; i < arr.length; i++) {
			xor ^= arr[i];
		}
		return xor;
	}

	public static int xorDuplicate(int arr[]) {

		for (int i = 0; i < arr.length; i++) {

		}
		return 0;
	}

	public static int missingNumber(int arr[]) {
		int max = findMaximum(arr);
		int total = max * (max + 1) / 2, sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return total - sum == 0 ? max + 1 : total - sum;
	}

	public static int countNumber(int arr[], int value) {
		int count = 0;

		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == value)
				count++;
			if (count > 2)
				return count;
		}
		return count;
	}

	public static int uniqueElement(int arr[]) {
		Set<Integer> value = Arrays.stream(arr).boxed().collect(Collectors.toSet());
		Iterator<Integer> iterator = value.iterator();
		while (iterator.hasNext()) {
			int va = iterator.next();
			if (count(arr, va) < 2)
				return va;
		}
		return -1;
	}

	public static int findMaximum(int arr[]) {
		int max = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] > max)
				max = arr[i];
		}
		return max;
	}

	public static List<List<Integer>> convertArrayIn2DArray(int arr[]) {
		// int max = findMaximum(arr);
		int count[] = new int[201];
		for (int i = 0; i < arr.length; i++)
			count[arr[i]]++;
//		System.out.println(Arrays.toString(count));
		int max = findMaximum(count);
		List<List<Integer>> response = new ArrayList<>();
		for (int i = 0; i < max; i++) {
			List<Integer> list = new ArrayList<>();
			for (int j = 0; j < count.length; j++) {
				if (count[j] > 0) {
					list.add(j);
					count[j]--;
				}
			}
			response.add(list);
		}

		return response;
	}

	public static int count(char arr[], int st, int end, char ch) {
		int count = 0;
		while (st <= end) {
			if (arr[st] == ch)
				count++;
			st++;
		}

		return count;
	}

	public static int maximumSumOfTwoSubStringScore(String s) {
		char[] arr = s.toCharArray();
		int i = 0, j = i + 1, max = 0;
		while (i < j && j < arr.length) {
			int cou = count(arr, i, j - 1, '0') + count(arr, j, arr.length - 1, '1');

			if (cou > max)
				max = cou;
			j++;
		}
		return max;
	}

	public static List<List<Integer>> shiftGrid(int arr[][], int k) {
		int row = arr.length, col = arr[0].length, j = row * col - 1, count = 0;
		while (count++ < k) {
			int ele = arr[arr.length - 1][arr[0].length - 1];
			for (j = row * col - 1; j > 0; j--) {
				arr[j / col][j % col] = arr[(j - 1) / col][(j - 1) % col];
			}
			arr[0][0] = ele;

		}
		List<List<Integer>> ar = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			List<Integer> ro = new ArrayList<>();
			for (j = 0; j < arr[0].length; j++) {
				ro.add(arr[i][j]);
			}
			ar.add(ro);

		}
		return ar;
	}

	public static boolean binarySearch2DInSortedRow(int arr[][], int target) {
		int row = 0, col = arr[0].length - 1;

		while (col >= 0 && row <= arr.length - 1) {
			if (arr[row][col] == target)
				return true;
			if (arr[row][col] < target)
				row++;
			else
				col--;
		}
		return false;
	}

	public static boolean binarySearchIn2D(int arr[][], int target) {
		int row = arr.length;
		int col = arr[0].length;
		int st = 0;
		int end = row * col - 1;

		while (st <= end) {
			int mid = st + (end - st) / 2;
			int element = arr[mid / col][mid % col];
			if (element == target)
				return true;
			if (element < target)
				st = mid + 1;
			else
				end = mid - 1;

		}
		return false;

	}

	public static void rotateArrayWithK(int arr[], int k) {
		int arr2[] = new int[arr.length], l = 0;
		int kIndex = arr.length - k;

		if (k >= arr.length) {
			int count = 0;
			while (count++ <= k) {
				int temp = arr[arr.length - 1];
				System.out.println(Arrays.toString(arr));
				for (int j = arr.length - 1; j > 0; j--) {
					arr[j] = arr[j - 1];
				}
				arr[0] = temp;
			}
			return;
		}

		if (kIndex < 0)
			return;
		for (int i = kIndex; i < arr.length; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < kIndex; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < arr.length; i++)
			arr[i] = arr2[i];

	}

	public static int[][] rotateArray90(int arr[][]) {
		int arr3[][] = new int[arr.length][arr[0].length], k = 0;
		for (int col = 0; col < arr[0].length; col++) {
			k = 0;
			for (int row = arr.length - 1; row >= 0; row--) {
				arr3[col][k++] = arr[row][col];
			}

		}
		return arr3;
	}

	public static int[][] generateMatrix(int n) {
		int row = n;
		int col = n;
		int total = n * n;
		int startingCol = 0;
		int startingRow = 0;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int arr[][] = new int[n][n];
		int count = 0;
		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				arr[startingRow][i] = ++count;
			}

			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				arr[i][endingCol] = ++count;
			}

			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				arr[endingRow][i] = ++count;
			}

			endingRow--;

			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				arr[i][startingCol] = ++count;
			}
			startingCol++;

		}
		return arr;
	}

	public static void printSprial(int arr[][]) {
		int startingCol = 0;
		int startingRow = 0;
		int row = arr.length;
		int col = arr[0].length;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int count = 0;
		int total = row * col;

		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				System.out.print(arr[startingRow][i]);
				count++;
			}
			System.out.println();
			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				System.out.print(arr[i][endingCol]);
				count++;
			}

			System.out.println();
			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				System.out.print(arr[endingRow][i]);
				count++;
			}

			endingRow--;
			System.out.println();
			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				System.out.print(arr[i][startingCol]);
				count++;
			}
			startingCol++;
			System.out.println();
		}
	}

	public static boolean isVowel(char ch) {
		ch = Character.toLowerCase(ch);
		if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
			return true;
		return false;
	}

	public static String reverseVowels(String s) {

		char[] arr = s.toCharArray();
		int i = 0, j = arr.length - 1;
		while (i < j) {
			if (isVowel(arr[i]) && isVowel(arr[j])) {
				char t = arr[i];
				arr[i] = arr[j];
				arr[j] = t;
				i++;
				j--;
			} else if (isVowel(arr[i]))
				j--;
			else
				i++;
		}
		return new String(arr);
	}

	public static void printWave(int arr[][], int row, int col) {
		for (int j = 0; j < col; j++) {

			for (int i = 0; i < row; i++) {
				System.out.print(arr[i][j]);
			}

			System.out.println();
			j++;
			for (int i = row - 1; i >= 0 && j < col; i--) {
				System.out.print(arr[i][j]);
			}
			System.out.println();

		}
	}

	public static int[] mergeSorted(int arr[], int m, int arr1[], int n) {
		int arr3[] = new int[m + n], i = 0, j = 0, k = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j] && n > 0) {
				arr3[k++] = arr1[j++];
				n--;
			} else if (m > 0) {
				arr3[k++] = arr[i++];
				m--;
			} else
				break;

		}
		System.out.println(Arrays.toString(arr3));
		while (m > 0 && i < arr.length) {
			arr3[k++] = arr[i++];
			m--;
		}
		while (n > 0 && j < arr1.length) {
			arr3[k++] = arr1[j++];
			n--;
		}
		return arr3;
	}

	public static List<Foodsystem> system = new ArrayList<>();

	public void enterData() {
		String food[] = { "kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi" };
		String country[] = { "korean", "japanese", "japanese", "greek", "japanese", "korean" };
		int arr[] = { 9, 12, 8, 15, 14, 7 };
		for (int i = 0; i < country.length; i++) {
			Map<String, Integer> fs = new LinkedHashMap<>();
			Foodsystem s = new Foodsystem();
			s.count = country[i];
			s.food.put(food[i], arr[i]);
			this.add(s);
		}
		System.out.println(system);

	}

	public void add(Foodsystem o) {
		for (int i = 0; i < this.system.size(); i++) {
			if (system.get(i).count.equals(o.count)) {
				system.get(i).food.putAll(o.food);
				return;
			}

		}
		this.system.add(o);
	}

	public void changeRating(String food, int rating) {
		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem f = system.get(i);
			if (f.food.containsKey(food)) {
				f.food.put(food, rating);
				return;
			}

		}

	}

	public String highestRating(String country) {
		String city = "";

		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem s = system.get(i);
			if (s.count.equals(country)) {
				int max = 0;
				Set<Entry<String, Integer>> entrySet = s.food.entrySet();
				System.out.println(entrySet);
				for (Entry<String, Integer> e : entrySet) {
					if (e.getValue() > max) {
						max = e.getValue();
						city = e.getKey();

					}
					if (e.getValue() == max) {
						s.food.put(e.getKey(), e.getValue());
					}
				}
			}

		}

		return city;
	}

	public static int countLetters(char[] s) {
		int k = 0;
		for (int i = 0; i < s.length;) {
			char ch = s[i];
			int j = i + 1, count = 1;

			while (j < s.length && s[j] == ch) {
				count++;
				j++;
			}
			System.out.println(ch + " " + count + " " + j);
			if (count > 1) {
				s[k++] = ch;
				for (char c : Integer.toString(count).toCharArray()) {
					if (k < s.length)
						s[k++] = c;
					else
						return k;
				}
			} else {
				s[k++] = ch;
			}
			i = j;
		}
		return k;
	}

	public static String removeAllDuplicates(String s) {
		StringBuilder sb = new StringBuilder();
		int count[] = new int[26];
		for (int i = 0; i < s.length(); i++) {
			int num = s.charAt(i) - 'a';
			count[num]++;
		}

		for (int i = 0; i < s.length(); i++) {
			if (count[(s.charAt(i) - 'a')] < 2)
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static String removeAllSubstring(String s, String part) {
		while (s.length() != 0 && s.contains(part))
			s = s.replaceFirst(part, "");

		return s;
	}

	public static String replaceAllDigitsWithCharacter(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
				sb.append((char) (s.charAt(i - 1) + (s.charAt(i) - 48)));
			else
				sb.append(s.charAt(i));
		}
		return sb.toString();

	}

	public static String replaceString(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == ' ')
				sb.append("@40");
			else
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static char mostOccurranceInString(String s) {
		int arr[] = new int[26]; // storing occurance of every letter according to index
		s = s.toLowerCase();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
				int num = s.charAt(i) - 'a';
				arr[num]++;
			}
		}

		// finding max
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < arr.length; i++) {
			if (max < arr[i]) {
				max = arr[i];
				ch = (char) i;
			}

		}
		return (char) (ch + 'a');

	}

	// brute force
	public static char mostOccurrance(String s) {
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < s.length(); i++) {
			int count = 0;
			for (int j = i + 1; j < s.length(); j++) {
				if (s.charAt(i) == s.charAt(j) && s.charAt(i) != ' ')
					count++;
			}

			if (count > max) {
				ch = s.charAt(i);
				max = count;
			}
		}
		return ch;
	}

	public static int climbStairs(int n) {

		if (n < 0)
			return 0;
		if (n == 0)
			return 1;
		return climbStairs(n - 1) + climbStairs(n - 2);
	}

	public static void reverseString(char[] ch, int st, int end) {

		while (st < end) {
			char temp = ch[st];
			ch[st] = ch[end];
			ch[end] = temp;
			st++;
			end--;
		}

	}

	public static char[] reverseWords(String s) {
		char ch[] = s.toCharArray();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ' && s.charAt(i) != ',') {
				int j = i + 1;
				for (; j < s.length(); j++) {
					if (s.charAt(j) == ' ' || s.charAt(j) == ',')
						break;
				}
				reverseString(ch, i, j - 1);
				i = j;
			}
		}
		return ch;
	}

	public static boolean isAlphaNumeric(char c) {
		if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9')
			return true;
		return false;
	}

	public static boolean isPolinromValidAlgo(String s) {
		StringBuilder b = new StringBuilder();
		// remove special characters only left alphanumeric
		for (int i = 0; i < s.length(); i++) {
			if (isAlphaNumeric(s.charAt(i)))
				b.append(s.charAt(i));

		}

		// to lower case
		String str = b.toString().toLowerCase();
		int st = 0, end = str.length() - 1;
		while (st < end) {
			if (str.charAt(st) != str.charAt(end))
				return false;
			st++;
			end--;
		}
		return true;

	}

	public static boolean isPolindrom(String s) {
		int st = 0, end = s.length() - 1;
		while (st < end) {
			if (s.charAt(st) >= '0' && s.charAt(st) <= '9') {
				if (s.charAt(end) >= '0' && s.charAt(end) <= '9') {

					if (s.charAt(st) != s.charAt(end))
						return false;
					else {
						st++;
						end--;
					}
				} else
					end--;
			} else
				st++;
		}
		return true;
	}

	// optimized
	public static int[] plusOneOptimized(int arr[]) {
		for (int i = arr.length - 1; i >= 0; i--) {
			if (arr[i] < 9) {
				arr[i]++;
				return arr;
			}
			arr[i] = 0;
		}
		arr = new int[arr.length + 1];
		arr[0] = 1;
		return arr;
	}

	// brute force
	public static int[] plusOne(int arr[]) {
		if (arr.length < 1)
			return arr;
		int carry = 1;
		for (int i = arr.length - 1; i >= 0; i--) {
			arr[i] = arr[i] + carry;
			carry = 0;
			if (arr[i] > 9) {
				arr[i] = 0;
				carry = 1;
			} else
				break;
		}

		if (carry != 0) {
			int ar[] = new int[arr.length + 1];
			ar[0] = carry;
			for (int i = 1; i < ar.length - 1; i++)
				ar[i] = arr[i];
			return ar;
		}
		return arr;
	}

	public static int countLastWordLength(String s, int index) {
		int count = 0;
		for (; index >= 0; index--) {
			if (s.charAt(index) != ' ')
				count++;
			else
				break;
		}
		return count;
	}

	public static int lastWordLength(String s) {
		for (int i = s.length() - 1; i >= 0; i--) {
			if (s.charAt(i) != ' ')
				return countLastWordLength(s, i);
		}
		return 0;
	}

	public static int firstOccurances(String s, String value) {
		if (s.contains(value)) {
			return s.indexOf(value);
		}
		return -1;
	}

	public static boolean isMatched(String s, String value) {
		if (s.length() < value.length())
			return false;
		for (int i = 0; i < value.length(); i++) {
			if (s.charAt(i) != value.charAt(i))
				return false;
		}
		return true;
	}

	public static int firstOccurance(String s, String value) {
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == value.charAt(0)) {
				if (isMatched(s.substring(i), value))
					return i;
			}
		}
		return -1;
	}

	public static int[] removeDuplicatess(int arr[]) {
		int i = 0, j = 1;
		for (i = 1; i < arr.length; i++) {
			if (arr[i - 1] != arr[i])
				arr[j++] = arr[i];
		}
		return arr;
	}

	public static int[] removeDuplicates(int arr[]) {
		Set<Integer> set = new LinkedHashSet<>();
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		return set.stream().mapToInt(i -> i).toArray();

	}

	public static String longestPrefixs(String arr[]) {
		Arrays.sort(arr);
		StringBuilder b = new StringBuilder();
		String first = arr[0];
		String last = arr[arr.length - 1];
		for (int i = 0; i < Math.min(first.length(), last.length()); i++) {
			if (first.charAt(i) != last.charAt(i))
				return b.toString();
			b.append(first.charAt(i));
		}
		return b.toString();

	}

	public static int[] twoSum2(int[] arr, int target) {
		int f = 0, l = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 1; j < arr.length; j++) {
				if (arr[i] + arr[j] == target) {
					f = i;
					l = j;
				}
			}
		}
		return new int[] { f, l };
	}

	public static Boolean arraySortedOrRotated(int arr[]) {
		int count = 0;
		for (int i = 1; i < arr.length; i++) {
			if (arr[i - 1] > arr[i])
				count++;
		}
		if (arr[0] < arr[arr.length - 1])
			count++;

		return count == 1;
	}

	// brute force
	public static Boolean isArraySortedOrRotated(int arr[]) {
		int i = 0;
		for (i = 0; i < arr.length - 1; i++) {
			if (arr[i] > arr[i + 1])
				break;

		}
		System.out.println(i + " -<");
		i++;
		for (; i < arr.length - 1; i++) {
			System.out.println("->" + i);
			if (arr[0] < arr[i] || arr[i] > arr[i + 1])
				return false;
		}
		if (i < arr.length && arr[0] < arr[i])
			return false;
		return true;
	}

	public static int findUnique(int arr[]) {
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {

			ans = ans ^ arr[i];
		}
		return ans;
	}

	public static int count(int arr[], int value) {
		int count = 0;
		for (int i = 0; i < arr.length; i++) {
			if (value == arr[i])
				count++;
		}
		return count;

	}

	public static int uniqueOccurance(int arr[]) {
		int arr1[] = new int[arr.length], k = 0;
		for (int i = 0; i < arr.length; i++) {
			if (!isPreExists(arr[i], arr, i - 1)) {

				int count = count(arr, arr[i]);
				arr1[k++] = count;
				System.out.println("count " + count);
			}
		}
		return findUniqueElement(arr1);
	}

	public static int[] reverse(int arr[], int st, int end) {
		if (end < arr.length)
			while (st < end) {
				int k = arr[st];
				arr[st++] = arr[end];
				arr[end--] = k;
			}
		return arr;
	}

	public static int[] reverseKElements(int arr[], int k) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length; i += k) {

			reverse(arr, i, i + k - 1);
		}
		System.out.println(Arrays.toString(arr));
		return arr;

	}

	public static boolean isPreExists(int value, int arr[], int k) {
		for (int i = k; i >= 0; i--) {
			if (arr[i] == value)
				return true;
		}
		return false;
	}

	public static int findUniqueElement(int arr[]) {
		System.out.println(Arrays.toString(arr));
		for (int i = 0; i < arr.length; i++) {
			int count = 0;
			if (!isPreExists(arr[i], arr, i - 1))
				for (int j = i; j < arr.length; j++) {

					if (arr[i] == arr[j])
						count++;
				}

			if (count == 1) {
				System.out.println("found " + arr[i]);

				return arr[i];
			}
		}
		return 0;
	}

	public static int[] insertionSort(int arr[]) {
		int j = 0;
		for (int i = 0; i < arr.length; i++) {
			int k = arr[i];
			for (j = i - 1; j >= 0; j--) {
				if (arr[j] < k) {
					arr[j + 1] = arr[j];
				} else
					break;
			}
			arr[j + 1] = k;
		}
		return arr;
	}

	public static int[] selectionSortRecu(int arr[], int i, int j, int min) {
		if (i >= arr.length)
			return arr;
		if (j < arr.length) {
			if (arr[min] > arr[j])
				min = j;
			return selectionSortRecu(arr, i, j + 1, min);
		}
		int k = arr[i];
		arr[i] = arr[min];
		arr[min] = k;
		return selectionSortRecu(arr, i + 1, i + 2, i + 1);
	}

	public static int[] mergeTwoSortedArray(int arr[], int arr1[]) {
		int arr3[] = new int[arr.length + arr1.length], k = 0, i = 0, j = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j]) {
				arr3[k++] = arr1[j++];

			} else {
				arr3[k++] = arr[i++];

			}
		}

		while (i < arr.length) {
			arr3[k++] = arr[i++];
		}
		while (j < arr1.length) {
			arr3[k++] = arr1[i++];
		}
		return arr3;
	}

	public static void recursionBubbleSort(int arr[], int i, int j) {
		if (i == arr.length)
			return;
		if (j < arr.length - i - 1 && arr[j] > arr[j + 1]) {

			int k = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = k;
			System.out.println(Arrays.toString(arr));
			recursionBubbleSort(arr, i, j + 1);

		} else {
			System.out.println("----- " + Arrays.toString(arr));
			recursionBubbleSort(arr, i + 1, 0);
		}

	}

	public static void bubbleSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int k = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = k;
				}

			}
		}
	}

	public static List<List<Integer>> threeSum(int arr[]) {
		int i = 0, j = 0, k = arr.length - 1;
		Set<List<Integer>> output = new HashSet<>();
		for (i = 0; i < arr.length; i++) {
			j = i + 1;
			k = arr.length - 1;
			while (j < k) {
				System.out.println(arr[i] + "->" + arr[j] + "->" + arr[k] + "=> " + (arr[i] + arr[j] + arr[k]) + " ( "
						+ i + "," + j + "," + k);
				if (arr[i] + arr[j] + arr[k] == 0) {
					List<Integer> list = new ArrayList<>();
					list.add(arr[i]);
					list.add(arr[j]);

					list.add(arr[k]);
					output.add(list);
				} else if (arr[i] + arr[j] + arr[k] > 0) {
					k--;
					j--;
				}
				j++;

			}
		}

		return output.stream().toList();

	}

	public static String longestPrefix(String s[]) {

		String prefix = "";

		for (int i = 0; i < s.length; i++) {
			for (int j = i + 1; j < s.length; j++) {
				if (s[i].length() > s[j].length()) {
					String temp = s[i];
					s[i] = s[j];
					s[j] = temp;
				}
			}
		}

		String st = s[0];
		boolean isMatched = false;
		for (int j = 0; j < st.length(); j++) {
			char ch = st.charAt(j);

			for (int k = 1; k < s.length; k++) {
				isMatched = false;

				if (ch == s[k].charAt(j)) {
					isMatched = true;
				} else
					break;
			}
			if (isMatched)
				prefix += ch;
			else
				break;

		}
		;
		return prefix;

	}

	public static String nonRepeatingChar(String s) {
		for (int i = 0; i < s.length(); i++) {
			boolean isPresent = false;
			for (int j = 0; j < s.length(); j++) {
				if (i != j && s.charAt(i) == s.charAt(j)) {
					isPresent = true;
					break;
				}
			}
			if (!isPresent) {
				return s.charAt(i) + "";
			}
		}
		return "All Are repated";
	}

	public static Integer romanToInteger(String s) {
		int num = 0;
		Map<String, Integer> romans = new HashMap<>();
		romans.put("M", 1000);
		romans.put("CM", 900);
		romans.put("D", 500);
		romans.put("CD", 400);
		romans.put("C", 100);
		romans.put("XC", 90);
		romans.put("L", 50);
		romans.put("XL", 40);
		romans.put("X", 10);
		romans.put("IX", 9);
		romans.put("V", 5);
		romans.put("IV", 4);
		romans.put("I", 1);
//System.out.println(romans.get("M"));
		if (s.length() < 2)
			return romans.get(s.charAt(0) + "");
		for (int i = 0; i < s.length() - 1; i++) {

			if (romans.get(s.charAt(i) + "").intValue() >= romans.get(s.charAt(i + 1) + "").intValue()) {
				num += romans.get(s.charAt(i) + "");
				System.out.println("num -> " + num);
			} else {

				int sum = romans.get(s.charAt(i + 1) + "") - romans.get(s.charAt(i) + "");
				System.out.println("num    => " + num + "  sum => " + sum);
				num += sum;
				i++;
				System.out.println("--------- " + num);
			}
			if (i == s.length() - 2)
				if (romans.get(s.charAt(i + 1) + "").intValue() <= romans.get(s.charAt(i) + "").intValue()) {
					num += romans.get(s.charAt(i + 1) + "");

				}
		}
		return num;
	}

	public static String integerToRoman(int num) {
		Integer number[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
		String romans[] = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };
		String result = "";
		for (int i = 0; i < number.length; i++) {

			while (num >= number[i]) {
				num -= number[i];
				result += romans[i];
			}
		}
		return result;

	}

	public static int convertToInteger(String s) {
		String st = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {
				st += s.charAt(i);
			} else if (s.charAt(i) == '-')
				st += s.charAt(i);
		}
		System.out.println(Integer.parseInt(st));
		return 0;
	}

	public static int reverserInteger(int n) {
		int rev = 0;
		while (n != 0) {
			int r = n % 10;
			n /= 10;
			rev = rev * 10 + r;
		}
		System.out.println(rev);
		return 0;
	}

	public static int[] mergeSortedArrays(int a1[], int a2[]) {
		int a3[] = new int[a1.length + a2.length], j = 0, k = 0, i = 0;

		Stack<Character> stack = new Stack();
		String s = "a";
		Character c = s.charAt(i);
		System.out.println(c.equals(c));

		while (i < a1.length && j < a2.length) {

			if (a1[i] >= a2[j])
				a3[k++] = a2[j++];
			else
				a3[k++] = a1[i++];

		}
		while (i < a1.length)
			a3[k++] = a1[i++];

		while (j < a2.length)
			a3[k++] = a2[j++];

		return a3;

	}

	public static int[] insertInSortedArray(int arr[], int value) {
		int temp[] = new int[arr.length + 1], j = 0;
		boolean isInserted = false;
		for (int i = 0; i < arr.length; i++) {

			if (!isInserted && arr[i] > value) {
				temp[j++] = value;
				isInserted = true;
			}
			temp[j++] = arr[i];
		}
		if (!isInserted)
			temp[j++] = value;
		return temp;
	}

	public static int[] inserAtNthPos(int arr[], int value, int pos) {
		int j = 0;
		int temp[] = new int[arr.length + 1];
		if (pos < 1)
			return arr;

		for (int i = 0; i < arr.length; i++) {
			if (i == pos - 1)
				temp[j++] = value;

			temp[j++] = arr[i];
		}
		if (pos > arr.length) {
			temp[j++] = value;
		}

//	for(int i=0;i<temp.length;i++)
//		arr[i]=temp[i];
		return temp;
	}

	public static void righRotation(int arr[], int num) {
		int n = arr.length, temp = 0, count = 0;
		while (count++ < num) {
			temp = arr[n - 1];
			for (int i = n - 1; i > 0; i--)
				arr[i] = arr[i - 1];
			arr[0] = temp;
		}

	}

	public static void leftRotation(int arr[], int num) {
		int temp[] = new int[arr.length], n = arr.length, j = 0;

		for (int i = num; i < n; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < num; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < n; i++)
			arr[i] = temp[i];
	}

	public static char[] copyArray(char[] arr) {
		if (arr == null)
			return new char[1];

		char[] a = Arrays.copyOf(arr, arr.length + 1);
		return a;
	}

	public static String zigzapConversion(String s, int num) {
		char[][] arr = new char[num][];
		int k = 0, i = 0, j = 0, t = 0;
		while (k < s.length()) {
			while (i != num - 1) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i++;
			}
			j++;
			while (i != 0) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i--;
			}
			j++;

		}
		for (char[] a : arr) {
			for (char tt : a)
				System.out.print(tt);
			System.out.println();
		}
		return "";
	}

	public static String longestPolindromSubtString(String s) {
		String ans = "";
		if (s.length() < 1)
			return s;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - 1; j >= 0; j--) {
				if (i < j) {
					String sub = s.substring(i, j + 1);
					if (sub.equals(new StringBuilder(sub).reverse().toString())) {
						if (sub.length() > ans.length()) {
							ans = sub;
						}

					}
				}
			}
		}

		return ans;
	}

	public static double medianOfTwoSortedArray(int[] arr1, int[] arr2) {

		int arr3[] = new int[arr1.length + arr2.length], i = 0, j = 0, k = 0;
		while (true) {
			if (i < arr1.length) {
				arr3[k++] = arr1[i++];
			} else if (j < arr2.length) {
				arr3[k++] = arr2[j++];
			} else
				break;

		}
		double ans = 0;
		Arrays.sort(arr3);
		System.out.println(Arrays.toString(arr3));
		if (arr3.length % 2 == 0) {
			int mid = arr3.length / 2;
			ans = (double) (arr3[mid - 1] + arr3[mid]) / 2;
			System.out.println(arr3[mid - 1]);
		} else {
			ans = arr3[arr3.length / 2];
		}

		return ans;
	}
// 4
// 1,1,1,1
// 2,1,1
// 1,1,2
// 2,2

	public static int[] twoSum(int arr[], int target) {
		int f = 0, sec = 0;
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {
				if (arr[i] + arr[j] == target && i != j) {

					f = i;
					sec = j;
				}
			}

		}
		System.out.println(f + " " + sec);
		return new int[] { f, sec };
	}

	public static char[] stringToArrayOfCharacters(String s) {
		char arr[] = new char[s.length()];
		for (int i = 0; i < s.length(); i++) {
			arr[i] = s.charAt(i);
		}
		return arr;
	}

	public static String[] textToWordsArray(String text) {
		List<String> words = new ArrayList<>();
		for (int i = 0; i < text.length(); i++) {

			for (int j = i; j < text.length() - 1; j++) {
				if (i > 0 && text.charAt(i) == ' ' && text.charAt(j + 1) == ' ' && text.charAt(i - 1) != ' ') {
					words.add(text.substring(i + 1, j + 1));
					break;
				} else if (i == 0 && text.charAt(j + 1) == ' ') {
					words.add(text.substring(i, j + 1));
					break;
				} else if (text.charAt(i) == ' ' && j + 1 == text.length() - 1) {
					words.add(text.substring(i + 1, text.length()));
					break;
				}
			}

		}
		String s[] = new String[words.size()];
		int i = 0;
		ListIterator<String> listIterator = words.listIterator();
		while (listIterator.hasNext()) {
			s[i++] = listIterator.next();
		}
		return s;
	}

	public static int wordCount(String s) {
		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0)
				count++;
			else if (s.charAt(i) == ' ')
				for (int j = i; j < s.length() - 1; j++) {
					if (s.charAt(j + 1) == ' ' && s.charAt(i - 1) != ' ') {
						count++;
						System.out.print(s.charAt(i) + " - > " + s.charAt(j) + " = " + count);
						break;
					}
				}
		}
		return count + 1;

	}

	public static void uniqueFromArrays(int arr[], int arr2[]) {

		List<Integer> list1 = List.of(1, 2, 4);
		List<Integer> list2 = List.of(1, 2, 3, 5);
		List<Integer> unique = new ArrayList<>();
		unique.addAll(list1);
		unique.addAll(list2);
		unique = unique.stream().distinct()
				.filter(a -> list1.contains(a) && !list2.contains(a) || !list1.contains(a) && list2.contains(a))
				.collect(Collectors.toList());
		System.out.println(unique);

		int k = 0;
		for (int i = 0; i < arr.length || k < arr2.length; i++, k++) {
			boolean a = false;
			boolean b = false;
			if (i < arr.length)
				for (int j = 0; j < arr2.length; j++) {
					if (arr[i] == arr2[j])
						a = true;
				}
			for (int j = 0; j < arr.length; j++) {
				if (arr2[k] == arr[j])
					b = true;
			}
			if (!a && i < arr.length)
				System.out.println(arr[i]);
			if (!b)
				System.out.println(arr2[k]);
		}
	}

	public static void arraySum(int arr[], int arr2[]) {
		int carry = 0, total = 0, j = 0, k = arr2.length - 1, i;
		List<Integer> sum = new ArrayList<>();

		for (i = arr.length - 1; i >= 0 && k >= 0; i--, k--) {

			total = arr[i] + arr2[k] + carry;
			carry = 0;
			if (total > 9) {
				carry = total % 10;
				total /= 10;
			}
			sum.add(total);

		}

		if (i < 0 && k >= 0) {
			for (int a = k; a >= 0; a--)
				sum.add(arr2[a]);
		}
		if (k < 0 && i >= 0) {
			for (int a = i; a >= 0; a--)
				sum.add(arr[a]);
		}
		Collections.reverse(sum);
		System.out.println(sum);
	}

	public static void arrayRightRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[arr.length - 1];
			for (j = arr.length - 1; j > 0; j--) {
				arr[j] = arr[j - 1];
			}
			count++;
			arr[0] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static void arrayLeftRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[0];
			for (j = 0; j < arr.length - 1; j++) {
				arr[j] = arr[j + 1];
			}
			count++;
			arr[j] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static boolean anagram(String s, String s1) {

		int count = 0;
		boolean b = false;
		for (int i = 0; i < s.length(); i++) {
			char ch = s.charAt(i);
			count = 0;
			b = false;
			for (int k = 0; k < s.length(); k++) {
				if (ch == s.charAt(k))
					count++;
			}

			for (int j = 0; j < s1.length(); j++) {
				if (count > 0 && ch == s1.charAt(j))
					count--;
			}
			if (count == 0)
				b = true;
		}

		System.out.println(b ? "yes" : "no");
		return b;
	}

	public static int count(int i, int arr[]) {
		int count = 0;
		for (int a : arr) {
			if (a == i)
				count++;
		}
		System.out.println(count);
		return count;
	}

	public static void majorityElement(int arr[]) {
		int max = 0, count = 0;
		for (int i = 0; i < arr.length; i++) {
			count = count(arr[i], arr);
			if (count >= max && count > arr.length / 2)
				max = arr[i];

		}
		System.out.println(max);
	}

	public static void longestPolindrom(String s) {

		int first = 0, last = s.length() - 1, max = 0;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - i; j >= 0; j--) {
				if (i < j && j < s.length())
					if (checkPolindrom(i, j + 1, s) && max < s.substring(i, j).length()) {

						max = s.substring(i, j + 1).length();
						first = i;
						last = j + 1;
					}
			}
			System.out.println("------");

		}
		System.out.println(s.substring(first, last));

	}

	public static boolean checkPolindrom(int f, int l, String s) {
		String st = s.substring(f, l);
		System.out.println(st + "444");
		return st.equals(new StringBuffer(st).reverse().toString());

	}

	public void spiralMatrix() throws ClassNotFoundException, NoSuchMethodException, SecurityException,
			InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		int a[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };
		int j = 0, k = 0, count = 0, max = 10 - 1;
		// int max=a.length*a.length-1;
		// System.out.println(a.length);

		for (int i = 0; i < a.length - i; i++) {

			if (count == max)
				break;

			for (j = i; j < a.length - i && count <= max; j++) {
				count++;
				System.out.println(a[k][j]);
			}
			j--;

			k++;
			while (k < a.length - i && count <= max) {
				System.out.println(a[k][j]);
				k++;
				count++;
			}
			k--;
			j--;

			while (j >= 0 && count <= max) {
				count++;
				System.out.println(a[k][j--]);
			}

			// k=i+1;
			if (k == a.length / 2 && j == a.length / 2)
				break;
			j++;
			while (k > i + 1 && count <= max) {
				System.out.println(a[--k][j]);
				count++;
			}

			k = i + 1;
			System.out.println("-----------------");
		}

	}

	public static ArrayList<Integer> findIndexes(int arr[], int sum) {
		boolean a = false;
		int f = 0, l = arr.length, s = 0;
		for (int i = 0; i < arr.length; i++) {
			s = 0;
			if (a)
				break;

			for (int j = i; j < arr.length; j++) {
				s += arr[j];
				if (s == sum) {
					f = i;
					l = j;
					a = true;
					break;
				}

			}
			System.out.println(s);
		}

		return a ? new ArrayList<Integer>(Arrays.asList(f, l)) : new ArrayList<Integer>(Arrays.asList(-1));
	}

	public int count(char a, String s) {
		class A {
			static int a;

			public void main() {
				System.out.println("hello");
			}
		}

		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == a)
				count++;
		}
		return count;
	}

	public static boolean isPresent(char a, int indx, String s) {
		for (int i = indx; i >= 0; i--) {
			if (s.charAt(i) == a)
				return true;
		}
		return false;
	}

	public static boolean isPresent(int a, int indx, int ar[]) {
		for (int i = indx; i >= 0; i--) {
			if (ar[i] == a)
				return true;
		}
		return false;
	}

	public static void fibonacci(int t1, int t2, int n) {
		if (n == 0)
			return;
		else {
			int t3 = t1 + t2;
			t1 = t2;
			t2 = t3;
			System.out.println(t3);
			fibonacci(t1, t2, n - 1);
		}

	}

	public static int factorial(int n) {
		if (n == 1)
			return 1;
		else
			n = n * factorial(n - 1);
		return n;

	}

	public static String removeSpaces(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ')
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static int[] removeDuplicate(int[] a) {
		int arr[] = new int[a.length];
		int j = 0;
		for (int i = 0; i < a.length; i++) {
			if (!isPresent(a[i], i - 1, a))
				arr[j++] = a[i];
		}
		a = new int[j];
		System.out.println(j);
		for (int i = 0; i < j; i++)
			a[i] = arr[i];
		return a;
	}

	class C {
		static int a;
	}
}

class B {
	int a = 10;

	public String toString() {
		System.out.println("askfjal");
		return new String(this.a + "");
	}

	public void hello(int... a) {

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-12-24 23:20:53.112
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-12-24 23:20:53.113
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-12-24 23:20:53.210
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.pract;

import java.lang.reflect.InvocationTargetException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.springframework.jdbc.core.metadata.OracleCallMetaDataProvider;

interface DD {

}

class AB implements Comparable<AB> {
	int id = 0;
	String name = "rohit";

	@Override
	public int compareTo(AB o) {
		if (this.id < o.id)
			return 1;

		return -1;
	}

	@Override
	public String toString() {
		return "AB [id=" + id + ", name=" + name + "]";
	}

}

abstract class kd {

}

class Foodsystem {
	public String count;
	public Map<String, Integer> food = new LinkedHashMap<>();

	public String toString() {
		return count + " =" + food;
	}

}

public class Test {

	public Test(int a) {

	}

	public static void main(String[] args) throws Exception {
		// fibonacci(0,1,20);
		// Class<?> clas = Class.forName("com.pract.Test");

		// Constructor<?> to = clas.getConstructor(int.class);
		// Test t = (Test) to.newInstance();
		var a = new Test(8);

		// System.out.println(Integer.toBinaryString(2));

		// new Random().ints(1,999).limit(20).sorted().forEach(System.out::println);
		// List<Integer> list = List.of(1,2,3,4,5);
		// System.out.println(list.stream().mapToInt(v->v).max().getAsInt());
		// list.stream().max(Integer::compare);

//		
//		longestPolindrom("bcac");
//	
//	majorityElement(new  int []{1,2,3,4,5,5});
//		
//	anagram("abcda","bcdaa");
//	String sp="TEST@$QWES 89";
//	sp = sp.replaceAll("\\d+","");
//	System.out.println(sp);

//arrayLeftRotation(new int[] {1,2,3,4,5},4);
//arrayRightRotation(new int[] {1,2,3,4,5},2);
//arraySum(new int[] {1,2,3,4},new int[] {1,2,3});
//uniqueFromArrays(new int[] {1,2,4},new int[] {1,2,3,5});
//wordCount("Hello what are you doing here you fucking bitch bastard");
//String s[]=textToWordsArray("Hello what are you doing here you fucking bitch bastard ab bcd");

//char arr[]=stringToArrayOfCharacters("hello what");

//twoSum(new int[] {2,7,11,15},9);
//		System.out.println(medianOfTwoSortedArray(new int[] {3},new int[] {-2,-1}));
//		System.out.println(longestPolindromSubtString("cbbd"));
		// zigzapConversion("PAYPALISHIRING",4);
//		Date d = new Date();
//		SimpleDateFormat f = new SimpleDateFormat("dd/MM/yyyy");
//		Date parse = f.parse("12/9/2023");
//		//LocalDate.now().
//		LocalDate l = LocalDate.now();
//		LocalDate l2 = LocalDate.of(2024, 10, 11);
//		Period period = Period.between(l, l2);
//		period.between(l, l2);
//		DayOfWeek dayOfWeek = l2.getDayOfWeek();
//		System.out.println(dayOfWeek.toString());

//		int arr[] = new int[] { 1, 2, 4 };
//		int arr2[] = new int[] { 1, 3, 4 };
		// righRotation(arr, 2);
//inserAtNthPos(arr,3,3);

//arr=insertInSortedArray(arr,6);
//System.out.println(2%5);
//arr=mergeSortedArrays(arr,arr2);
//System.out.println(Arrays.toString(arr))
		// reverserInteger(-1234);
//convertToInteger("  -1234");

		// AB.main(new String[] {"a","b"});
		// AB ab = new AB();
//		ab.hello();
//Comparator<Integer> com = new Comparator<Integer>() {
//
//	@Override
//	public int compare(Integer o1, Integer o2) {
//	   
//		return o1.intValue()>o2.intValue()?o2:o1;
//	}
//	
//};
//com = (c,b) -> c<b?1:-1;
//
//TreeSet<AB>  t = new TreeSet<>(); 
//		AB a1 = new AB();
//		a1.id=10;
//		AB a2 = new AB();
//		a2.id=20;
//		AB a3 = new AB();
//		a3.id=30;
//		AB a4 = new AB();
//		a4.id=40;
//		AB a5 = new AB();
//		a5.id=50;
//		
//		t.add(a1);
//		t.add(a2);
//		t.add(a3);
//		t.add(a4);
//		t.add(a5);
//		System.out.println(t);
		// System.out.println(integerToRoman(400));
		// System.out.println(romanToInteger("D"));
		// System.out.println(nonRepeatingChar("abcabc"));
		// System.out.println(longestPrefix(new String[] {"flow","flowight","flower"}));
//		int arr1[] = { 10, 8, 7, 5, 4, 11, 78 };
//		int arr3[] = { -1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4 };
//		Arrays.sort(arr3);
		// System.out.println(threeSum(arr3));
//		recursionBubbleSort(arr1,0,0);
//		System.out.println(Arrays.toString(arr1));
//		List.of(arr);

//		System.out.println(Arrays.toString(mergeTwoSortedArray(new int[] {1,3,5,7,9},new int[] {2,4,6,7,8})));
//		System.out.println(Arrays.toString(selectionSortRecu(new int[] {7,9,4,3,2,1,54,3},0,1,0)));

//		System.out.println(Arrays.toString(insertionSort(new int[] {9,8,6,5,4,3,5})));
		// System.out.println(uniqueOccurance(new int[] {1,1,1,2,2,2,3,4,4,5,4,5}));;
//		System.out.println(reverseKElements(new int[] {1,2,3,4,5,6,7,8,9},2));

		// System.out.println(isArraySortedOrRotated(new int[] {5,6,7,8,1}));
		// System.out.println(Arrays.toString(twoSum2(new int[] {2 ,7,8,5,2,1},9)));
		// System.out.println(longestPrefixs(new String[] {"ab","aba","ad"}));
		// System.out.println(Arrays.toString(removeDuplicatess(new int[]
		// {1,1,2,2,3,4,4,5,55,5})));
		// System.out.println(firstOccurances("hadbadhad","had"));
		// String s[]= {"aaa","aec","adc","ae"};
//		Arrays.sort(s);
//		System.out.println(lastWordLength("hello world jav   "));
		// System.out.println(Arrays.toString(plusOneOptimized(new int[] {9,9,})));
		// System.out.println(isPolindrom("5?6?7?876?5"));
		// System.out.println(reverseWords("A man, a plan, a canal: Panama"));
//		System.out.println(mostOccurrance("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(mostOccurranceInString("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(replaceString("a man is one the street"));
//	System.out.println(replaceAllDigitsWithCharacter("a1b2c3"));
		// System.out.println(removeAllSubstring("aabababa","aba"));
//System.out.println(removeAllDuplicates("aabbccdeffghill"));
		// System.out.println(1%2);
//		char ch[]=new char[] {'a','a','a','b','b','a','a'};
//		int n=countLetters(ch);
//		for(int i=0;i<n;i++) {
//			System.out.print(ch[i]+",");
// 		System.out.println(System.currentTimeMillis());
//		}
//		System.out.println(Arrays.toString(mergeSorted(new int[] {1,2,3,4},3,new int[] {2,5,6},2)));
		// int arr[][] = new int[][] { { 1, 2, 3} ,{ 4, 5, 6} ,{7,8,9}};
//		printWave(arr,2,3);
		// System.out.println(reverseVowels("hello"));
//		printSprial(arr);
//		generateMatrix(5);
//		arr = rotateArray90(arr);
//		for(int i=0;i<arr.length;i++) {
//			for(int j=0;j<arr[0].length;j++)
//				System.out.print(arr[i][j]+" ");
//			System.out.println();
//		}

//		int arr []= {1,2};
		// rotateArrayWithK(arr, 3);
//		int arr[][] = {{1,2,3},{4,5,6},{7,8,9}};  
//		List<List<Integer>> shiftGrid = shiftGrid(arr, 2);
//		for(int i =0 ;i<shiftGrid.size();i++) {
//			System.out.println(shiftGrid.get(i));
//		}

//		System.out.println(maximumSumOfTwoSubStringScore("00111"));
//		System.out.println(convertArrayIn2DArray(new int[] {1,2,3,4,5,5,6,200,200}));
//	System.out.println(missingNumber(new int[] {9,6,4,2,3,5,7,0,1}));	
//		System.out.println(unique(new int[] {1,1,2,2,3,3,9}));
		// System.out.println(Arrays.toString(findErrorNums(new int[] {1,2,2,4})));
		//	kajuKatli(10);
		System.out.println(System.currentTimeMillis());
		System.out.println(minOperations("1000"));
		System.out.println(System.currentTimeMillis());
	}

	public static int minOperations(String s) {
		int count[] = new int[2];
		for(int i=0;i<s.length();i++) {
			count[s.charAt(i)-'0']++;
		}
		if(count[0]>count[1]) {
			(count[0]-count[1])/2;
		}
			
		System.out.println(Arrays.toString(count));
		return 0;
	}
	
	
	public static int[] findErrorNums(int[] arr) {
		Set<Integer> value = new HashSet<>();
		int[] ar = new int[2];
		for (int i = 0; i < arr.length; i++) {
			if (value.contains(arr[i])) {
				ar[0] = arr[i];
				arr[1] = arr[i] + 1;
				System.out.println(arr[i] + 1);
				return ar;
			}
			value.add(arr[i]);
		}
		return ar;
	}

	public static int[] selectionSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			int min = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[j] < arr[min])
					min = j;
			}
			int temp = arr[i];
			arr[i] = arr[min];
			arr[min] = temp;

		}
		return arr;
	}

	public static int[] bubbleSortPr(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}

			}
		}
		return arr;
	}

	public static int unique(int arr[]) {
		int xor = 0;
		for (int i = 0; i < arr.length; i++) {
			xor ^= arr[i];
		}
		return xor;
	}

	public static int xorDuplicate(int arr[]) {

		for (int i = 0; i < arr.length; i++) {

		}
		return 0;
	}

	public static int missingNumber(int arr[]) {
		int max = findMaximum(arr);
		int total = max * (max + 1) / 2, sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return total - sum == 0 ? max + 1 : total - sum;
	}

	public static int countNumber(int arr[], int value) {
		int count = 0;

		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == value)
				count++;
			if (count > 2)
				return count;
		}
		return count;
	}

	public static int uniqueElement(int arr[]) {
		Set<Integer> value = Arrays.stream(arr).boxed().collect(Collectors.toSet());
		Iterator<Integer> iterator = value.iterator();
		while (iterator.hasNext()) {
			int va = iterator.next();
			if (count(arr, va) < 2)
				return va;
		}
		return -1;
	}

	public static int findMaximum(int arr[]) {
		int max = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] > max)
				max = arr[i];
		}
		return max;
	}

	public static List<List<Integer>> convertArrayIn2DArray(int arr[]) {
		// int max = findMaximum(arr);
		int count[] = new int[201];
		for (int i = 0; i < arr.length; i++)
			count[arr[i]]++;
//		System.out.println(Arrays.toString(count));
		int max = findMaximum(count);
		List<List<Integer>> response = new ArrayList<>();
		for (int i = 0; i < max; i++) {
			List<Integer> list = new ArrayList<>();
			for (int j = 0; j < count.length; j++) {
				if (count[j] > 0) {
					list.add(j);
					count[j]--;
				}
			}
			response.add(list);
		}

		return response;
	}

	public static int count(char arr[], int st, int end, char ch) {
		int count = 0;
		while (st <= end) {
			if (arr[st] == ch)
				count++;
			st++;
		}

		return count;
	}

	public static int maximumSumOfTwoSubStringScore(String s) {
		char[] arr = s.toCharArray();
		int i = 0, j = i + 1, max = 0;
		while (i < j && j < arr.length) {
			int cou = count(arr, i, j - 1, '0') + count(arr, j, arr.length - 1, '1');

			if (cou > max)
				max = cou;
			j++;
		}
		return max;
	}

	public static List<List<Integer>> shiftGrid(int arr[][], int k) {
		int row = arr.length, col = arr[0].length, j = row * col - 1, count = 0;
		while (count++ < k) {
			int ele = arr[arr.length - 1][arr[0].length - 1];
			for (j = row * col - 1; j > 0; j--) {
				arr[j / col][j % col] = arr[(j - 1) / col][(j - 1) % col];
			}
			arr[0][0] = ele;

		}
		List<List<Integer>> ar = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			List<Integer> ro = new ArrayList<>();
			for (j = 0; j < arr[0].length; j++) {
				ro.add(arr[i][j]);
			}
			ar.add(ro);

		}
		return ar;
	}

	public static boolean binarySearch2DInSortedRow(int arr[][], int target) {
		int row = 0, col = arr[0].length - 1;

		while (col >= 0 && row <= arr.length - 1) {
			if (arr[row][col] == target)
				return true;
			if (arr[row][col] < target)
				row++;
			else
				col--;
		}
		return false;
	}

	public static boolean binarySearchIn2D(int arr[][], int target) {
		int row = arr.length;
		int col = arr[0].length;
		int st = 0;
		int end = row * col - 1;

		while (st <= end) {
			int mid = st + (end - st) / 2;
			int element = arr[mid / col][mid % col];
			if (element == target)
				return true;
			if (element < target)
				st = mid + 1;
			else
				end = mid - 1;

		}
		return false;

	}

	public static void rotateArrayWithK(int arr[], int k) {
		int arr2[] = new int[arr.length], l = 0;
		int kIndex = arr.length - k;

		if (k >= arr.length) {
			int count = 0;
			while (count++ <= k) {
				int temp = arr[arr.length - 1];
				System.out.println(Arrays.toString(arr));
				for (int j = arr.length - 1; j > 0; j--) {
					arr[j] = arr[j - 1];
				}
				arr[0] = temp;
			}
			return;
		}

		if (kIndex < 0)
			return;
		for (int i = kIndex; i < arr.length; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < kIndex; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < arr.length; i++)
			arr[i] = arr2[i];

	}

	public static int[][] rotateArray90(int arr[][]) {
		int arr3[][] = new int[arr.length][arr[0].length], k = 0;
		for (int col = 0; col < arr[0].length; col++) {
			k = 0;
			for (int row = arr.length - 1; row >= 0; row--) {
				arr3[col][k++] = arr[row][col];
			}

		}
		return arr3;
	}

	public static int[][] generateMatrix(int n) {
		int row = n;
		int col = n;
		int total = n * n;
		int startingCol = 0;
		int startingRow = 0;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int arr[][] = new int[n][n];
		int count = 0;
		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				arr[startingRow][i] = ++count;
			}

			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				arr[i][endingCol] = ++count;
			}

			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				arr[endingRow][i] = ++count;
			}

			endingRow--;

			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				arr[i][startingCol] = ++count;
			}
			startingCol++;

		}
		return arr;
	}

	public static void printSprial(int arr[][]) {
		int startingCol = 0;
		int startingRow = 0;
		int row = arr.length;
		int col = arr[0].length;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int count = 0;
		int total = row * col;

		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				System.out.print(arr[startingRow][i]);
				count++;
			}
			System.out.println();
			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				System.out.print(arr[i][endingCol]);
				count++;
			}

			System.out.println();
			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				System.out.print(arr[endingRow][i]);
				count++;
			}

			endingRow--;
			System.out.println();
			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				System.out.print(arr[i][startingCol]);
				count++;
			}
			startingCol++;
			System.out.println();
		}
	}

	public static boolean isVowel(char ch) {
		ch = Character.toLowerCase(ch);
		if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
			return true;
		return false;
	}

	public static String reverseVowels(String s) {

		char[] arr = s.toCharArray();
		int i = 0, j = arr.length - 1;
		while (i < j) {
			if (isVowel(arr[i]) && isVowel(arr[j])) {
				char t = arr[i];
				arr[i] = arr[j];
				arr[j] = t;
				i++;
				j--;
			} else if (isVowel(arr[i]))
				j--;
			else
				i++;
		}
		return new String(arr);
	}

	public static void printWave(int arr[][], int row, int col) {
		for (int j = 0; j < col; j++) {

			for (int i = 0; i < row; i++) {
				System.out.print(arr[i][j]);
			}

			System.out.println();
			j++;
			for (int i = row - 1; i >= 0 && j < col; i--) {
				System.out.print(arr[i][j]);
			}
			System.out.println();

		}
	}

	public static int[] mergeSorted(int arr[], int m, int arr1[], int n) {
		int arr3[] = new int[m + n], i = 0, j = 0, k = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j] && n > 0) {
				arr3[k++] = arr1[j++];
				n--;
			} else if (m > 0) {
				arr3[k++] = arr[i++];
				m--;
			} else
				break;

		}
		System.out.println(Arrays.toString(arr3));
		while (m > 0 && i < arr.length) {
			arr3[k++] = arr[i++];
			m--;
		}
		while (n > 0 && j < arr1.length) {
			arr3[k++] = arr1[j++];
			n--;
		}
		return arr3;
	}

	public static List<Foodsystem> system = new ArrayList<>();

	public void enterData() {
		String food[] = { "kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi" };
		String country[] = { "korean", "japanese", "japanese", "greek", "japanese", "korean" };
		int arr[] = { 9, 12, 8, 15, 14, 7 };
		for (int i = 0; i < country.length; i++) {
			Map<String, Integer> fs = new LinkedHashMap<>();
			Foodsystem s = new Foodsystem();
			s.count = country[i];
			s.food.put(food[i], arr[i]);
			this.add(s);
		}
		System.out.println(system);

	}

	public void add(Foodsystem o) {
		for (int i = 0; i < this.system.size(); i++) {
			if (system.get(i).count.equals(o.count)) {
				system.get(i).food.putAll(o.food);
				return;
			}

		}
		this.system.add(o);
	}

	public void changeRating(String food, int rating) {
		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem f = system.get(i);
			if (f.food.containsKey(food)) {
				f.food.put(food, rating);
				return;
			}

		}

	}

	public String highestRating(String country) {
		String city = "";

		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem s = system.get(i);
			if (s.count.equals(country)) {
				int max = 0;
				Set<Entry<String, Integer>> entrySet = s.food.entrySet();
				System.out.println(entrySet);
				for (Entry<String, Integer> e : entrySet) {
					if (e.getValue() > max) {
						max = e.getValue();
						city = e.getKey();

					}
					if (e.getValue() == max) {
						s.food.put(e.getKey(), e.getValue());
					}
				}
			}

		}

		return city;
	}

	public static int countLetters(char[] s) {
		int k = 0;
		for (int i = 0; i < s.length;) {
			char ch = s[i];
			int j = i + 1, count = 1;

			while (j < s.length && s[j] == ch) {
				count++;
				j++;
			}
			System.out.println(ch + " " + count + " " + j);
			if (count > 1) {
				s[k++] = ch;
				for (char c : Integer.toString(count).toCharArray()) {
					if (k < s.length)
						s[k++] = c;
					else
						return k;
				}
			} else {
				s[k++] = ch;
			}
			i = j;
		}
		return k;
	}

	public static String removeAllDuplicates(String s) {
		StringBuilder sb = new StringBuilder();
		int count[] = new int[26];
		for (int i = 0; i < s.length(); i++) {
			int num = s.charAt(i) - 'a';
			count[num]++;
		}

		for (int i = 0; i < s.length(); i++) {
			if (count[(s.charAt(i) - 'a')] < 2)
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static String removeAllSubstring(String s, String part) {
		while (s.length() != 0 && s.contains(part))
			s = s.replaceFirst(part, "");

		return s;
	}

	public static String replaceAllDigitsWithCharacter(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
				sb.append((char) (s.charAt(i - 1) + (s.charAt(i) - 48)));
			else
				sb.append(s.charAt(i));
		}
		return sb.toString();

	}

	public static String replaceString(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == ' ')
				sb.append("@40");
			else
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static char mostOccurranceInString(String s) {
		int arr[] = new int[26]; // storing occurance of every letter according to index
		s = s.toLowerCase();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
				int num = s.charAt(i) - 'a';
				arr[num]++;
			}
		}

		// finding max
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < arr.length; i++) {
			if (max < arr[i]) {
				max = arr[i];
				ch = (char) i;
			}

		}
		return (char) (ch + 'a');

	}

	// brute force
	public static char mostOccurrance(String s) {
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < s.length(); i++) {
			int count = 0;
			for (int j = i + 1; j < s.length(); j++) {
				if (s.charAt(i) == s.charAt(j) && s.charAt(i) != ' ')
					count++;
			}

			if (count > max) {
				ch = s.charAt(i);
				max = count;
			}
		}
		return ch;
	}

	public static int climbStairs(int n) {

		if (n < 0)
			return 0;
		if (n == 0)
			return 1;
		return climbStairs(n - 1) + climbStairs(n - 2);
	}

	public static void reverseString(char[] ch, int st, int end) {

		while (st < end) {
			char temp = ch[st];
			ch[st] = ch[end];
			ch[end] = temp;
			st++;
			end--;
		}

	}

	public static char[] reverseWords(String s) {
		char ch[] = s.toCharArray();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ' && s.charAt(i) != ',') {
				int j = i + 1;
				for (; j < s.length(); j++) {
					if (s.charAt(j) == ' ' || s.charAt(j) == ',')
						break;
				}
				reverseString(ch, i, j - 1);
				i = j;
			}
		}
		return ch;
	}

	public static boolean isAlphaNumeric(char c) {
		if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9')
			return true;
		return false;
	}

	public static boolean isPolinromValidAlgo(String s) {
		StringBuilder b = new StringBuilder();
		// remove special characters only left alphanumeric
		for (int i = 0; i < s.length(); i++) {
			if (isAlphaNumeric(s.charAt(i)))
				b.append(s.charAt(i));

		}

		// to lower case
		String str = b.toString().toLowerCase();
		int st = 0, end = str.length() - 1;
		while (st < end) {
			if (str.charAt(st) != str.charAt(end))
				return false;
			st++;
			end--;
		}
		return true;

	}

	public static boolean isPolindrom(String s) {
		int st = 0, end = s.length() - 1;
		while (st < end) {
			if (s.charAt(st) >= '0' && s.charAt(st) <= '9') {
				if (s.charAt(end) >= '0' && s.charAt(end) <= '9') {

					if (s.charAt(st) != s.charAt(end))
						return false;
					else {
						st++;
						end--;
					}
				} else
					end--;
			} else
				st++;
		}
		return true;
	}

	// optimized
	public static int[] plusOneOptimized(int arr[]) {
		for (int i = arr.length - 1; i >= 0; i--) {
			if (arr[i] < 9) {
				arr[i]++;
				return arr;
			}
			arr[i] = 0;
		}
		arr = new int[arr.length + 1];
		arr[0] = 1;
		return arr;
	}

	// brute force
	public static int[] plusOne(int arr[]) {
		if (arr.length < 1)
			return arr;
		int carry = 1;
		for (int i = arr.length - 1; i >= 0; i--) {
			arr[i] = arr[i] + carry;
			carry = 0;
			if (arr[i] > 9) {
				arr[i] = 0;
				carry = 1;
			} else
				break;
		}

		if (carry != 0) {
			int ar[] = new int[arr.length + 1];
			ar[0] = carry;
			for (int i = 1; i < ar.length - 1; i++)
				ar[i] = arr[i];
			return ar;
		}
		return arr;
	}

	public static int countLastWordLength(String s, int index) {
		int count = 0;
		for (; index >= 0; index--) {
			if (s.charAt(index) != ' ')
				count++;
			else
				break;
		}
		return count;
	}

	public static int lastWordLength(String s) {
		for (int i = s.length() - 1; i >= 0; i--) {
			if (s.charAt(i) != ' ')
				return countLastWordLength(s, i);
		}
		return 0;
	}

	public static int firstOccurances(String s, String value) {
		if (s.contains(value)) {
			return s.indexOf(value);
		}
		return -1;
	}

	public static boolean isMatched(String s, String value) {
		if (s.length() < value.length())
			return false;
		for (int i = 0; i < value.length(); i++) {
			if (s.charAt(i) != value.charAt(i))
				return false;
		}
		return true;
	}

	public static int firstOccurance(String s, String value) {
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == value.charAt(0)) {
				if (isMatched(s.substring(i), value))
					return i;
			}
		}
		return -1;
	}

	public static int[] removeDuplicatess(int arr[]) {
		int i = 0, j = 1;
		for (i = 1; i < arr.length; i++) {
			if (arr[i - 1] != arr[i])
				arr[j++] = arr[i];
		}
		return arr;
	}

	public static int[] removeDuplicates(int arr[]) {
		Set<Integer> set = new LinkedHashSet<>();
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		return set.stream().mapToInt(i -> i).toArray();

	}

	public static String longestPrefixs(String arr[]) {
		Arrays.sort(arr);
		StringBuilder b = new StringBuilder();
		String first = arr[0];
		String last = arr[arr.length - 1];
		for (int i = 0; i < Math.min(first.length(), last.length()); i++) {
			if (first.charAt(i) != last.charAt(i))
				return b.toString();
			b.append(first.charAt(i));
		}
		return b.toString();

	}

	public static int[] twoSum2(int[] arr, int target) {
		int f = 0, l = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 1; j < arr.length; j++) {
				if (arr[i] + arr[j] == target) {
					f = i;
					l = j;
				}
			}
		}
		return new int[] { f, l };
	}

	public static Boolean arraySortedOrRotated(int arr[]) {
		int count = 0;
		for (int i = 1; i < arr.length; i++) {
			if (arr[i - 1] > arr[i])
				count++;
		}
		if (arr[0] < arr[arr.length - 1])
			count++;

		return count == 1;
	}

	// brute force
	public static Boolean isArraySortedOrRotated(int arr[]) {
		int i = 0;
		for (i = 0; i < arr.length - 1; i++) {
			if (arr[i] > arr[i + 1])
				break;

		}
		System.out.println(i + " -<");
		i++;
		for (; i < arr.length - 1; i++) {
			System.out.println("->" + i);
			if (arr[0] < arr[i] || arr[i] > arr[i + 1])
				return false;
		}
		if (i < arr.length && arr[0] < arr[i])
			return false;
		return true;
	}

	public static int findUnique(int arr[]) {
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {

			ans = ans ^ arr[i];
		}
		return ans;
	}

	public static int count(int arr[], int value) {
		int count = 0;
		for (int i = 0; i < arr.length; i++) {
			if (value == arr[i])
				count++;
		}
		return count;

	}

	public static int uniqueOccurance(int arr[]) {
		int arr1[] = new int[arr.length], k = 0;
		for (int i = 0; i < arr.length; i++) {
			if (!isPreExists(arr[i], arr, i - 1)) {

				int count = count(arr, arr[i]);
				arr1[k++] = count;
				System.out.println("count " + count);
			}
		}
		return findUniqueElement(arr1);
	}

	public static int[] reverse(int arr[], int st, int end) {
		if (end < arr.length)
			while (st < end) {
				int k = arr[st];
				arr[st++] = arr[end];
				arr[end--] = k;
			}
		return arr;
	}

	public static int[] reverseKElements(int arr[], int k) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length; i += k) {

			reverse(arr, i, i + k - 1);
		}
		System.out.println(Arrays.toString(arr));
		return arr;

	}

	public static boolean isPreExists(int value, int arr[], int k) {
		for (int i = k; i >= 0; i--) {
			if (arr[i] == value)
				return true;
		}
		return false;
	}

	public static int findUniqueElement(int arr[]) {
		System.out.println(Arrays.toString(arr));
		for (int i = 0; i < arr.length; i++) {
			int count = 0;
			if (!isPreExists(arr[i], arr, i - 1))
				for (int j = i; j < arr.length; j++) {

					if (arr[i] == arr[j])
						count++;
				}

			if (count == 1) {
				System.out.println("found " + arr[i]);

				return arr[i];
			}
		}
		return 0;
	}

	public static int[] insertionSort(int arr[]) {
		int j = 0;
		for (int i = 0; i < arr.length; i++) {
			int k = arr[i];
			for (j = i - 1; j >= 0; j--) {
				if (arr[j] < k) {
					arr[j + 1] = arr[j];
				} else
					break;
			}
			arr[j + 1] = k;
		}
		return arr;
	}

	public static int[] selectionSortRecu(int arr[], int i, int j, int min) {
		if (i >= arr.length)
			return arr;
		if (j < arr.length) {
			if (arr[min] > arr[j])
				min = j;
			return selectionSortRecu(arr, i, j + 1, min);
		}
		int k = arr[i];
		arr[i] = arr[min];
		arr[min] = k;
		return selectionSortRecu(arr, i + 1, i + 2, i + 1);
	}

	public static int[] mergeTwoSortedArray(int arr[], int arr1[]) {
		int arr3[] = new int[arr.length + arr1.length], k = 0, i = 0, j = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j]) {
				arr3[k++] = arr1[j++];

			} else {
				arr3[k++] = arr[i++];

			}
		}

		while (i < arr.length) {
			arr3[k++] = arr[i++];
		}
		while (j < arr1.length) {
			arr3[k++] = arr1[i++];
		}
		return arr3;
	}

	public static void recursionBubbleSort(int arr[], int i, int j) {
		if (i == arr.length)
			return;
		if (j < arr.length - i - 1 && arr[j] > arr[j + 1]) {

			int k = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = k;
			System.out.println(Arrays.toString(arr));
			recursionBubbleSort(arr, i, j + 1);

		} else {
			System.out.println("----- " + Arrays.toString(arr));
			recursionBubbleSort(arr, i + 1, 0);
		}

	}

	public static void bubbleSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int k = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = k;
				}

			}
		}
	}

	public static List<List<Integer>> threeSum(int arr[]) {
		int i = 0, j = 0, k = arr.length - 1;
		Set<List<Integer>> output = new HashSet<>();
		for (i = 0; i < arr.length; i++) {
			j = i + 1;
			k = arr.length - 1;
			while (j < k) {
				System.out.println(arr[i] + "->" + arr[j] + "->" + arr[k] + "=> " + (arr[i] + arr[j] + arr[k]) + " ( "
						+ i + "," + j + "," + k);
				if (arr[i] + arr[j] + arr[k] == 0) {
					List<Integer> list = new ArrayList<>();
					list.add(arr[i]);
					list.add(arr[j]);

					list.add(arr[k]);
					output.add(list);
				} else if (arr[i] + arr[j] + arr[k] > 0) {
					k--;
					j--;
				}
				j++;

			}
		}

		return output.stream().toList();

	}

	public static String longestPrefix(String s[]) {

		String prefix = "";

		for (int i = 0; i < s.length; i++) {
			for (int j = i + 1; j < s.length; j++) {
				if (s[i].length() > s[j].length()) {
					String temp = s[i];
					s[i] = s[j];
					s[j] = temp;
				}
			}
		}

		String st = s[0];
		boolean isMatched = false;
		for (int j = 0; j < st.length(); j++) {
			char ch = st.charAt(j);

			for (int k = 1; k < s.length; k++) {
				isMatched = false;

				if (ch == s[k].charAt(j)) {
					isMatched = true;
				} else
					break;
			}
			if (isMatched)
				prefix += ch;
			else
				break;

		}
		;
		return prefix;

	}

	public static String nonRepeatingChar(String s) {
		for (int i = 0; i < s.length(); i++) {
			boolean isPresent = false;
			for (int j = 0; j < s.length(); j++) {
				if (i != j && s.charAt(i) == s.charAt(j)) {
					isPresent = true;
					break;
				}
			}
			if (!isPresent) {
				return s.charAt(i) + "";
			}
		}
		return "All Are repated";
	}

	public static Integer romanToInteger(String s) {
		int num = 0;
		Map<String, Integer> romans = new HashMap<>();
		romans.put("M", 1000);
		romans.put("CM", 900);
		romans.put("D", 500);
		romans.put("CD", 400);
		romans.put("C", 100);
		romans.put("XC", 90);
		romans.put("L", 50);
		romans.put("XL", 40);
		romans.put("X", 10);
		romans.put("IX", 9);
		romans.put("V", 5);
		romans.put("IV", 4);
		romans.put("I", 1);
//System.out.println(romans.get("M"));
		if (s.length() < 2)
			return romans.get(s.charAt(0) + "");
		for (int i = 0; i < s.length() - 1; i++) {

			if (romans.get(s.charAt(i) + "").intValue() >= romans.get(s.charAt(i + 1) + "").intValue()) {
				num += romans.get(s.charAt(i) + "");
				System.out.println("num -> " + num);
			} else {

				int sum = romans.get(s.charAt(i + 1) + "") - romans.get(s.charAt(i) + "");
				System.out.println("num    => " + num + "  sum => " + sum);
				num += sum;
				i++;
				System.out.println("--------- " + num);
			}
			if (i == s.length() - 2)
				if (romans.get(s.charAt(i + 1) + "").intValue() <= romans.get(s.charAt(i) + "").intValue()) {
					num += romans.get(s.charAt(i + 1) + "");

				}
		}
		return num;
	}

	public static String integerToRoman(int num) {
		Integer number[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
		String romans[] = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };
		String result = "";
		for (int i = 0; i < number.length; i++) {

			while (num >= number[i]) {
				num -= number[i];
				result += romans[i];
			}
		}
		return result;

	}

	public static int convertToInteger(String s) {
		String st = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {
				st += s.charAt(i);
			} else if (s.charAt(i) == '-')
				st += s.charAt(i);
		}
		System.out.println(Integer.parseInt(st));
		return 0;
	}

	public static int reverserInteger(int n) {
		int rev = 0;
		while (n != 0) {
			int r = n % 10;
			n /= 10;
			rev = rev * 10 + r;
		}
		System.out.println(rev);
		return 0;
	}

	public static int[] mergeSortedArrays(int a1[], int a2[]) {
		int a3[] = new int[a1.length + a2.length], j = 0, k = 0, i = 0;

		Stack<Character> stack = new Stack();
		String s = "a";
		Character c = s.charAt(i);
		System.out.println(c.equals(c));

		while (i < a1.length && j < a2.length) {

			if (a1[i] >= a2[j])
				a3[k++] = a2[j++];
			else
				a3[k++] = a1[i++];

		}
		while (i < a1.length)
			a3[k++] = a1[i++];

		while (j < a2.length)
			a3[k++] = a2[j++];

		return a3;

	}

	public static int[] insertInSortedArray(int arr[], int value) {
		int temp[] = new int[arr.length + 1], j = 0;
		boolean isInserted = false;
		for (int i = 0; i < arr.length; i++) {

			if (!isInserted && arr[i] > value) {
				temp[j++] = value;
				isInserted = true;
			}
			temp[j++] = arr[i];
		}
		if (!isInserted)
			temp[j++] = value;
		return temp;
	}

	public static int[] inserAtNthPos(int arr[], int value, int pos) {
		int j = 0;
		int temp[] = new int[arr.length + 1];
		if (pos < 1)
			return arr;

		for (int i = 0; i < arr.length; i++) {
			if (i == pos - 1)
				temp[j++] = value;

			temp[j++] = arr[i];
		}
		if (pos > arr.length) {
			temp[j++] = value;
		}

//	for(int i=0;i<temp.length;i++)
//		arr[i]=temp[i];
		return temp;
	}

	public static void righRotation(int arr[], int num) {
		int n = arr.length, temp = 0, count = 0;
		while (count++ < num) {
			temp = arr[n - 1];
			for (int i = n - 1; i > 0; i--)
				arr[i] = arr[i - 1];
			arr[0] = temp;
		}

	}

	public static void leftRotation(int arr[], int num) {
		int temp[] = new int[arr.length], n = arr.length, j = 0;

		for (int i = num; i < n; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < num; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < n; i++)
			arr[i] = temp[i];
	}

	public static char[] copyArray(char[] arr) {
		if (arr == null)
			return new char[1];

		char[] a = Arrays.copyOf(arr, arr.length + 1);
		return a;
	}

	public static String zigzapConversion(String s, int num) {
		char[][] arr = new char[num][];
		int k = 0, i = 0, j = 0, t = 0;
		while (k < s.length()) {
			while (i != num - 1) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i++;
			}
			j++;
			while (i != 0) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i--;
			}
			j++;

		}
		for (char[] a : arr) {
			for (char tt : a)
				System.out.print(tt);
			System.out.println();
		}
		return "";
	}

	public static String longestPolindromSubtString(String s) {
		String ans = "";
		if (s.length() < 1)
			return s;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - 1; j >= 0; j--) {
				if (i < j) {
					String sub = s.substring(i, j + 1);
					if (sub.equals(new StringBuilder(sub).reverse().toString())) {
						if (sub.length() > ans.length()) {
							ans = sub;
						}

					}
				}
			}
		}

		return ans;
	}

	public static double medianOfTwoSortedArray(int[] arr1, int[] arr2) {

		int arr3[] = new int[arr1.length + arr2.length], i = 0, j = 0, k = 0;
		while (true) {
			if (i < arr1.length) {
				arr3[k++] = arr1[i++];
			} else if (j < arr2.length) {
				arr3[k++] = arr2[j++];
			} else
				break;

		}
		double ans = 0;
		Arrays.sort(arr3);
		System.out.println(Arrays.toString(arr3));
		if (arr3.length % 2 == 0) {
			int mid = arr3.length / 2;
			ans = (double) (arr3[mid - 1] + arr3[mid]) / 2;
			System.out.println(arr3[mid - 1]);
		} else {
			ans = arr3[arr3.length / 2];
		}

		return ans;
	}
// 4
// 1,1,1,1
// 2,1,1
// 1,1,2
// 2,2

	public static int[] twoSum(int arr[], int target) {
		int f = 0, sec = 0;
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {
				if (arr[i] + arr[j] == target && i != j) {

					f = i;
					sec = j;
				}
			}

		}
		System.out.println(f + " " + sec);
		return new int[] { f, sec };
	}

	public static char[] stringToArrayOfCharacters(String s) {
		char arr[] = new char[s.length()];
		for (int i = 0; i < s.length(); i++) {
			arr[i] = s.charAt(i);
		}
		return arr;
	}

	public static String[] textToWordsArray(String text) {
		List<String> words = new ArrayList<>();
		for (int i = 0; i < text.length(); i++) {

			for (int j = i; j < text.length() - 1; j++) {
				if (i > 0 && text.charAt(i) == ' ' && text.charAt(j + 1) == ' ' && text.charAt(i - 1) != ' ') {
					words.add(text.substring(i + 1, j + 1));
					break;
				} else if (i == 0 && text.charAt(j + 1) == ' ') {
					words.add(text.substring(i, j + 1));
					break;
				} else if (text.charAt(i) == ' ' && j + 1 == text.length() - 1) {
					words.add(text.substring(i + 1, text.length()));
					break;
				}
			}

		}
		String s[] = new String[words.size()];
		int i = 0;
		ListIterator<String> listIterator = words.listIterator();
		while (listIterator.hasNext()) {
			s[i++] = listIterator.next();
		}
		return s;
	}

	public static int wordCount(String s) {
		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0)
				count++;
			else if (s.charAt(i) == ' ')
				for (int j = i; j < s.length() - 1; j++) {
					if (s.charAt(j + 1) == ' ' && s.charAt(i - 1) != ' ') {
						count++;
						System.out.print(s.charAt(i) + " - > " + s.charAt(j) + " = " + count);
						break;
					}
				}
		}
		return count + 1;

	}

	public static void uniqueFromArrays(int arr[], int arr2[]) {

		List<Integer> list1 = List.of(1, 2, 4);
		List<Integer> list2 = List.of(1, 2, 3, 5);
		List<Integer> unique = new ArrayList<>();
		unique.addAll(list1);
		unique.addAll(list2);
		unique = unique.stream().distinct()
				.filter(a -> list1.contains(a) && !list2.contains(a) || !list1.contains(a) && list2.contains(a))
				.collect(Collectors.toList());
		System.out.println(unique);

		int k = 0;
		for (int i = 0; i < arr.length || k < arr2.length; i++, k++) {
			boolean a = false;
			boolean b = false;
			if (i < arr.length)
				for (int j = 0; j < arr2.length; j++) {
					if (arr[i] == arr2[j])
						a = true;
				}
			for (int j = 0; j < arr.length; j++) {
				if (arr2[k] == arr[j])
					b = true;
			}
			if (!a && i < arr.length)
				System.out.println(arr[i]);
			if (!b)
				System.out.println(arr2[k]);
		}
	}

	public static void arraySum(int arr[], int arr2[]) {
		int carry = 0, total = 0, j = 0, k = arr2.length - 1, i;
		List<Integer> sum = new ArrayList<>();

		for (i = arr.length - 1; i >= 0 && k >= 0; i--, k--) {

			total = arr[i] + arr2[k] + carry;
			carry = 0;
			if (total > 9) {
				carry = total % 10;
				total /= 10;
			}
			sum.add(total);

		}

		if (i < 0 && k >= 0) {
			for (int a = k; a >= 0; a--)
				sum.add(arr2[a]);
		}
		if (k < 0 && i >= 0) {
			for (int a = i; a >= 0; a--)
				sum.add(arr[a]);
		}
		Collections.reverse(sum);
		System.out.println(sum);
	}

	public static void arrayRightRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[arr.length - 1];
			for (j = arr.length - 1; j > 0; j--) {
				arr[j] = arr[j - 1];
			}
			count++;
			arr[0] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static void arrayLeftRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[0];
			for (j = 0; j < arr.length - 1; j++) {
				arr[j] = arr[j + 1];
			}
			count++;
			arr[j] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static boolean anagram(String s, String s1) {

		int count = 0;
		boolean b = false;
		for (int i = 0; i < s.length(); i++) {
			char ch = s.charAt(i);
			count = 0;
			b = false;
			for (int k = 0; k < s.length(); k++) {
				if (ch == s.charAt(k))
					count++;
			}

			for (int j = 0; j < s1.length(); j++) {
				if (count > 0 && ch == s1.charAt(j))
					count--;
			}
			if (count == 0)
				b = true;
		}

		System.out.println(b ? "yes" : "no");
		return b;
	}

	public static int count(int i, int arr[]) {
		int count = 0;
		for (int a : arr) {
			if (a == i)
				count++;
		}
		System.out.println(count);
		return count;
	}

	public static void majorityElement(int arr[]) {
		int max = 0, count = 0;
		for (int i = 0; i < arr.length; i++) {
			count = count(arr[i], arr);
			if (count >= max && count > arr.length / 2)
				max = arr[i];

		}
		System.out.println(max);
	}

	public static void longestPolindrom(String s) {

		int first = 0, last = s.length() - 1, max = 0;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - i; j >= 0; j--) {
				if (i < j && j < s.length())
					if (checkPolindrom(i, j + 1, s) && max < s.substring(i, j).length()) {

						max = s.substring(i, j + 1).length();
						first = i;
						last = j + 1;
					}
			}
			System.out.println("------");

		}
		System.out.println(s.substring(first, last));

	}

	public static boolean checkPolindrom(int f, int l, String s) {
		String st = s.substring(f, l);
		System.out.println(st + "444");
		return st.equals(new StringBuffer(st).reverse().toString());

	}

	public void spiralMatrix() throws ClassNotFoundException, NoSuchMethodException, SecurityException,
			InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		int a[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };
		int j = 0, k = 0, count = 0, max = 10 - 1;
		// int max=a.length*a.length-1;
		// System.out.println(a.length);

		for (int i = 0; i < a.length - i; i++) {

			if (count == max)
				break;

			for (j = i; j < a.length - i && count <= max; j++) {
				count++;
				System.out.println(a[k][j]);
			}
			j--;

			k++;
			while (k < a.length - i && count <= max) {
				System.out.println(a[k][j]);
				k++;
				count++;
			}
			k--;
			j--;

			while (j >= 0 && count <= max) {
				count++;
				System.out.println(a[k][j--]);
			}

			// k=i+1;
			if (k == a.length / 2 && j == a.length / 2)
				break;
			j++;
			while (k > i + 1 && count <= max) {
				System.out.println(a[--k][j]);
				count++;
			}

			k = i + 1;
			System.out.println("-----------------");
		}

	}

	public static ArrayList<Integer> findIndexes(int arr[], int sum) {
		boolean a = false;
		int f = 0, l = arr.length, s = 0;
		for (int i = 0; i < arr.length; i++) {
			s = 0;
			if (a)
				break;

			for (int j = i; j < arr.length; j++) {
				s += arr[j];
				if (s == sum) {
					f = i;
					l = j;
					a = true;
					break;
				}

			}
			System.out.println(s);
		}

		return a ? new ArrayList<Integer>(Arrays.asList(f, l)) : new ArrayList<Integer>(Arrays.asList(-1));
	}

	public int count(char a, String s) {
		class A {
			static int a;

			public void main() {
				System.out.println("hello");
			}
		}

		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == a)
				count++;
		}
		return count;
	}

	public static boolean isPresent(char a, int indx, String s) {
		for (int i = indx; i >= 0; i--) {
			if (s.charAt(i) == a)
				return true;
		}
		return false;
	}

	public static boolean isPresent(int a, int indx, int ar[]) {
		for (int i = indx; i >= 0; i--) {
			if (ar[i] == a)
				return true;
		}
		return false;
	}

	public static void fibonacci(int t1, int t2, int n) {
		if (n == 0)
			return;
		else {
			int t3 = t1 + t2;
			t1 = t2;
			t2 = t3;
			System.out.println(t3);
			fibonacci(t1, t2, n - 1);
		}

	}

	public static int factorial(int n) {
		if (n == 1)
			return 1;
		else
			n = n * factorial(n - 1);
		return n;

	}

	public static String removeSpaces(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ')
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static int[] removeDuplicate(int[] a) {
		int arr[] = new int[a.length];
		int j = 0;
		for (int i = 0; i < a.length; i++) {
			if (!isPresent(a[i], i - 1, a))
				arr[j++] = a[i];
		}
		a = new int[j];
		System.out.println(j);
		for (int i = 0; i < j; i++)
			a[i] = arr[i];
		return a;
	}

	class C {
		static int a;
	}
}

class B {
	int a = 10;

	public String toString() {
		System.out.println("askfjal");
		return new String(this.a + "");
	}

	public void hello(int... a) {

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-12-24 23:20:53.212
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-12-24 23:20:53.213
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-12-24 23:21:06.508
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.pract;

import java.lang.reflect.InvocationTargetException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.springframework.jdbc.core.metadata.OracleCallMetaDataProvider;

interface DD {

}

class AB implements Comparable<AB> {
	int id = 0;
	String name = "rohit";

	@Override
	public int compareTo(AB o) {
		if (this.id < o.id)
			return 1;

		return -1;
	}

	@Override
	public String toString() {
		return "AB [id=" + id + ", name=" + name + "]";
	}

}

abstract class kd {

}

class Foodsystem {
	public String count;
	public Map<String, Integer> food = new LinkedHashMap<>();

	public String toString() {
		return count + " =" + food;
	}

}

public class Test {

	public Test(int a) {

	}

	public static void main(String[] args) throws Exception {
		// fibonacci(0,1,20);
		// Class<?> clas = Class.forName("com.pract.Test");

		// Constructor<?> to = clas.getConstructor(int.class);
		// Test t = (Test) to.newInstance();
		var a = new Test(8);

		// System.out.println(Integer.toBinaryString(2));

		// new Random().ints(1,999).limit(20).sorted().forEach(System.out::println);
		// List<Integer> list = List.of(1,2,3,4,5);
		// System.out.println(list.stream().mapToInt(v->v).max().getAsInt());
		// list.stream().max(Integer::compare);

//		
//		longestPolindrom("bcac");
//	
//	majorityElement(new  int []{1,2,3,4,5,5});
//		
//	anagram("abcda","bcdaa");
//	String sp="TEST@$QWES 89";
//	sp = sp.replaceAll("\\d+","");
//	System.out.println(sp);

//arrayLeftRotation(new int[] {1,2,3,4,5},4);
//arrayRightRotation(new int[] {1,2,3,4,5},2);
//arraySum(new int[] {1,2,3,4},new int[] {1,2,3});
//uniqueFromArrays(new int[] {1,2,4},new int[] {1,2,3,5});
//wordCount("Hello what are you doing here you fucking bitch bastard");
//String s[]=textToWordsArray("Hello what are you doing here you fucking bitch bastard ab bcd");

//char arr[]=stringToArrayOfCharacters("hello what");

//twoSum(new int[] {2,7,11,15},9);
//		System.out.println(medianOfTwoSortedArray(new int[] {3},new int[] {-2,-1}));
//		System.out.println(longestPolindromSubtString("cbbd"));
		// zigzapConversion("PAYPALISHIRING",4);
//		Date d = new Date();
//		SimpleDateFormat f = new SimpleDateFormat("dd/MM/yyyy");
//		Date parse = f.parse("12/9/2023");
//		//LocalDate.now().
//		LocalDate l = LocalDate.now();
//		LocalDate l2 = LocalDate.of(2024, 10, 11);
//		Period period = Period.between(l, l2);
//		period.between(l, l2);
//		DayOfWeek dayOfWeek = l2.getDayOfWeek();
//		System.out.println(dayOfWeek.toString());

//		int arr[] = new int[] { 1, 2, 4 };
//		int arr2[] = new int[] { 1, 3, 4 };
		// righRotation(arr, 2);
//inserAtNthPos(arr,3,3);

//arr=insertInSortedArray(arr,6);
//System.out.println(2%5);
//arr=mergeSortedArrays(arr,arr2);
//System.out.println(Arrays.toString(arr))
		// reverserInteger(-1234);
//convertToInteger("  -1234");

		// AB.main(new String[] {"a","b"});
		// AB ab = new AB();
//		ab.hello();
//Comparator<Integer> com = new Comparator<Integer>() {
//
//	@Override
//	public int compare(Integer o1, Integer o2) {
//	   
//		return o1.intValue()>o2.intValue()?o2:o1;
//	}
//	
//};
//com = (c,b) -> c<b?1:-1;
//
//TreeSet<AB>  t = new TreeSet<>(); 
//		AB a1 = new AB();
//		a1.id=10;
//		AB a2 = new AB();
//		a2.id=20;
//		AB a3 = new AB();
//		a3.id=30;
//		AB a4 = new AB();
//		a4.id=40;
//		AB a5 = new AB();
//		a5.id=50;
//		
//		t.add(a1);
//		t.add(a2);
//		t.add(a3);
//		t.add(a4);
//		t.add(a5);
//		System.out.println(t);
		// System.out.println(integerToRoman(400));
		// System.out.println(romanToInteger("D"));
		// System.out.println(nonRepeatingChar("abcabc"));
		// System.out.println(longestPrefix(new String[] {"flow","flowight","flower"}));
//		int arr1[] = { 10, 8, 7, 5, 4, 11, 78 };
//		int arr3[] = { -1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4 };
//		Arrays.sort(arr3);
		// System.out.println(threeSum(arr3));
//		recursionBubbleSort(arr1,0,0);
//		System.out.println(Arrays.toString(arr1));
//		List.of(arr);

//		System.out.println(Arrays.toString(mergeTwoSortedArray(new int[] {1,3,5,7,9},new int[] {2,4,6,7,8})));
//		System.out.println(Arrays.toString(selectionSortRecu(new int[] {7,9,4,3,2,1,54,3},0,1,0)));

//		System.out.println(Arrays.toString(insertionSort(new int[] {9,8,6,5,4,3,5})));
		// System.out.println(uniqueOccurance(new int[] {1,1,1,2,2,2,3,4,4,5,4,5}));;
//		System.out.println(reverseKElements(new int[] {1,2,3,4,5,6,7,8,9},2));

		// System.out.println(isArraySortedOrRotated(new int[] {5,6,7,8,1}));
		// System.out.println(Arrays.toString(twoSum2(new int[] {2 ,7,8,5,2,1},9)));
		// System.out.println(longestPrefixs(new String[] {"ab","aba","ad"}));
		// System.out.println(Arrays.toString(removeDuplicatess(new int[]
		// {1,1,2,2,3,4,4,5,55,5})));
		// System.out.println(firstOccurances("hadbadhad","had"));
		// String s[]= {"aaa","aec","adc","ae"};
//		Arrays.sort(s);
//		System.out.println(lastWordLength("hello world jav   "));
		// System.out.println(Arrays.toString(plusOneOptimized(new int[] {9,9,})));
		// System.out.println(isPolindrom("5?6?7?876?5"));
		// System.out.println(reverseWords("A man, a plan, a canal: Panama"));
//		System.out.println(mostOccurrance("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(mostOccurranceInString("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(replaceString("a man is one the street"));
//	System.out.println(replaceAllDigitsWithCharacter("a1b2c3"));
		// System.out.println(removeAllSubstring("aabababa","aba"));
//System.out.println(removeAllDuplicates("aabbccdeffghill"));
		// System.out.println(1%2);
//		char ch[]=new char[] {'a','a','a','b','b','a','a'};
//		int n=countLetters(ch);
//		for(int i=0;i<n;i++) {
//			System.out.print(ch[i]+",");
// 		System.out.println(System.currentTimeMillis());
//		}
//		System.out.println(Arrays.toString(mergeSorted(new int[] {1,2,3,4},3,new int[] {2,5,6},2)));
		// int arr[][] = new int[][] { { 1, 2, 3} ,{ 4, 5, 6} ,{7,8,9}};
//		printWave(arr,2,3);
		// System.out.println(reverseVowels("hello"));
//		printSprial(arr);
//		generateMatrix(5);
//		arr = rotateArray90(arr);
//		for(int i=0;i<arr.length;i++) {
//			for(int j=0;j<arr[0].length;j++)
//				System.out.print(arr[i][j]+" ");
//			System.out.println();
//		}

//		int arr []= {1,2};
		// rotateArrayWithK(arr, 3);
//		int arr[][] = {{1,2,3},{4,5,6},{7,8,9}};  
//		List<List<Integer>> shiftGrid = shiftGrid(arr, 2);
//		for(int i =0 ;i<shiftGrid.size();i++) {
//			System.out.println(shiftGrid.get(i));
//		}

//		System.out.println(maximumSumOfTwoSubStringScore("00111"));
//		System.out.println(convertArrayIn2DArray(new int[] {1,2,3,4,5,5,6,200,200}));
//	System.out.println(missingNumber(new int[] {9,6,4,2,3,5,7,0,1}));	
//		System.out.println(unique(new int[] {1,1,2,2,3,3,9}));
		// System.out.println(Arrays.toString(findErrorNums(new int[] {1,2,2,4})));
		//	kajuKatli(10);
		System.out.println(System.currentTimeMillis());
		System.out.println(minOperations("1000"));
		System.out.println(System.currentTimeMillis());
	}

	public static int minOperations(String s) {
		int count[] = new int[2];
		for(int i=0;i<s.length();i++) {
			count[s.charAt(i)-'0']++;
		}
		if(count[0]>count[1]) {
		return	(count[0]-count[1])/2;
		}
		(count[0]-count[1])/2;
		System.out.println(Arrays.toString(count));
		return 0;
	}
	
	
	public static int[] findErrorNums(int[] arr) {
		Set<Integer> value = new HashSet<>();
		int[] ar = new int[2];
		for (int i = 0; i < arr.length; i++) {
			if (value.contains(arr[i])) {
				ar[0] = arr[i];
				arr[1] = arr[i] + 1;
				System.out.println(arr[i] + 1);
				return ar;
			}
			value.add(arr[i]);
		}
		return ar;
	}

	public static int[] selectionSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			int min = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[j] < arr[min])
					min = j;
			}
			int temp = arr[i];
			arr[i] = arr[min];
			arr[min] = temp;

		}
		return arr;
	}

	public static int[] bubbleSortPr(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}

			}
		}
		return arr;
	}

	public static int unique(int arr[]) {
		int xor = 0;
		for (int i = 0; i < arr.length; i++) {
			xor ^= arr[i];
		}
		return xor;
	}

	public static int xorDuplicate(int arr[]) {

		for (int i = 0; i < arr.length; i++) {

		}
		return 0;
	}

	public static int missingNumber(int arr[]) {
		int max = findMaximum(arr);
		int total = max * (max + 1) / 2, sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return total - sum == 0 ? max + 1 : total - sum;
	}

	public static int countNumber(int arr[], int value) {
		int count = 0;

		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == value)
				count++;
			if (count > 2)
				return count;
		}
		return count;
	}

	public static int uniqueElement(int arr[]) {
		Set<Integer> value = Arrays.stream(arr).boxed().collect(Collectors.toSet());
		Iterator<Integer> iterator = value.iterator();
		while (iterator.hasNext()) {
			int va = iterator.next();
			if (count(arr, va) < 2)
				return va;
		}
		return -1;
	}

	public static int findMaximum(int arr[]) {
		int max = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] > max)
				max = arr[i];
		}
		return max;
	}

	public static List<List<Integer>> convertArrayIn2DArray(int arr[]) {
		// int max = findMaximum(arr);
		int count[] = new int[201];
		for (int i = 0; i < arr.length; i++)
			count[arr[i]]++;
//		System.out.println(Arrays.toString(count));
		int max = findMaximum(count);
		List<List<Integer>> response = new ArrayList<>();
		for (int i = 0; i < max; i++) {
			List<Integer> list = new ArrayList<>();
			for (int j = 0; j < count.length; j++) {
				if (count[j] > 0) {
					list.add(j);
					count[j]--;
				}
			}
			response.add(list);
		}

		return response;
	}

	public static int count(char arr[], int st, int end, char ch) {
		int count = 0;
		while (st <= end) {
			if (arr[st] == ch)
				count++;
			st++;
		}

		return count;
	}

	public static int maximumSumOfTwoSubStringScore(String s) {
		char[] arr = s.toCharArray();
		int i = 0, j = i + 1, max = 0;
		while (i < j && j < arr.length) {
			int cou = count(arr, i, j - 1, '0') + count(arr, j, arr.length - 1, '1');

			if (cou > max)
				max = cou;
			j++;
		}
		return max;
	}

	public static List<List<Integer>> shiftGrid(int arr[][], int k) {
		int row = arr.length, col = arr[0].length, j = row * col - 1, count = 0;
		while (count++ < k) {
			int ele = arr[arr.length - 1][arr[0].length - 1];
			for (j = row * col - 1; j > 0; j--) {
				arr[j / col][j % col] = arr[(j - 1) / col][(j - 1) % col];
			}
			arr[0][0] = ele;

		}
		List<List<Integer>> ar = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			List<Integer> ro = new ArrayList<>();
			for (j = 0; j < arr[0].length; j++) {
				ro.add(arr[i][j]);
			}
			ar.add(ro);

		}
		return ar;
	}

	public static boolean binarySearch2DInSortedRow(int arr[][], int target) {
		int row = 0, col = arr[0].length - 1;

		while (col >= 0 && row <= arr.length - 1) {
			if (arr[row][col] == target)
				return true;
			if (arr[row][col] < target)
				row++;
			else
				col--;
		}
		return false;
	}

	public static boolean binarySearchIn2D(int arr[][], int target) {
		int row = arr.length;
		int col = arr[0].length;
		int st = 0;
		int end = row * col - 1;

		while (st <= end) {
			int mid = st + (end - st) / 2;
			int element = arr[mid / col][mid % col];
			if (element == target)
				return true;
			if (element < target)
				st = mid + 1;
			else
				end = mid - 1;

		}
		return false;

	}

	public static void rotateArrayWithK(int arr[], int k) {
		int arr2[] = new int[arr.length], l = 0;
		int kIndex = arr.length - k;

		if (k >= arr.length) {
			int count = 0;
			while (count++ <= k) {
				int temp = arr[arr.length - 1];
				System.out.println(Arrays.toString(arr));
				for (int j = arr.length - 1; j > 0; j--) {
					arr[j] = arr[j - 1];
				}
				arr[0] = temp;
			}
			return;
		}

		if (kIndex < 0)
			return;
		for (int i = kIndex; i < arr.length; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < kIndex; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < arr.length; i++)
			arr[i] = arr2[i];

	}

	public static int[][] rotateArray90(int arr[][]) {
		int arr3[][] = new int[arr.length][arr[0].length], k = 0;
		for (int col = 0; col < arr[0].length; col++) {
			k = 0;
			for (int row = arr.length - 1; row >= 0; row--) {
				arr3[col][k++] = arr[row][col];
			}

		}
		return arr3;
	}

	public static int[][] generateMatrix(int n) {
		int row = n;
		int col = n;
		int total = n * n;
		int startingCol = 0;
		int startingRow = 0;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int arr[][] = new int[n][n];
		int count = 0;
		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				arr[startingRow][i] = ++count;
			}

			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				arr[i][endingCol] = ++count;
			}

			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				arr[endingRow][i] = ++count;
			}

			endingRow--;

			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				arr[i][startingCol] = ++count;
			}
			startingCol++;

		}
		return arr;
	}

	public static void printSprial(int arr[][]) {
		int startingCol = 0;
		int startingRow = 0;
		int row = arr.length;
		int col = arr[0].length;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int count = 0;
		int total = row * col;

		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				System.out.print(arr[startingRow][i]);
				count++;
			}
			System.out.println();
			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				System.out.print(arr[i][endingCol]);
				count++;
			}

			System.out.println();
			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				System.out.print(arr[endingRow][i]);
				count++;
			}

			endingRow--;
			System.out.println();
			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				System.out.print(arr[i][startingCol]);
				count++;
			}
			startingCol++;
			System.out.println();
		}
	}

	public static boolean isVowel(char ch) {
		ch = Character.toLowerCase(ch);
		if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
			return true;
		return false;
	}

	public static String reverseVowels(String s) {

		char[] arr = s.toCharArray();
		int i = 0, j = arr.length - 1;
		while (i < j) {
			if (isVowel(arr[i]) && isVowel(arr[j])) {
				char t = arr[i];
				arr[i] = arr[j];
				arr[j] = t;
				i++;
				j--;
			} else if (isVowel(arr[i]))
				j--;
			else
				i++;
		}
		return new String(arr);
	}

	public static void printWave(int arr[][], int row, int col) {
		for (int j = 0; j < col; j++) {

			for (int i = 0; i < row; i++) {
				System.out.print(arr[i][j]);
			}

			System.out.println();
			j++;
			for (int i = row - 1; i >= 0 && j < col; i--) {
				System.out.print(arr[i][j]);
			}
			System.out.println();

		}
	}

	public static int[] mergeSorted(int arr[], int m, int arr1[], int n) {
		int arr3[] = new int[m + n], i = 0, j = 0, k = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j] && n > 0) {
				arr3[k++] = arr1[j++];
				n--;
			} else if (m > 0) {
				arr3[k++] = arr[i++];
				m--;
			} else
				break;

		}
		System.out.println(Arrays.toString(arr3));
		while (m > 0 && i < arr.length) {
			arr3[k++] = arr[i++];
			m--;
		}
		while (n > 0 && j < arr1.length) {
			arr3[k++] = arr1[j++];
			n--;
		}
		return arr3;
	}

	public static List<Foodsystem> system = new ArrayList<>();

	public void enterData() {
		String food[] = { "kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi" };
		String country[] = { "korean", "japanese", "japanese", "greek", "japanese", "korean" };
		int arr[] = { 9, 12, 8, 15, 14, 7 };
		for (int i = 0; i < country.length; i++) {
			Map<String, Integer> fs = new LinkedHashMap<>();
			Foodsystem s = new Foodsystem();
			s.count = country[i];
			s.food.put(food[i], arr[i]);
			this.add(s);
		}
		System.out.println(system);

	}

	public void add(Foodsystem o) {
		for (int i = 0; i < this.system.size(); i++) {
			if (system.get(i).count.equals(o.count)) {
				system.get(i).food.putAll(o.food);
				return;
			}

		}
		this.system.add(o);
	}

	public void changeRating(String food, int rating) {
		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem f = system.get(i);
			if (f.food.containsKey(food)) {
				f.food.put(food, rating);
				return;
			}

		}

	}

	public String highestRating(String country) {
		String city = "";

		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem s = system.get(i);
			if (s.count.equals(country)) {
				int max = 0;
				Set<Entry<String, Integer>> entrySet = s.food.entrySet();
				System.out.println(entrySet);
				for (Entry<String, Integer> e : entrySet) {
					if (e.getValue() > max) {
						max = e.getValue();
						city = e.getKey();

					}
					if (e.getValue() == max) {
						s.food.put(e.getKey(), e.getValue());
					}
				}
			}

		}

		return city;
	}

	public static int countLetters(char[] s) {
		int k = 0;
		for (int i = 0; i < s.length;) {
			char ch = s[i];
			int j = i + 1, count = 1;

			while (j < s.length && s[j] == ch) {
				count++;
				j++;
			}
			System.out.println(ch + " " + count + " " + j);
			if (count > 1) {
				s[k++] = ch;
				for (char c : Integer.toString(count).toCharArray()) {
					if (k < s.length)
						s[k++] = c;
					else
						return k;
				}
			} else {
				s[k++] = ch;
			}
			i = j;
		}
		return k;
	}

	public static String removeAllDuplicates(String s) {
		StringBuilder sb = new StringBuilder();
		int count[] = new int[26];
		for (int i = 0; i < s.length(); i++) {
			int num = s.charAt(i) - 'a';
			count[num]++;
		}

		for (int i = 0; i < s.length(); i++) {
			if (count[(s.charAt(i) - 'a')] < 2)
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static String removeAllSubstring(String s, String part) {
		while (s.length() != 0 && s.contains(part))
			s = s.replaceFirst(part, "");

		return s;
	}

	public static String replaceAllDigitsWithCharacter(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
				sb.append((char) (s.charAt(i - 1) + (s.charAt(i) - 48)));
			else
				sb.append(s.charAt(i));
		}
		return sb.toString();

	}

	public static String replaceString(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == ' ')
				sb.append("@40");
			else
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static char mostOccurranceInString(String s) {
		int arr[] = new int[26]; // storing occurance of every letter according to index
		s = s.toLowerCase();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
				int num = s.charAt(i) - 'a';
				arr[num]++;
			}
		}

		// finding max
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < arr.length; i++) {
			if (max < arr[i]) {
				max = arr[i];
				ch = (char) i;
			}

		}
		return (char) (ch + 'a');

	}

	// brute force
	public static char mostOccurrance(String s) {
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < s.length(); i++) {
			int count = 0;
			for (int j = i + 1; j < s.length(); j++) {
				if (s.charAt(i) == s.charAt(j) && s.charAt(i) != ' ')
					count++;
			}

			if (count > max) {
				ch = s.charAt(i);
				max = count;
			}
		}
		return ch;
	}

	public static int climbStairs(int n) {

		if (n < 0)
			return 0;
		if (n == 0)
			return 1;
		return climbStairs(n - 1) + climbStairs(n - 2);
	}

	public static void reverseString(char[] ch, int st, int end) {

		while (st < end) {
			char temp = ch[st];
			ch[st] = ch[end];
			ch[end] = temp;
			st++;
			end--;
		}

	}

	public static char[] reverseWords(String s) {
		char ch[] = s.toCharArray();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ' && s.charAt(i) != ',') {
				int j = i + 1;
				for (; j < s.length(); j++) {
					if (s.charAt(j) == ' ' || s.charAt(j) == ',')
						break;
				}
				reverseString(ch, i, j - 1);
				i = j;
			}
		}
		return ch;
	}

	public static boolean isAlphaNumeric(char c) {
		if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9')
			return true;
		return false;
	}

	public static boolean isPolinromValidAlgo(String s) {
		StringBuilder b = new StringBuilder();
		// remove special characters only left alphanumeric
		for (int i = 0; i < s.length(); i++) {
			if (isAlphaNumeric(s.charAt(i)))
				b.append(s.charAt(i));

		}

		// to lower case
		String str = b.toString().toLowerCase();
		int st = 0, end = str.length() - 1;
		while (st < end) {
			if (str.charAt(st) != str.charAt(end))
				return false;
			st++;
			end--;
		}
		return true;

	}

	public static boolean isPolindrom(String s) {
		int st = 0, end = s.length() - 1;
		while (st < end) {
			if (s.charAt(st) >= '0' && s.charAt(st) <= '9') {
				if (s.charAt(end) >= '0' && s.charAt(end) <= '9') {

					if (s.charAt(st) != s.charAt(end))
						return false;
					else {
						st++;
						end--;
					}
				} else
					end--;
			} else
				st++;
		}
		return true;
	}

	// optimized
	public static int[] plusOneOptimized(int arr[]) {
		for (int i = arr.length - 1; i >= 0; i--) {
			if (arr[i] < 9) {
				arr[i]++;
				return arr;
			}
			arr[i] = 0;
		}
		arr = new int[arr.length + 1];
		arr[0] = 1;
		return arr;
	}

	// brute force
	public static int[] plusOne(int arr[]) {
		if (arr.length < 1)
			return arr;
		int carry = 1;
		for (int i = arr.length - 1; i >= 0; i--) {
			arr[i] = arr[i] + carry;
			carry = 0;
			if (arr[i] > 9) {
				arr[i] = 0;
				carry = 1;
			} else
				break;
		}

		if (carry != 0) {
			int ar[] = new int[arr.length + 1];
			ar[0] = carry;
			for (int i = 1; i < ar.length - 1; i++)
				ar[i] = arr[i];
			return ar;
		}
		return arr;
	}

	public static int countLastWordLength(String s, int index) {
		int count = 0;
		for (; index >= 0; index--) {
			if (s.charAt(index) != ' ')
				count++;
			else
				break;
		}
		return count;
	}

	public static int lastWordLength(String s) {
		for (int i = s.length() - 1; i >= 0; i--) {
			if (s.charAt(i) != ' ')
				return countLastWordLength(s, i);
		}
		return 0;
	}

	public static int firstOccurances(String s, String value) {
		if (s.contains(value)) {
			return s.indexOf(value);
		}
		return -1;
	}

	public static boolean isMatched(String s, String value) {
		if (s.length() < value.length())
			return false;
		for (int i = 0; i < value.length(); i++) {
			if (s.charAt(i) != value.charAt(i))
				return false;
		}
		return true;
	}

	public static int firstOccurance(String s, String value) {
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == value.charAt(0)) {
				if (isMatched(s.substring(i), value))
					return i;
			}
		}
		return -1;
	}

	public static int[] removeDuplicatess(int arr[]) {
		int i = 0, j = 1;
		for (i = 1; i < arr.length; i++) {
			if (arr[i - 1] != arr[i])
				arr[j++] = arr[i];
		}
		return arr;
	}

	public static int[] removeDuplicates(int arr[]) {
		Set<Integer> set = new LinkedHashSet<>();
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		return set.stream().mapToInt(i -> i).toArray();

	}

	public static String longestPrefixs(String arr[]) {
		Arrays.sort(arr);
		StringBuilder b = new StringBuilder();
		String first = arr[0];
		String last = arr[arr.length - 1];
		for (int i = 0; i < Math.min(first.length(), last.length()); i++) {
			if (first.charAt(i) != last.charAt(i))
				return b.toString();
			b.append(first.charAt(i));
		}
		return b.toString();

	}

	public static int[] twoSum2(int[] arr, int target) {
		int f = 0, l = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 1; j < arr.length; j++) {
				if (arr[i] + arr[j] == target) {
					f = i;
					l = j;
				}
			}
		}
		return new int[] { f, l };
	}

	public static Boolean arraySortedOrRotated(int arr[]) {
		int count = 0;
		for (int i = 1; i < arr.length; i++) {
			if (arr[i - 1] > arr[i])
				count++;
		}
		if (arr[0] < arr[arr.length - 1])
			count++;

		return count == 1;
	}

	// brute force
	public static Boolean isArraySortedOrRotated(int arr[]) {
		int i = 0;
		for (i = 0; i < arr.length - 1; i++) {
			if (arr[i] > arr[i + 1])
				break;

		}
		System.out.println(i + " -<");
		i++;
		for (; i < arr.length - 1; i++) {
			System.out.println("->" + i);
			if (arr[0] < arr[i] || arr[i] > arr[i + 1])
				return false;
		}
		if (i < arr.length && arr[0] < arr[i])
			return false;
		return true;
	}

	public static int findUnique(int arr[]) {
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {

			ans = ans ^ arr[i];
		}
		return ans;
	}

	public static int count(int arr[], int value) {
		int count = 0;
		for (int i = 0; i < arr.length; i++) {
			if (value == arr[i])
				count++;
		}
		return count;

	}

	public static int uniqueOccurance(int arr[]) {
		int arr1[] = new int[arr.length], k = 0;
		for (int i = 0; i < arr.length; i++) {
			if (!isPreExists(arr[i], arr, i - 1)) {

				int count = count(arr, arr[i]);
				arr1[k++] = count;
				System.out.println("count " + count);
			}
		}
		return findUniqueElement(arr1);
	}

	public static int[] reverse(int arr[], int st, int end) {
		if (end < arr.length)
			while (st < end) {
				int k = arr[st];
				arr[st++] = arr[end];
				arr[end--] = k;
			}
		return arr;
	}

	public static int[] reverseKElements(int arr[], int k) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length; i += k) {

			reverse(arr, i, i + k - 1);
		}
		System.out.println(Arrays.toString(arr));
		return arr;

	}

	public static boolean isPreExists(int value, int arr[], int k) {
		for (int i = k; i >= 0; i--) {
			if (arr[i] == value)
				return true;
		}
		return false;
	}

	public static int findUniqueElement(int arr[]) {
		System.out.println(Arrays.toString(arr));
		for (int i = 0; i < arr.length; i++) {
			int count = 0;
			if (!isPreExists(arr[i], arr, i - 1))
				for (int j = i; j < arr.length; j++) {

					if (arr[i] == arr[j])
						count++;
				}

			if (count == 1) {
				System.out.println("found " + arr[i]);

				return arr[i];
			}
		}
		return 0;
	}

	public static int[] insertionSort(int arr[]) {
		int j = 0;
		for (int i = 0; i < arr.length; i++) {
			int k = arr[i];
			for (j = i - 1; j >= 0; j--) {
				if (arr[j] < k) {
					arr[j + 1] = arr[j];
				} else
					break;
			}
			arr[j + 1] = k;
		}
		return arr;
	}

	public static int[] selectionSortRecu(int arr[], int i, int j, int min) {
		if (i >= arr.length)
			return arr;
		if (j < arr.length) {
			if (arr[min] > arr[j])
				min = j;
			return selectionSortRecu(arr, i, j + 1, min);
		}
		int k = arr[i];
		arr[i] = arr[min];
		arr[min] = k;
		return selectionSortRecu(arr, i + 1, i + 2, i + 1);
	}

	public static int[] mergeTwoSortedArray(int arr[], int arr1[]) {
		int arr3[] = new int[arr.length + arr1.length], k = 0, i = 0, j = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j]) {
				arr3[k++] = arr1[j++];

			} else {
				arr3[k++] = arr[i++];

			}
		}

		while (i < arr.length) {
			arr3[k++] = arr[i++];
		}
		while (j < arr1.length) {
			arr3[k++] = arr1[i++];
		}
		return arr3;
	}

	public static void recursionBubbleSort(int arr[], int i, int j) {
		if (i == arr.length)
			return;
		if (j < arr.length - i - 1 && arr[j] > arr[j + 1]) {

			int k = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = k;
			System.out.println(Arrays.toString(arr));
			recursionBubbleSort(arr, i, j + 1);

		} else {
			System.out.println("----- " + Arrays.toString(arr));
			recursionBubbleSort(arr, i + 1, 0);
		}

	}

	public static void bubbleSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int k = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = k;
				}

			}
		}
	}

	public static List<List<Integer>> threeSum(int arr[]) {
		int i = 0, j = 0, k = arr.length - 1;
		Set<List<Integer>> output = new HashSet<>();
		for (i = 0; i < arr.length; i++) {
			j = i + 1;
			k = arr.length - 1;
			while (j < k) {
				System.out.println(arr[i] + "->" + arr[j] + "->" + arr[k] + "=> " + (arr[i] + arr[j] + arr[k]) + " ( "
						+ i + "," + j + "," + k);
				if (arr[i] + arr[j] + arr[k] == 0) {
					List<Integer> list = new ArrayList<>();
					list.add(arr[i]);
					list.add(arr[j]);

					list.add(arr[k]);
					output.add(list);
				} else if (arr[i] + arr[j] + arr[k] > 0) {
					k--;
					j--;
				}
				j++;

			}
		}

		return output.stream().toList();

	}

	public static String longestPrefix(String s[]) {

		String prefix = "";

		for (int i = 0; i < s.length; i++) {
			for (int j = i + 1; j < s.length; j++) {
				if (s[i].length() > s[j].length()) {
					String temp = s[i];
					s[i] = s[j];
					s[j] = temp;
				}
			}
		}

		String st = s[0];
		boolean isMatched = false;
		for (int j = 0; j < st.length(); j++) {
			char ch = st.charAt(j);

			for (int k = 1; k < s.length; k++) {
				isMatched = false;

				if (ch == s[k].charAt(j)) {
					isMatched = true;
				} else
					break;
			}
			if (isMatched)
				prefix += ch;
			else
				break;

		}
		;
		return prefix;

	}

	public static String nonRepeatingChar(String s) {
		for (int i = 0; i < s.length(); i++) {
			boolean isPresent = false;
			for (int j = 0; j < s.length(); j++) {
				if (i != j && s.charAt(i) == s.charAt(j)) {
					isPresent = true;
					break;
				}
			}
			if (!isPresent) {
				return s.charAt(i) + "";
			}
		}
		return "All Are repated";
	}

	public static Integer romanToInteger(String s) {
		int num = 0;
		Map<String, Integer> romans = new HashMap<>();
		romans.put("M", 1000);
		romans.put("CM", 900);
		romans.put("D", 500);
		romans.put("CD", 400);
		romans.put("C", 100);
		romans.put("XC", 90);
		romans.put("L", 50);
		romans.put("XL", 40);
		romans.put("X", 10);
		romans.put("IX", 9);
		romans.put("V", 5);
		romans.put("IV", 4);
		romans.put("I", 1);
//System.out.println(romans.get("M"));
		if (s.length() < 2)
			return romans.get(s.charAt(0) + "");
		for (int i = 0; i < s.length() - 1; i++) {

			if (romans.get(s.charAt(i) + "").intValue() >= romans.get(s.charAt(i + 1) + "").intValue()) {
				num += romans.get(s.charAt(i) + "");
				System.out.println("num -> " + num);
			} else {

				int sum = romans.get(s.charAt(i + 1) + "") - romans.get(s.charAt(i) + "");
				System.out.println("num    => " + num + "  sum => " + sum);
				num += sum;
				i++;
				System.out.println("--------- " + num);
			}
			if (i == s.length() - 2)
				if (romans.get(s.charAt(i + 1) + "").intValue() <= romans.get(s.charAt(i) + "").intValue()) {
					num += romans.get(s.charAt(i + 1) + "");

				}
		}
		return num;
	}

	public static String integerToRoman(int num) {
		Integer number[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
		String romans[] = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };
		String result = "";
		for (int i = 0; i < number.length; i++) {

			while (num >= number[i]) {
				num -= number[i];
				result += romans[i];
			}
		}
		return result;

	}

	public static int convertToInteger(String s) {
		String st = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {
				st += s.charAt(i);
			} else if (s.charAt(i) == '-')
				st += s.charAt(i);
		}
		System.out.println(Integer.parseInt(st));
		return 0;
	}

	public static int reverserInteger(int n) {
		int rev = 0;
		while (n != 0) {
			int r = n % 10;
			n /= 10;
			rev = rev * 10 + r;
		}
		System.out.println(rev);
		return 0;
	}

	public static int[] mergeSortedArrays(int a1[], int a2[]) {
		int a3[] = new int[a1.length + a2.length], j = 0, k = 0, i = 0;

		Stack<Character> stack = new Stack();
		String s = "a";
		Character c = s.charAt(i);
		System.out.println(c.equals(c));

		while (i < a1.length && j < a2.length) {

			if (a1[i] >= a2[j])
				a3[k++] = a2[j++];
			else
				a3[k++] = a1[i++];

		}
		while (i < a1.length)
			a3[k++] = a1[i++];

		while (j < a2.length)
			a3[k++] = a2[j++];

		return a3;

	}

	public static int[] insertInSortedArray(int arr[], int value) {
		int temp[] = new int[arr.length + 1], j = 0;
		boolean isInserted = false;
		for (int i = 0; i < arr.length; i++) {

			if (!isInserted && arr[i] > value) {
				temp[j++] = value;
				isInserted = true;
			}
			temp[j++] = arr[i];
		}
		if (!isInserted)
			temp[j++] = value;
		return temp;
	}

	public static int[] inserAtNthPos(int arr[], int value, int pos) {
		int j = 0;
		int temp[] = new int[arr.length + 1];
		if (pos < 1)
			return arr;

		for (int i = 0; i < arr.length; i++) {
			if (i == pos - 1)
				temp[j++] = value;

			temp[j++] = arr[i];
		}
		if (pos > arr.length) {
			temp[j++] = value;
		}

//	for(int i=0;i<temp.length;i++)
//		arr[i]=temp[i];
		return temp;
	}

	public static void righRotation(int arr[], int num) {
		int n = arr.length, temp = 0, count = 0;
		while (count++ < num) {
			temp = arr[n - 1];
			for (int i = n - 1; i > 0; i--)
				arr[i] = arr[i - 1];
			arr[0] = temp;
		}

	}

	public static void leftRotation(int arr[], int num) {
		int temp[] = new int[arr.length], n = arr.length, j = 0;

		for (int i = num; i < n; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < num; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < n; i++)
			arr[i] = temp[i];
	}

	public static char[] copyArray(char[] arr) {
		if (arr == null)
			return new char[1];

		char[] a = Arrays.copyOf(arr, arr.length + 1);
		return a;
	}

	public static String zigzapConversion(String s, int num) {
		char[][] arr = new char[num][];
		int k = 0, i = 0, j = 0, t = 0;
		while (k < s.length()) {
			while (i != num - 1) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i++;
			}
			j++;
			while (i != 0) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i--;
			}
			j++;

		}
		for (char[] a : arr) {
			for (char tt : a)
				System.out.print(tt);
			System.out.println();
		}
		return "";
	}

	public static String longestPolindromSubtString(String s) {
		String ans = "";
		if (s.length() < 1)
			return s;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - 1; j >= 0; j--) {
				if (i < j) {
					String sub = s.substring(i, j + 1);
					if (sub.equals(new StringBuilder(sub).reverse().toString())) {
						if (sub.length() > ans.length()) {
							ans = sub;
						}

					}
				}
			}
		}

		return ans;
	}

	public static double medianOfTwoSortedArray(int[] arr1, int[] arr2) {

		int arr3[] = new int[arr1.length + arr2.length], i = 0, j = 0, k = 0;
		while (true) {
			if (i < arr1.length) {
				arr3[k++] = arr1[i++];
			} else if (j < arr2.length) {
				arr3[k++] = arr2[j++];
			} else
				break;

		}
		double ans = 0;
		Arrays.sort(arr3);
		System.out.println(Arrays.toString(arr3));
		if (arr3.length % 2 == 0) {
			int mid = arr3.length / 2;
			ans = (double) (arr3[mid - 1] + arr3[mid]) / 2;
			System.out.println(arr3[mid - 1]);
		} else {
			ans = arr3[arr3.length / 2];
		}

		return ans;
	}
// 4
// 1,1,1,1
// 2,1,1
// 1,1,2
// 2,2

	public static int[] twoSum(int arr[], int target) {
		int f = 0, sec = 0;
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {
				if (arr[i] + arr[j] == target && i != j) {

					f = i;
					sec = j;
				}
			}

		}
		System.out.println(f + " " + sec);
		return new int[] { f, sec };
	}

	public static char[] stringToArrayOfCharacters(String s) {
		char arr[] = new char[s.length()];
		for (int i = 0; i < s.length(); i++) {
			arr[i] = s.charAt(i);
		}
		return arr;
	}

	public static String[] textToWordsArray(String text) {
		List<String> words = new ArrayList<>();
		for (int i = 0; i < text.length(); i++) {

			for (int j = i; j < text.length() - 1; j++) {
				if (i > 0 && text.charAt(i) == ' ' && text.charAt(j + 1) == ' ' && text.charAt(i - 1) != ' ') {
					words.add(text.substring(i + 1, j + 1));
					break;
				} else if (i == 0 && text.charAt(j + 1) == ' ') {
					words.add(text.substring(i, j + 1));
					break;
				} else if (text.charAt(i) == ' ' && j + 1 == text.length() - 1) {
					words.add(text.substring(i + 1, text.length()));
					break;
				}
			}

		}
		String s[] = new String[words.size()];
		int i = 0;
		ListIterator<String> listIterator = words.listIterator();
		while (listIterator.hasNext()) {
			s[i++] = listIterator.next();
		}
		return s;
	}

	public static int wordCount(String s) {
		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0)
				count++;
			else if (s.charAt(i) == ' ')
				for (int j = i; j < s.length() - 1; j++) {
					if (s.charAt(j + 1) == ' ' && s.charAt(i - 1) != ' ') {
						count++;
						System.out.print(s.charAt(i) + " - > " + s.charAt(j) + " = " + count);
						break;
					}
				}
		}
		return count + 1;

	}

	public static void uniqueFromArrays(int arr[], int arr2[]) {

		List<Integer> list1 = List.of(1, 2, 4);
		List<Integer> list2 = List.of(1, 2, 3, 5);
		List<Integer> unique = new ArrayList<>();
		unique.addAll(list1);
		unique.addAll(list2);
		unique = unique.stream().distinct()
				.filter(a -> list1.contains(a) && !list2.contains(a) || !list1.contains(a) && list2.contains(a))
				.collect(Collectors.toList());
		System.out.println(unique);

		int k = 0;
		for (int i = 0; i < arr.length || k < arr2.length; i++, k++) {
			boolean a = false;
			boolean b = false;
			if (i < arr.length)
				for (int j = 0; j < arr2.length; j++) {
					if (arr[i] == arr2[j])
						a = true;
				}
			for (int j = 0; j < arr.length; j++) {
				if (arr2[k] == arr[j])
					b = true;
			}
			if (!a && i < arr.length)
				System.out.println(arr[i]);
			if (!b)
				System.out.println(arr2[k]);
		}
	}

	public static void arraySum(int arr[], int arr2[]) {
		int carry = 0, total = 0, j = 0, k = arr2.length - 1, i;
		List<Integer> sum = new ArrayList<>();

		for (i = arr.length - 1; i >= 0 && k >= 0; i--, k--) {

			total = arr[i] + arr2[k] + carry;
			carry = 0;
			if (total > 9) {
				carry = total % 10;
				total /= 10;
			}
			sum.add(total);

		}

		if (i < 0 && k >= 0) {
			for (int a = k; a >= 0; a--)
				sum.add(arr2[a]);
		}
		if (k < 0 && i >= 0) {
			for (int a = i; a >= 0; a--)
				sum.add(arr[a]);
		}
		Collections.reverse(sum);
		System.out.println(sum);
	}

	public static void arrayRightRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[arr.length - 1];
			for (j = arr.length - 1; j > 0; j--) {
				arr[j] = arr[j - 1];
			}
			count++;
			arr[0] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static void arrayLeftRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[0];
			for (j = 0; j < arr.length - 1; j++) {
				arr[j] = arr[j + 1];
			}
			count++;
			arr[j] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static boolean anagram(String s, String s1) {

		int count = 0;
		boolean b = false;
		for (int i = 0; i < s.length(); i++) {
			char ch = s.charAt(i);
			count = 0;
			b = false;
			for (int k = 0; k < s.length(); k++) {
				if (ch == s.charAt(k))
					count++;
			}

			for (int j = 0; j < s1.length(); j++) {
				if (count > 0 && ch == s1.charAt(j))
					count--;
			}
			if (count == 0)
				b = true;
		}

		System.out.println(b ? "yes" : "no");
		return b;
	}

	public static int count(int i, int arr[]) {
		int count = 0;
		for (int a : arr) {
			if (a == i)
				count++;
		}
		System.out.println(count);
		return count;
	}

	public static void majorityElement(int arr[]) {
		int max = 0, count = 0;
		for (int i = 0; i < arr.length; i++) {
			count = count(arr[i], arr);
			if (count >= max && count > arr.length / 2)
				max = arr[i];

		}
		System.out.println(max);
	}

	public static void longestPolindrom(String s) {

		int first = 0, last = s.length() - 1, max = 0;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - i; j >= 0; j--) {
				if (i < j && j < s.length())
					if (checkPolindrom(i, j + 1, s) && max < s.substring(i, j).length()) {

						max = s.substring(i, j + 1).length();
						first = i;
						last = j + 1;
					}
			}
			System.out.println("------");

		}
		System.out.println(s.substring(first, last));

	}

	public static boolean checkPolindrom(int f, int l, String s) {
		String st = s.substring(f, l);
		System.out.println(st + "444");
		return st.equals(new StringBuffer(st).reverse().toString());

	}

	public void spiralMatrix() throws ClassNotFoundException, NoSuchMethodException, SecurityException,
			InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		int a[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };
		int j = 0, k = 0, count = 0, max = 10 - 1;
		// int max=a.length*a.length-1;
		// System.out.println(a.length);

		for (int i = 0; i < a.length - i; i++) {

			if (count == max)
				break;

			for (j = i; j < a.length - i && count <= max; j++) {
				count++;
				System.out.println(a[k][j]);
			}
			j--;

			k++;
			while (k < a.length - i && count <= max) {
				System.out.println(a[k][j]);
				k++;
				count++;
			}
			k--;
			j--;

			while (j >= 0 && count <= max) {
				count++;
				System.out.println(a[k][j--]);
			}

			// k=i+1;
			if (k == a.length / 2 && j == a.length / 2)
				break;
			j++;
			while (k > i + 1 && count <= max) {
				System.out.println(a[--k][j]);
				count++;
			}

			k = i + 1;
			System.out.println("-----------------");
		}

	}

	public static ArrayList<Integer> findIndexes(int arr[], int sum) {
		boolean a = false;
		int f = 0, l = arr.length, s = 0;
		for (int i = 0; i < arr.length; i++) {
			s = 0;
			if (a)
				break;

			for (int j = i; j < arr.length; j++) {
				s += arr[j];
				if (s == sum) {
					f = i;
					l = j;
					a = true;
					break;
				}

			}
			System.out.println(s);
		}

		return a ? new ArrayList<Integer>(Arrays.asList(f, l)) : new ArrayList<Integer>(Arrays.asList(-1));
	}

	public int count(char a, String s) {
		class A {
			static int a;

			public void main() {
				System.out.println("hello");
			}
		}

		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == a)
				count++;
		}
		return count;
	}

	public static boolean isPresent(char a, int indx, String s) {
		for (int i = indx; i >= 0; i--) {
			if (s.charAt(i) == a)
				return true;
		}
		return false;
	}

	public static boolean isPresent(int a, int indx, int ar[]) {
		for (int i = indx; i >= 0; i--) {
			if (ar[i] == a)
				return true;
		}
		return false;
	}

	public static void fibonacci(int t1, int t2, int n) {
		if (n == 0)
			return;
		else {
			int t3 = t1 + t2;
			t1 = t2;
			t2 = t3;
			System.out.println(t3);
			fibonacci(t1, t2, n - 1);
		}

	}

	public static int factorial(int n) {
		if (n == 1)
			return 1;
		else
			n = n * factorial(n - 1);
		return n;

	}

	public static String removeSpaces(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ')
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static int[] removeDuplicate(int[] a) {
		int arr[] = new int[a.length];
		int j = 0;
		for (int i = 0; i < a.length; i++) {
			if (!isPresent(a[i], i - 1, a))
				arr[j++] = a[i];
		}
		a = new int[j];
		System.out.println(j);
		for (int i = 0; i < j; i++)
			a[i] = arr[i];
		return a;
	}

	class C {
		static int a;
	}
}

class B {
	int a = 10;

	public String toString() {
		System.out.println("askfjal");
		return new String(this.a + "");
	}

	public void hello(int... a) {

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-12-24 23:21:06.510
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-12-24 23:21:06.511
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-12-24 23:21:06.559
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.pract;

import java.lang.reflect.InvocationTargetException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.springframework.jdbc.core.metadata.OracleCallMetaDataProvider;

interface DD {

}

class AB implements Comparable<AB> {
	int id = 0;
	String name = "rohit";

	@Override
	public int compareTo(AB o) {
		if (this.id < o.id)
			return 1;

		return -1;
	}

	@Override
	public String toString() {
		return "AB [id=" + id + ", name=" + name + "]";
	}

}

abstract class kd {

}

class Foodsystem {
	public String count;
	public Map<String, Integer> food = new LinkedHashMap<>();

	public String toString() {
		return count + " =" + food;
	}

}

public class Test {

	public Test(int a) {

	}

	public static void main(String[] args) throws Exception {
		// fibonacci(0,1,20);
		// Class<?> clas = Class.forName("com.pract.Test");

		// Constructor<?> to = clas.getConstructor(int.class);
		// Test t = (Test) to.newInstance();
		var a = new Test(8);

		// System.out.println(Integer.toBinaryString(2));

		// new Random().ints(1,999).limit(20).sorted().forEach(System.out::println);
		// List<Integer> list = List.of(1,2,3,4,5);
		// System.out.println(list.stream().mapToInt(v->v).max().getAsInt());
		// list.stream().max(Integer::compare);

//		
//		longestPolindrom("bcac");
//	
//	majorityElement(new  int []{1,2,3,4,5,5});
//		
//	anagram("abcda","bcdaa");
//	String sp="TEST@$QWES 89";
//	sp = sp.replaceAll("\\d+","");
//	System.out.println(sp);

//arrayLeftRotation(new int[] {1,2,3,4,5},4);
//arrayRightRotation(new int[] {1,2,3,4,5},2);
//arraySum(new int[] {1,2,3,4},new int[] {1,2,3});
//uniqueFromArrays(new int[] {1,2,4},new int[] {1,2,3,5});
//wordCount("Hello what are you doing here you fucking bitch bastard");
//String s[]=textToWordsArray("Hello what are you doing here you fucking bitch bastard ab bcd");

//char arr[]=stringToArrayOfCharacters("hello what");

//twoSum(new int[] {2,7,11,15},9);
//		System.out.println(medianOfTwoSortedArray(new int[] {3},new int[] {-2,-1}));
//		System.out.println(longestPolindromSubtString("cbbd"));
		// zigzapConversion("PAYPALISHIRING",4);
//		Date d = new Date();
//		SimpleDateFormat f = new SimpleDateFormat("dd/MM/yyyy");
//		Date parse = f.parse("12/9/2023");
//		//LocalDate.now().
//		LocalDate l = LocalDate.now();
//		LocalDate l2 = LocalDate.of(2024, 10, 11);
//		Period period = Period.between(l, l2);
//		period.between(l, l2);
//		DayOfWeek dayOfWeek = l2.getDayOfWeek();
//		System.out.println(dayOfWeek.toString());

//		int arr[] = new int[] { 1, 2, 4 };
//		int arr2[] = new int[] { 1, 3, 4 };
		// righRotation(arr, 2);
//inserAtNthPos(arr,3,3);

//arr=insertInSortedArray(arr,6);
//System.out.println(2%5);
//arr=mergeSortedArrays(arr,arr2);
//System.out.println(Arrays.toString(arr))
		// reverserInteger(-1234);
//convertToInteger("  -1234");

		// AB.main(new String[] {"a","b"});
		// AB ab = new AB();
//		ab.hello();
//Comparator<Integer> com = new Comparator<Integer>() {
//
//	@Override
//	public int compare(Integer o1, Integer o2) {
//	   
//		return o1.intValue()>o2.intValue()?o2:o1;
//	}
//	
//};
//com = (c,b) -> c<b?1:-1;
//
//TreeSet<AB>  t = new TreeSet<>(); 
//		AB a1 = new AB();
//		a1.id=10;
//		AB a2 = new AB();
//		a2.id=20;
//		AB a3 = new AB();
//		a3.id=30;
//		AB a4 = new AB();
//		a4.id=40;
//		AB a5 = new AB();
//		a5.id=50;
//		
//		t.add(a1);
//		t.add(a2);
//		t.add(a3);
//		t.add(a4);
//		t.add(a5);
//		System.out.println(t);
		// System.out.println(integerToRoman(400));
		// System.out.println(romanToInteger("D"));
		// System.out.println(nonRepeatingChar("abcabc"));
		// System.out.println(longestPrefix(new String[] {"flow","flowight","flower"}));
//		int arr1[] = { 10, 8, 7, 5, 4, 11, 78 };
//		int arr3[] = { -1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4 };
//		Arrays.sort(arr3);
		// System.out.println(threeSum(arr3));
//		recursionBubbleSort(arr1,0,0);
//		System.out.println(Arrays.toString(arr1));
//		List.of(arr);

//		System.out.println(Arrays.toString(mergeTwoSortedArray(new int[] {1,3,5,7,9},new int[] {2,4,6,7,8})));
//		System.out.println(Arrays.toString(selectionSortRecu(new int[] {7,9,4,3,2,1,54,3},0,1,0)));

//		System.out.println(Arrays.toString(insertionSort(new int[] {9,8,6,5,4,3,5})));
		// System.out.println(uniqueOccurance(new int[] {1,1,1,2,2,2,3,4,4,5,4,5}));;
//		System.out.println(reverseKElements(new int[] {1,2,3,4,5,6,7,8,9},2));

		// System.out.println(isArraySortedOrRotated(new int[] {5,6,7,8,1}));
		// System.out.println(Arrays.toString(twoSum2(new int[] {2 ,7,8,5,2,1},9)));
		// System.out.println(longestPrefixs(new String[] {"ab","aba","ad"}));
		// System.out.println(Arrays.toString(removeDuplicatess(new int[]
		// {1,1,2,2,3,4,4,5,55,5})));
		// System.out.println(firstOccurances("hadbadhad","had"));
		// String s[]= {"aaa","aec","adc","ae"};
//		Arrays.sort(s);
//		System.out.println(lastWordLength("hello world jav   "));
		// System.out.println(Arrays.toString(plusOneOptimized(new int[] {9,9,})));
		// System.out.println(isPolindrom("5?6?7?876?5"));
		// System.out.println(reverseWords("A man, a plan, a canal: Panama"));
//		System.out.println(mostOccurrance("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(mostOccurranceInString("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(replaceString("a man is one the street"));
//	System.out.println(replaceAllDigitsWithCharacter("a1b2c3"));
		// System.out.println(removeAllSubstring("aabababa","aba"));
//System.out.println(removeAllDuplicates("aabbccdeffghill"));
		// System.out.println(1%2);
//		char ch[]=new char[] {'a','a','a','b','b','a','a'};
//		int n=countLetters(ch);
//		for(int i=0;i<n;i++) {
//			System.out.print(ch[i]+",");
// 		System.out.println(System.currentTimeMillis());
//		}
//		System.out.println(Arrays.toString(mergeSorted(new int[] {1,2,3,4},3,new int[] {2,5,6},2)));
		// int arr[][] = new int[][] { { 1, 2, 3} ,{ 4, 5, 6} ,{7,8,9}};
//		printWave(arr,2,3);
		// System.out.println(reverseVowels("hello"));
//		printSprial(arr);
//		generateMatrix(5);
//		arr = rotateArray90(arr);
//		for(int i=0;i<arr.length;i++) {
//			for(int j=0;j<arr[0].length;j++)
//				System.out.print(arr[i][j]+" ");
//			System.out.println();
//		}

//		int arr []= {1,2};
		// rotateArrayWithK(arr, 3);
//		int arr[][] = {{1,2,3},{4,5,6},{7,8,9}};  
//		List<List<Integer>> shiftGrid = shiftGrid(arr, 2);
//		for(int i =0 ;i<shiftGrid.size();i++) {
//			System.out.println(shiftGrid.get(i));
//		}

//		System.out.println(maximumSumOfTwoSubStringScore("00111"));
//		System.out.println(convertArrayIn2DArray(new int[] {1,2,3,4,5,5,6,200,200}));
//	System.out.println(missingNumber(new int[] {9,6,4,2,3,5,7,0,1}));	
//		System.out.println(unique(new int[] {1,1,2,2,3,3,9}));
		// System.out.println(Arrays.toString(findErrorNums(new int[] {1,2,2,4})));
		//	kajuKatli(10);
		System.out.println(System.currentTimeMillis());
		System.out.println(minOperations("1000"));
		System.out.println(System.currentTimeMillis());
	}

	public static int minOperations(String s) {
		int count[] = new int[2];
		for(int i=0;i<s.length();i++) {
			count[s.charAt(i)-'0']++;
		}
		if(count[0]>count[1]) {
		return	(count[0]-count[1])/2;
		}
		(count[0]-count[1])/2;
		System.out.println(Arrays.toString(count));
		return 0;
	}
	
	
	public static int[] findErrorNums(int[] arr) {
		Set<Integer> value = new HashSet<>();
		int[] ar = new int[2];
		for (int i = 0; i < arr.length; i++) {
			if (value.contains(arr[i])) {
				ar[0] = arr[i];
				arr[1] = arr[i] + 1;
				System.out.println(arr[i] + 1);
				return ar;
			}
			value.add(arr[i]);
		}
		return ar;
	}

	public static int[] selectionSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			int min = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[j] < arr[min])
					min = j;
			}
			int temp = arr[i];
			arr[i] = arr[min];
			arr[min] = temp;

		}
		return arr;
	}

	public static int[] bubbleSortPr(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}

			}
		}
		return arr;
	}

	public static int unique(int arr[]) {
		int xor = 0;
		for (int i = 0; i < arr.length; i++) {
			xor ^= arr[i];
		}
		return xor;
	}

	public static int xorDuplicate(int arr[]) {

		for (int i = 0; i < arr.length; i++) {

		}
		return 0;
	}

	public static int missingNumber(int arr[]) {
		int max = findMaximum(arr);
		int total = max * (max + 1) / 2, sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return total - sum == 0 ? max + 1 : total - sum;
	}

	public static int countNumber(int arr[], int value) {
		int count = 0;

		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == value)
				count++;
			if (count > 2)
				return count;
		}
		return count;
	}

	public static int uniqueElement(int arr[]) {
		Set<Integer> value = Arrays.stream(arr).boxed().collect(Collectors.toSet());
		Iterator<Integer> iterator = value.iterator();
		while (iterator.hasNext()) {
			int va = iterator.next();
			if (count(arr, va) < 2)
				return va;
		}
		return -1;
	}

	public static int findMaximum(int arr[]) {
		int max = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] > max)
				max = arr[i];
		}
		return max;
	}

	public static List<List<Integer>> convertArrayIn2DArray(int arr[]) {
		// int max = findMaximum(arr);
		int count[] = new int[201];
		for (int i = 0; i < arr.length; i++)
			count[arr[i]]++;
//		System.out.println(Arrays.toString(count));
		int max = findMaximum(count);
		List<List<Integer>> response = new ArrayList<>();
		for (int i = 0; i < max; i++) {
			List<Integer> list = new ArrayList<>();
			for (int j = 0; j < count.length; j++) {
				if (count[j] > 0) {
					list.add(j);
					count[j]--;
				}
			}
			response.add(list);
		}

		return response;
	}

	public static int count(char arr[], int st, int end, char ch) {
		int count = 0;
		while (st <= end) {
			if (arr[st] == ch)
				count++;
			st++;
		}

		return count;
	}

	public static int maximumSumOfTwoSubStringScore(String s) {
		char[] arr = s.toCharArray();
		int i = 0, j = i + 1, max = 0;
		while (i < j && j < arr.length) {
			int cou = count(arr, i, j - 1, '0') + count(arr, j, arr.length - 1, '1');

			if (cou > max)
				max = cou;
			j++;
		}
		return max;
	}

	public static List<List<Integer>> shiftGrid(int arr[][], int k) {
		int row = arr.length, col = arr[0].length, j = row * col - 1, count = 0;
		while (count++ < k) {
			int ele = arr[arr.length - 1][arr[0].length - 1];
			for (j = row * col - 1; j > 0; j--) {
				arr[j / col][j % col] = arr[(j - 1) / col][(j - 1) % col];
			}
			arr[0][0] = ele;

		}
		List<List<Integer>> ar = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			List<Integer> ro = new ArrayList<>();
			for (j = 0; j < arr[0].length; j++) {
				ro.add(arr[i][j]);
			}
			ar.add(ro);

		}
		return ar;
	}

	public static boolean binarySearch2DInSortedRow(int arr[][], int target) {
		int row = 0, col = arr[0].length - 1;

		while (col >= 0 && row <= arr.length - 1) {
			if (arr[row][col] == target)
				return true;
			if (arr[row][col] < target)
				row++;
			else
				col--;
		}
		return false;
	}

	public static boolean binarySearchIn2D(int arr[][], int target) {
		int row = arr.length;
		int col = arr[0].length;
		int st = 0;
		int end = row * col - 1;

		while (st <= end) {
			int mid = st + (end - st) / 2;
			int element = arr[mid / col][mid % col];
			if (element == target)
				return true;
			if (element < target)
				st = mid + 1;
			else
				end = mid - 1;

		}
		return false;

	}

	public static void rotateArrayWithK(int arr[], int k) {
		int arr2[] = new int[arr.length], l = 0;
		int kIndex = arr.length - k;

		if (k >= arr.length) {
			int count = 0;
			while (count++ <= k) {
				int temp = arr[arr.length - 1];
				System.out.println(Arrays.toString(arr));
				for (int j = arr.length - 1; j > 0; j--) {
					arr[j] = arr[j - 1];
				}
				arr[0] = temp;
			}
			return;
		}

		if (kIndex < 0)
			return;
		for (int i = kIndex; i < arr.length; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < kIndex; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < arr.length; i++)
			arr[i] = arr2[i];

	}

	public static int[][] rotateArray90(int arr[][]) {
		int arr3[][] = new int[arr.length][arr[0].length], k = 0;
		for (int col = 0; col < arr[0].length; col++) {
			k = 0;
			for (int row = arr.length - 1; row >= 0; row--) {
				arr3[col][k++] = arr[row][col];
			}

		}
		return arr3;
	}

	public static int[][] generateMatrix(int n) {
		int row = n;
		int col = n;
		int total = n * n;
		int startingCol = 0;
		int startingRow = 0;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int arr[][] = new int[n][n];
		int count = 0;
		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				arr[startingRow][i] = ++count;
			}

			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				arr[i][endingCol] = ++count;
			}

			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				arr[endingRow][i] = ++count;
			}

			endingRow--;

			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				arr[i][startingCol] = ++count;
			}
			startingCol++;

		}
		return arr;
	}

	public static void printSprial(int arr[][]) {
		int startingCol = 0;
		int startingRow = 0;
		int row = arr.length;
		int col = arr[0].length;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int count = 0;
		int total = row * col;

		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				System.out.print(arr[startingRow][i]);
				count++;
			}
			System.out.println();
			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				System.out.print(arr[i][endingCol]);
				count++;
			}

			System.out.println();
			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				System.out.print(arr[endingRow][i]);
				count++;
			}

			endingRow--;
			System.out.println();
			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				System.out.print(arr[i][startingCol]);
				count++;
			}
			startingCol++;
			System.out.println();
		}
	}

	public static boolean isVowel(char ch) {
		ch = Character.toLowerCase(ch);
		if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
			return true;
		return false;
	}

	public static String reverseVowels(String s) {

		char[] arr = s.toCharArray();
		int i = 0, j = arr.length - 1;
		while (i < j) {
			if (isVowel(arr[i]) && isVowel(arr[j])) {
				char t = arr[i];
				arr[i] = arr[j];
				arr[j] = t;
				i++;
				j--;
			} else if (isVowel(arr[i]))
				j--;
			else
				i++;
		}
		return new String(arr);
	}

	public static void printWave(int arr[][], int row, int col) {
		for (int j = 0; j < col; j++) {

			for (int i = 0; i < row; i++) {
				System.out.print(arr[i][j]);
			}

			System.out.println();
			j++;
			for (int i = row - 1; i >= 0 && j < col; i--) {
				System.out.print(arr[i][j]);
			}
			System.out.println();

		}
	}

	public static int[] mergeSorted(int arr[], int m, int arr1[], int n) {
		int arr3[] = new int[m + n], i = 0, j = 0, k = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j] && n > 0) {
				arr3[k++] = arr1[j++];
				n--;
			} else if (m > 0) {
				arr3[k++] = arr[i++];
				m--;
			} else
				break;

		}
		System.out.println(Arrays.toString(arr3));
		while (m > 0 && i < arr.length) {
			arr3[k++] = arr[i++];
			m--;
		}
		while (n > 0 && j < arr1.length) {
			arr3[k++] = arr1[j++];
			n--;
		}
		return arr3;
	}

	public static List<Foodsystem> system = new ArrayList<>();

	public void enterData() {
		String food[] = { "kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi" };
		String country[] = { "korean", "japanese", "japanese", "greek", "japanese", "korean" };
		int arr[] = { 9, 12, 8, 15, 14, 7 };
		for (int i = 0; i < country.length; i++) {
			Map<String, Integer> fs = new LinkedHashMap<>();
			Foodsystem s = new Foodsystem();
			s.count = country[i];
			s.food.put(food[i], arr[i]);
			this.add(s);
		}
		System.out.println(system);

	}

	public void add(Foodsystem o) {
		for (int i = 0; i < this.system.size(); i++) {
			if (system.get(i).count.equals(o.count)) {
				system.get(i).food.putAll(o.food);
				return;
			}

		}
		this.system.add(o);
	}

	public void changeRating(String food, int rating) {
		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem f = system.get(i);
			if (f.food.containsKey(food)) {
				f.food.put(food, rating);
				return;
			}

		}

	}

	public String highestRating(String country) {
		String city = "";

		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem s = system.get(i);
			if (s.count.equals(country)) {
				int max = 0;
				Set<Entry<String, Integer>> entrySet = s.food.entrySet();
				System.out.println(entrySet);
				for (Entry<String, Integer> e : entrySet) {
					if (e.getValue() > max) {
						max = e.getValue();
						city = e.getKey();

					}
					if (e.getValue() == max) {
						s.food.put(e.getKey(), e.getValue());
					}
				}
			}

		}

		return city;
	}

	public static int countLetters(char[] s) {
		int k = 0;
		for (int i = 0; i < s.length;) {
			char ch = s[i];
			int j = i + 1, count = 1;

			while (j < s.length && s[j] == ch) {
				count++;
				j++;
			}
			System.out.println(ch + " " + count + " " + j);
			if (count > 1) {
				s[k++] = ch;
				for (char c : Integer.toString(count).toCharArray()) {
					if (k < s.length)
						s[k++] = c;
					else
						return k;
				}
			} else {
				s[k++] = ch;
			}
			i = j;
		}
		return k;
	}

	public static String removeAllDuplicates(String s) {
		StringBuilder sb = new StringBuilder();
		int count[] = new int[26];
		for (int i = 0; i < s.length(); i++) {
			int num = s.charAt(i) - 'a';
			count[num]++;
		}

		for (int i = 0; i < s.length(); i++) {
			if (count[(s.charAt(i) - 'a')] < 2)
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static String removeAllSubstring(String s, String part) {
		while (s.length() != 0 && s.contains(part))
			s = s.replaceFirst(part, "");

		return s;
	}

	public static String replaceAllDigitsWithCharacter(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
				sb.append((char) (s.charAt(i - 1) + (s.charAt(i) - 48)));
			else
				sb.append(s.charAt(i));
		}
		return sb.toString();

	}

	public static String replaceString(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == ' ')
				sb.append("@40");
			else
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static char mostOccurranceInString(String s) {
		int arr[] = new int[26]; // storing occurance of every letter according to index
		s = s.toLowerCase();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
				int num = s.charAt(i) - 'a';
				arr[num]++;
			}
		}

		// finding max
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < arr.length; i++) {
			if (max < arr[i]) {
				max = arr[i];
				ch = (char) i;
			}

		}
		return (char) (ch + 'a');

	}

	// brute force
	public static char mostOccurrance(String s) {
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < s.length(); i++) {
			int count = 0;
			for (int j = i + 1; j < s.length(); j++) {
				if (s.charAt(i) == s.charAt(j) && s.charAt(i) != ' ')
					count++;
			}

			if (count > max) {
				ch = s.charAt(i);
				max = count;
			}
		}
		return ch;
	}

	public static int climbStairs(int n) {

		if (n < 0)
			return 0;
		if (n == 0)
			return 1;
		return climbStairs(n - 1) + climbStairs(n - 2);
	}

	public static void reverseString(char[] ch, int st, int end) {

		while (st < end) {
			char temp = ch[st];
			ch[st] = ch[end];
			ch[end] = temp;
			st++;
			end--;
		}

	}

	public static char[] reverseWords(String s) {
		char ch[] = s.toCharArray();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ' && s.charAt(i) != ',') {
				int j = i + 1;
				for (; j < s.length(); j++) {
					if (s.charAt(j) == ' ' || s.charAt(j) == ',')
						break;
				}
				reverseString(ch, i, j - 1);
				i = j;
			}
		}
		return ch;
	}

	public static boolean isAlphaNumeric(char c) {
		if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9')
			return true;
		return false;
	}

	public static boolean isPolinromValidAlgo(String s) {
		StringBuilder b = new StringBuilder();
		// remove special characters only left alphanumeric
		for (int i = 0; i < s.length(); i++) {
			if (isAlphaNumeric(s.charAt(i)))
				b.append(s.charAt(i));

		}

		// to lower case
		String str = b.toString().toLowerCase();
		int st = 0, end = str.length() - 1;
		while (st < end) {
			if (str.charAt(st) != str.charAt(end))
				return false;
			st++;
			end--;
		}
		return true;

	}

	public static boolean isPolindrom(String s) {
		int st = 0, end = s.length() - 1;
		while (st < end) {
			if (s.charAt(st) >= '0' && s.charAt(st) <= '9') {
				if (s.charAt(end) >= '0' && s.charAt(end) <= '9') {

					if (s.charAt(st) != s.charAt(end))
						return false;
					else {
						st++;
						end--;
					}
				} else
					end--;
			} else
				st++;
		}
		return true;
	}

	// optimized
	public static int[] plusOneOptimized(int arr[]) {
		for (int i = arr.length - 1; i >= 0; i--) {
			if (arr[i] < 9) {
				arr[i]++;
				return arr;
			}
			arr[i] = 0;
		}
		arr = new int[arr.length + 1];
		arr[0] = 1;
		return arr;
	}

	// brute force
	public static int[] plusOne(int arr[]) {
		if (arr.length < 1)
			return arr;
		int carry = 1;
		for (int i = arr.length - 1; i >= 0; i--) {
			arr[i] = arr[i] + carry;
			carry = 0;
			if (arr[i] > 9) {
				arr[i] = 0;
				carry = 1;
			} else
				break;
		}

		if (carry != 0) {
			int ar[] = new int[arr.length + 1];
			ar[0] = carry;
			for (int i = 1; i < ar.length - 1; i++)
				ar[i] = arr[i];
			return ar;
		}
		return arr;
	}

	public static int countLastWordLength(String s, int index) {
		int count = 0;
		for (; index >= 0; index--) {
			if (s.charAt(index) != ' ')
				count++;
			else
				break;
		}
		return count;
	}

	public static int lastWordLength(String s) {
		for (int i = s.length() - 1; i >= 0; i--) {
			if (s.charAt(i) != ' ')
				return countLastWordLength(s, i);
		}
		return 0;
	}

	public static int firstOccurances(String s, String value) {
		if (s.contains(value)) {
			return s.indexOf(value);
		}
		return -1;
	}

	public static boolean isMatched(String s, String value) {
		if (s.length() < value.length())
			return false;
		for (int i = 0; i < value.length(); i++) {
			if (s.charAt(i) != value.charAt(i))
				return false;
		}
		return true;
	}

	public static int firstOccurance(String s, String value) {
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == value.charAt(0)) {
				if (isMatched(s.substring(i), value))
					return i;
			}
		}
		return -1;
	}

	public static int[] removeDuplicatess(int arr[]) {
		int i = 0, j = 1;
		for (i = 1; i < arr.length; i++) {
			if (arr[i - 1] != arr[i])
				arr[j++] = arr[i];
		}
		return arr;
	}

	public static int[] removeDuplicates(int arr[]) {
		Set<Integer> set = new LinkedHashSet<>();
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		return set.stream().mapToInt(i -> i).toArray();

	}

	public static String longestPrefixs(String arr[]) {
		Arrays.sort(arr);
		StringBuilder b = new StringBuilder();
		String first = arr[0];
		String last = arr[arr.length - 1];
		for (int i = 0; i < Math.min(first.length(), last.length()); i++) {
			if (first.charAt(i) != last.charAt(i))
				return b.toString();
			b.append(first.charAt(i));
		}
		return b.toString();

	}

	public static int[] twoSum2(int[] arr, int target) {
		int f = 0, l = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 1; j < arr.length; j++) {
				if (arr[i] + arr[j] == target) {
					f = i;
					l = j;
				}
			}
		}
		return new int[] { f, l };
	}

	public static Boolean arraySortedOrRotated(int arr[]) {
		int count = 0;
		for (int i = 1; i < arr.length; i++) {
			if (arr[i - 1] > arr[i])
				count++;
		}
		if (arr[0] < arr[arr.length - 1])
			count++;

		return count == 1;
	}

	// brute force
	public static Boolean isArraySortedOrRotated(int arr[]) {
		int i = 0;
		for (i = 0; i < arr.length - 1; i++) {
			if (arr[i] > arr[i + 1])
				break;

		}
		System.out.println(i + " -<");
		i++;
		for (; i < arr.length - 1; i++) {
			System.out.println("->" + i);
			if (arr[0] < arr[i] || arr[i] > arr[i + 1])
				return false;
		}
		if (i < arr.length && arr[0] < arr[i])
			return false;
		return true;
	}

	public static int findUnique(int arr[]) {
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {

			ans = ans ^ arr[i];
		}
		return ans;
	}

	public static int count(int arr[], int value) {
		int count = 0;
		for (int i = 0; i < arr.length; i++) {
			if (value == arr[i])
				count++;
		}
		return count;

	}

	public static int uniqueOccurance(int arr[]) {
		int arr1[] = new int[arr.length], k = 0;
		for (int i = 0; i < arr.length; i++) {
			if (!isPreExists(arr[i], arr, i - 1)) {

				int count = count(arr, arr[i]);
				arr1[k++] = count;
				System.out.println("count " + count);
			}
		}
		return findUniqueElement(arr1);
	}

	public static int[] reverse(int arr[], int st, int end) {
		if (end < arr.length)
			while (st < end) {
				int k = arr[st];
				arr[st++] = arr[end];
				arr[end--] = k;
			}
		return arr;
	}

	public static int[] reverseKElements(int arr[], int k) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length; i += k) {

			reverse(arr, i, i + k - 1);
		}
		System.out.println(Arrays.toString(arr));
		return arr;

	}

	public static boolean isPreExists(int value, int arr[], int k) {
		for (int i = k; i >= 0; i--) {
			if (arr[i] == value)
				return true;
		}
		return false;
	}

	public static int findUniqueElement(int arr[]) {
		System.out.println(Arrays.toString(arr));
		for (int i = 0; i < arr.length; i++) {
			int count = 0;
			if (!isPreExists(arr[i], arr, i - 1))
				for (int j = i; j < arr.length; j++) {

					if (arr[i] == arr[j])
						count++;
				}

			if (count == 1) {
				System.out.println("found " + arr[i]);

				return arr[i];
			}
		}
		return 0;
	}

	public static int[] insertionSort(int arr[]) {
		int j = 0;
		for (int i = 0; i < arr.length; i++) {
			int k = arr[i];
			for (j = i - 1; j >= 0; j--) {
				if (arr[j] < k) {
					arr[j + 1] = arr[j];
				} else
					break;
			}
			arr[j + 1] = k;
		}
		return arr;
	}

	public static int[] selectionSortRecu(int arr[], int i, int j, int min) {
		if (i >= arr.length)
			return arr;
		if (j < arr.length) {
			if (arr[min] > arr[j])
				min = j;
			return selectionSortRecu(arr, i, j + 1, min);
		}
		int k = arr[i];
		arr[i] = arr[min];
		arr[min] = k;
		return selectionSortRecu(arr, i + 1, i + 2, i + 1);
	}

	public static int[] mergeTwoSortedArray(int arr[], int arr1[]) {
		int arr3[] = new int[arr.length + arr1.length], k = 0, i = 0, j = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j]) {
				arr3[k++] = arr1[j++];

			} else {
				arr3[k++] = arr[i++];

			}
		}

		while (i < arr.length) {
			arr3[k++] = arr[i++];
		}
		while (j < arr1.length) {
			arr3[k++] = arr1[i++];
		}
		return arr3;
	}

	public static void recursionBubbleSort(int arr[], int i, int j) {
		if (i == arr.length)
			return;
		if (j < arr.length - i - 1 && arr[j] > arr[j + 1]) {

			int k = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = k;
			System.out.println(Arrays.toString(arr));
			recursionBubbleSort(arr, i, j + 1);

		} else {
			System.out.println("----- " + Arrays.toString(arr));
			recursionBubbleSort(arr, i + 1, 0);
		}

	}

	public static void bubbleSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int k = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = k;
				}

			}
		}
	}

	public static List<List<Integer>> threeSum(int arr[]) {
		int i = 0, j = 0, k = arr.length - 1;
		Set<List<Integer>> output = new HashSet<>();
		for (i = 0; i < arr.length; i++) {
			j = i + 1;
			k = arr.length - 1;
			while (j < k) {
				System.out.println(arr[i] + "->" + arr[j] + "->" + arr[k] + "=> " + (arr[i] + arr[j] + arr[k]) + " ( "
						+ i + "," + j + "," + k);
				if (arr[i] + arr[j] + arr[k] == 0) {
					List<Integer> list = new ArrayList<>();
					list.add(arr[i]);
					list.add(arr[j]);

					list.add(arr[k]);
					output.add(list);
				} else if (arr[i] + arr[j] + arr[k] > 0) {
					k--;
					j--;
				}
				j++;

			}
		}

		return output.stream().toList();

	}

	public static String longestPrefix(String s[]) {

		String prefix = "";

		for (int i = 0; i < s.length; i++) {
			for (int j = i + 1; j < s.length; j++) {
				if (s[i].length() > s[j].length()) {
					String temp = s[i];
					s[i] = s[j];
					s[j] = temp;
				}
			}
		}

		String st = s[0];
		boolean isMatched = false;
		for (int j = 0; j < st.length(); j++) {
			char ch = st.charAt(j);

			for (int k = 1; k < s.length; k++) {
				isMatched = false;

				if (ch == s[k].charAt(j)) {
					isMatched = true;
				} else
					break;
			}
			if (isMatched)
				prefix += ch;
			else
				break;

		}
		;
		return prefix;

	}

	public static String nonRepeatingChar(String s) {
		for (int i = 0; i < s.length(); i++) {
			boolean isPresent = false;
			for (int j = 0; j < s.length(); j++) {
				if (i != j && s.charAt(i) == s.charAt(j)) {
					isPresent = true;
					break;
				}
			}
			if (!isPresent) {
				return s.charAt(i) + "";
			}
		}
		return "All Are repated";
	}

	public static Integer romanToInteger(String s) {
		int num = 0;
		Map<String, Integer> romans = new HashMap<>();
		romans.put("M", 1000);
		romans.put("CM", 900);
		romans.put("D", 500);
		romans.put("CD", 400);
		romans.put("C", 100);
		romans.put("XC", 90);
		romans.put("L", 50);
		romans.put("XL", 40);
		romans.put("X", 10);
		romans.put("IX", 9);
		romans.put("V", 5);
		romans.put("IV", 4);
		romans.put("I", 1);
//System.out.println(romans.get("M"));
		if (s.length() < 2)
			return romans.get(s.charAt(0) + "");
		for (int i = 0; i < s.length() - 1; i++) {

			if (romans.get(s.charAt(i) + "").intValue() >= romans.get(s.charAt(i + 1) + "").intValue()) {
				num += romans.get(s.charAt(i) + "");
				System.out.println("num -> " + num);
			} else {

				int sum = romans.get(s.charAt(i + 1) + "") - romans.get(s.charAt(i) + "");
				System.out.println("num    => " + num + "  sum => " + sum);
				num += sum;
				i++;
				System.out.println("--------- " + num);
			}
			if (i == s.length() - 2)
				if (romans.get(s.charAt(i + 1) + "").intValue() <= romans.get(s.charAt(i) + "").intValue()) {
					num += romans.get(s.charAt(i + 1) + "");

				}
		}
		return num;
	}

	public static String integerToRoman(int num) {
		Integer number[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
		String romans[] = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };
		String result = "";
		for (int i = 0; i < number.length; i++) {

			while (num >= number[i]) {
				num -= number[i];
				result += romans[i];
			}
		}
		return result;

	}

	public static int convertToInteger(String s) {
		String st = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {
				st += s.charAt(i);
			} else if (s.charAt(i) == '-')
				st += s.charAt(i);
		}
		System.out.println(Integer.parseInt(st));
		return 0;
	}

	public static int reverserInteger(int n) {
		int rev = 0;
		while (n != 0) {
			int r = n % 10;
			n /= 10;
			rev = rev * 10 + r;
		}
		System.out.println(rev);
		return 0;
	}

	public static int[] mergeSortedArrays(int a1[], int a2[]) {
		int a3[] = new int[a1.length + a2.length], j = 0, k = 0, i = 0;

		Stack<Character> stack = new Stack();
		String s = "a";
		Character c = s.charAt(i);
		System.out.println(c.equals(c));

		while (i < a1.length && j < a2.length) {

			if (a1[i] >= a2[j])
				a3[k++] = a2[j++];
			else
				a3[k++] = a1[i++];

		}
		while (i < a1.length)
			a3[k++] = a1[i++];

		while (j < a2.length)
			a3[k++] = a2[j++];

		return a3;

	}

	public static int[] insertInSortedArray(int arr[], int value) {
		int temp[] = new int[arr.length + 1], j = 0;
		boolean isInserted = false;
		for (int i = 0; i < arr.length; i++) {

			if (!isInserted && arr[i] > value) {
				temp[j++] = value;
				isInserted = true;
			}
			temp[j++] = arr[i];
		}
		if (!isInserted)
			temp[j++] = value;
		return temp;
	}

	public static int[] inserAtNthPos(int arr[], int value, int pos) {
		int j = 0;
		int temp[] = new int[arr.length + 1];
		if (pos < 1)
			return arr;

		for (int i = 0; i < arr.length; i++) {
			if (i == pos - 1)
				temp[j++] = value;

			temp[j++] = arr[i];
		}
		if (pos > arr.length) {
			temp[j++] = value;
		}

//	for(int i=0;i<temp.length;i++)
//		arr[i]=temp[i];
		return temp;
	}

	public static void righRotation(int arr[], int num) {
		int n = arr.length, temp = 0, count = 0;
		while (count++ < num) {
			temp = arr[n - 1];
			for (int i = n - 1; i > 0; i--)
				arr[i] = arr[i - 1];
			arr[0] = temp;
		}

	}

	public static void leftRotation(int arr[], int num) {
		int temp[] = new int[arr.length], n = arr.length, j = 0;

		for (int i = num; i < n; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < num; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < n; i++)
			arr[i] = temp[i];
	}

	public static char[] copyArray(char[] arr) {
		if (arr == null)
			return new char[1];

		char[] a = Arrays.copyOf(arr, arr.length + 1);
		return a;
	}

	public static String zigzapConversion(String s, int num) {
		char[][] arr = new char[num][];
		int k = 0, i = 0, j = 0, t = 0;
		while (k < s.length()) {
			while (i != num - 1) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i++;
			}
			j++;
			while (i != 0) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i--;
			}
			j++;

		}
		for (char[] a : arr) {
			for (char tt : a)
				System.out.print(tt);
			System.out.println();
		}
		return "";
	}

	public static String longestPolindromSubtString(String s) {
		String ans = "";
		if (s.length() < 1)
			return s;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - 1; j >= 0; j--) {
				if (i < j) {
					String sub = s.substring(i, j + 1);
					if (sub.equals(new StringBuilder(sub).reverse().toString())) {
						if (sub.length() > ans.length()) {
							ans = sub;
						}

					}
				}
			}
		}

		return ans;
	}

	public static double medianOfTwoSortedArray(int[] arr1, int[] arr2) {

		int arr3[] = new int[arr1.length + arr2.length], i = 0, j = 0, k = 0;
		while (true) {
			if (i < arr1.length) {
				arr3[k++] = arr1[i++];
			} else if (j < arr2.length) {
				arr3[k++] = arr2[j++];
			} else
				break;

		}
		double ans = 0;
		Arrays.sort(arr3);
		System.out.println(Arrays.toString(arr3));
		if (arr3.length % 2 == 0) {
			int mid = arr3.length / 2;
			ans = (double) (arr3[mid - 1] + arr3[mid]) / 2;
			System.out.println(arr3[mid - 1]);
		} else {
			ans = arr3[arr3.length / 2];
		}

		return ans;
	}
// 4
// 1,1,1,1
// 2,1,1
// 1,1,2
// 2,2

	public static int[] twoSum(int arr[], int target) {
		int f = 0, sec = 0;
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {
				if (arr[i] + arr[j] == target && i != j) {

					f = i;
					sec = j;
				}
			}

		}
		System.out.println(f + " " + sec);
		return new int[] { f, sec };
	}

	public static char[] stringToArrayOfCharacters(String s) {
		char arr[] = new char[s.length()];
		for (int i = 0; i < s.length(); i++) {
			arr[i] = s.charAt(i);
		}
		return arr;
	}

	public static String[] textToWordsArray(String text) {
		List<String> words = new ArrayList<>();
		for (int i = 0; i < text.length(); i++) {

			for (int j = i; j < text.length() - 1; j++) {
				if (i > 0 && text.charAt(i) == ' ' && text.charAt(j + 1) == ' ' && text.charAt(i - 1) != ' ') {
					words.add(text.substring(i + 1, j + 1));
					break;
				} else if (i == 0 && text.charAt(j + 1) == ' ') {
					words.add(text.substring(i, j + 1));
					break;
				} else if (text.charAt(i) == ' ' && j + 1 == text.length() - 1) {
					words.add(text.substring(i + 1, text.length()));
					break;
				}
			}

		}
		String s[] = new String[words.size()];
		int i = 0;
		ListIterator<String> listIterator = words.listIterator();
		while (listIterator.hasNext()) {
			s[i++] = listIterator.next();
		}
		return s;
	}

	public static int wordCount(String s) {
		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0)
				count++;
			else if (s.charAt(i) == ' ')
				for (int j = i; j < s.length() - 1; j++) {
					if (s.charAt(j + 1) == ' ' && s.charAt(i - 1) != ' ') {
						count++;
						System.out.print(s.charAt(i) + " - > " + s.charAt(j) + " = " + count);
						break;
					}
				}
		}
		return count + 1;

	}

	public static void uniqueFromArrays(int arr[], int arr2[]) {

		List<Integer> list1 = List.of(1, 2, 4);
		List<Integer> list2 = List.of(1, 2, 3, 5);
		List<Integer> unique = new ArrayList<>();
		unique.addAll(list1);
		unique.addAll(list2);
		unique = unique.stream().distinct()
				.filter(a -> list1.contains(a) && !list2.contains(a) || !list1.contains(a) && list2.contains(a))
				.collect(Collectors.toList());
		System.out.println(unique);

		int k = 0;
		for (int i = 0; i < arr.length || k < arr2.length; i++, k++) {
			boolean a = false;
			boolean b = false;
			if (i < arr.length)
				for (int j = 0; j < arr2.length; j++) {
					if (arr[i] == arr2[j])
						a = true;
				}
			for (int j = 0; j < arr.length; j++) {
				if (arr2[k] == arr[j])
					b = true;
			}
			if (!a && i < arr.length)
				System.out.println(arr[i]);
			if (!b)
				System.out.println(arr2[k]);
		}
	}

	public static void arraySum(int arr[], int arr2[]) {
		int carry = 0, total = 0, j = 0, k = arr2.length - 1, i;
		List<Integer> sum = new ArrayList<>();

		for (i = arr.length - 1; i >= 0 && k >= 0; i--, k--) {

			total = arr[i] + arr2[k] + carry;
			carry = 0;
			if (total > 9) {
				carry = total % 10;
				total /= 10;
			}
			sum.add(total);

		}

		if (i < 0 && k >= 0) {
			for (int a = k; a >= 0; a--)
				sum.add(arr2[a]);
		}
		if (k < 0 && i >= 0) {
			for (int a = i; a >= 0; a--)
				sum.add(arr[a]);
		}
		Collections.reverse(sum);
		System.out.println(sum);
	}

	public static void arrayRightRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[arr.length - 1];
			for (j = arr.length - 1; j > 0; j--) {
				arr[j] = arr[j - 1];
			}
			count++;
			arr[0] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static void arrayLeftRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[0];
			for (j = 0; j < arr.length - 1; j++) {
				arr[j] = arr[j + 1];
			}
			count++;
			arr[j] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static boolean anagram(String s, String s1) {

		int count = 0;
		boolean b = false;
		for (int i = 0; i < s.length(); i++) {
			char ch = s.charAt(i);
			count = 0;
			b = false;
			for (int k = 0; k < s.length(); k++) {
				if (ch == s.charAt(k))
					count++;
			}

			for (int j = 0; j < s1.length(); j++) {
				if (count > 0 && ch == s1.charAt(j))
					count--;
			}
			if (count == 0)
				b = true;
		}

		System.out.println(b ? "yes" : "no");
		return b;
	}

	public static int count(int i, int arr[]) {
		int count = 0;
		for (int a : arr) {
			if (a == i)
				count++;
		}
		System.out.println(count);
		return count;
	}

	public static void majorityElement(int arr[]) {
		int max = 0, count = 0;
		for (int i = 0; i < arr.length; i++) {
			count = count(arr[i], arr);
			if (count >= max && count > arr.length / 2)
				max = arr[i];

		}
		System.out.println(max);
	}

	public static void longestPolindrom(String s) {

		int first = 0, last = s.length() - 1, max = 0;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - i; j >= 0; j--) {
				if (i < j && j < s.length())
					if (checkPolindrom(i, j + 1, s) && max < s.substring(i, j).length()) {

						max = s.substring(i, j + 1).length();
						first = i;
						last = j + 1;
					}
			}
			System.out.println("------");

		}
		System.out.println(s.substring(first, last));

	}

	public static boolean checkPolindrom(int f, int l, String s) {
		String st = s.substring(f, l);
		System.out.println(st + "444");
		return st.equals(new StringBuffer(st).reverse().toString());

	}

	public void spiralMatrix() throws ClassNotFoundException, NoSuchMethodException, SecurityException,
			InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		int a[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };
		int j = 0, k = 0, count = 0, max = 10 - 1;
		// int max=a.length*a.length-1;
		// System.out.println(a.length);

		for (int i = 0; i < a.length - i; i++) {

			if (count == max)
				break;

			for (j = i; j < a.length - i && count <= max; j++) {
				count++;
				System.out.println(a[k][j]);
			}
			j--;

			k++;
			while (k < a.length - i && count <= max) {
				System.out.println(a[k][j]);
				k++;
				count++;
			}
			k--;
			j--;

			while (j >= 0 && count <= max) {
				count++;
				System.out.println(a[k][j--]);
			}

			// k=i+1;
			if (k == a.length / 2 && j == a.length / 2)
				break;
			j++;
			while (k > i + 1 && count <= max) {
				System.out.println(a[--k][j]);
				count++;
			}

			k = i + 1;
			System.out.println("-----------------");
		}

	}

	public static ArrayList<Integer> findIndexes(int arr[], int sum) {
		boolean a = false;
		int f = 0, l = arr.length, s = 0;
		for (int i = 0; i < arr.length; i++) {
			s = 0;
			if (a)
				break;

			for (int j = i; j < arr.length; j++) {
				s += arr[j];
				if (s == sum) {
					f = i;
					l = j;
					a = true;
					break;
				}

			}
			System.out.println(s);
		}

		return a ? new ArrayList<Integer>(Arrays.asList(f, l)) : new ArrayList<Integer>(Arrays.asList(-1));
	}

	public int count(char a, String s) {
		class A {
			static int a;

			public void main() {
				System.out.println("hello");
			}
		}

		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == a)
				count++;
		}
		return count;
	}

	public static boolean isPresent(char a, int indx, String s) {
		for (int i = indx; i >= 0; i--) {
			if (s.charAt(i) == a)
				return true;
		}
		return false;
	}

	public static boolean isPresent(int a, int indx, int ar[]) {
		for (int i = indx; i >= 0; i--) {
			if (ar[i] == a)
				return true;
		}
		return false;
	}

	public static void fibonacci(int t1, int t2, int n) {
		if (n == 0)
			return;
		else {
			int t3 = t1 + t2;
			t1 = t2;
			t2 = t3;
			System.out.println(t3);
			fibonacci(t1, t2, n - 1);
		}

	}

	public static int factorial(int n) {
		if (n == 1)
			return 1;
		else
			n = n * factorial(n - 1);
		return n;

	}

	public static String removeSpaces(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ')
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static int[] removeDuplicate(int[] a) {
		int arr[] = new int[a.length];
		int j = 0;
		for (int i = 0; i < a.length; i++) {
			if (!isPresent(a[i], i - 1, a))
				arr[j++] = a[i];
		}
		a = new int[j];
		System.out.println(j);
		for (int i = 0; i < j; i++)
			a[i] = arr[i];
		return a;
	}

	class C {
		static int a;
	}
}

class B {
	int a = 10;

	public String toString() {
		System.out.println("askfjal");
		return new String(this.a + "");
	}

	public void hello(int... a) {

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-12-24 23:21:06.561
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-12-24 23:21:06.563
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-12-24 23:21:08.272
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.pract;

import java.lang.reflect.InvocationTargetException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.springframework.jdbc.core.metadata.OracleCallMetaDataProvider;

interface DD {

}

class AB implements Comparable<AB> {
	int id = 0;
	String name = "rohit";

	@Override
	public int compareTo(AB o) {
		if (this.id < o.id)
			return 1;

		return -1;
	}

	@Override
	public String toString() {
		return "AB [id=" + id + ", name=" + name + "]";
	}

}

abstract class kd {

}

class Foodsystem {
	public String count;
	public Map<String, Integer> food = new LinkedHashMap<>();

	public String toString() {
		return count + " =" + food;
	}

}

public class Test {

	public Test(int a) {

	}

	public static void main(String[] args) throws Exception {
		// fibonacci(0,1,20);
		// Class<?> clas = Class.forName("com.pract.Test");

		// Constructor<?> to = clas.getConstructor(int.class);
		// Test t = (Test) to.newInstance();
		var a = new Test(8);

		// System.out.println(Integer.toBinaryString(2));

		// new Random().ints(1,999).limit(20).sorted().forEach(System.out::println);
		// List<Integer> list = List.of(1,2,3,4,5);
		// System.out.println(list.stream().mapToInt(v->v).max().getAsInt());
		// list.stream().max(Integer::compare);

//		
//		longestPolindrom("bcac");
//	
//	majorityElement(new  int []{1,2,3,4,5,5});
//		
//	anagram("abcda","bcdaa");
//	String sp="TEST@$QWES 89";
//	sp = sp.replaceAll("\\d+","");
//	System.out.println(sp);

//arrayLeftRotation(new int[] {1,2,3,4,5},4);
//arrayRightRotation(new int[] {1,2,3,4,5},2);
//arraySum(new int[] {1,2,3,4},new int[] {1,2,3});
//uniqueFromArrays(new int[] {1,2,4},new int[] {1,2,3,5});
//wordCount("Hello what are you doing here you fucking bitch bastard");
//String s[]=textToWordsArray("Hello what are you doing here you fucking bitch bastard ab bcd");

//char arr[]=stringToArrayOfCharacters("hello what");

//twoSum(new int[] {2,7,11,15},9);
//		System.out.println(medianOfTwoSortedArray(new int[] {3},new int[] {-2,-1}));
//		System.out.println(longestPolindromSubtString("cbbd"));
		// zigzapConversion("PAYPALISHIRING",4);
//		Date d = new Date();
//		SimpleDateFormat f = new SimpleDateFormat("dd/MM/yyyy");
//		Date parse = f.parse("12/9/2023");
//		//LocalDate.now().
//		LocalDate l = LocalDate.now();
//		LocalDate l2 = LocalDate.of(2024, 10, 11);
//		Period period = Period.between(l, l2);
//		period.between(l, l2);
//		DayOfWeek dayOfWeek = l2.getDayOfWeek();
//		System.out.println(dayOfWeek.toString());

//		int arr[] = new int[] { 1, 2, 4 };
//		int arr2[] = new int[] { 1, 3, 4 };
		// righRotation(arr, 2);
//inserAtNthPos(arr,3,3);

//arr=insertInSortedArray(arr,6);
//System.out.println(2%5);
//arr=mergeSortedArrays(arr,arr2);
//System.out.println(Arrays.toString(arr))
		// reverserInteger(-1234);
//convertToInteger("  -1234");

		// AB.main(new String[] {"a","b"});
		// AB ab = new AB();
//		ab.hello();
//Comparator<Integer> com = new Comparator<Integer>() {
//
//	@Override
//	public int compare(Integer o1, Integer o2) {
//	   
//		return o1.intValue()>o2.intValue()?o2:o1;
//	}
//	
//};
//com = (c,b) -> c<b?1:-1;
//
//TreeSet<AB>  t = new TreeSet<>(); 
//		AB a1 = new AB();
//		a1.id=10;
//		AB a2 = new AB();
//		a2.id=20;
//		AB a3 = new AB();
//		a3.id=30;
//		AB a4 = new AB();
//		a4.id=40;
//		AB a5 = new AB();
//		a5.id=50;
//		
//		t.add(a1);
//		t.add(a2);
//		t.add(a3);
//		t.add(a4);
//		t.add(a5);
//		System.out.println(t);
		// System.out.println(integerToRoman(400));
		// System.out.println(romanToInteger("D"));
		// System.out.println(nonRepeatingChar("abcabc"));
		// System.out.println(longestPrefix(new String[] {"flow","flowight","flower"}));
//		int arr1[] = { 10, 8, 7, 5, 4, 11, 78 };
//		int arr3[] = { -1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4 };
//		Arrays.sort(arr3);
		// System.out.println(threeSum(arr3));
//		recursionBubbleSort(arr1,0,0);
//		System.out.println(Arrays.toString(arr1));
//		List.of(arr);

//		System.out.println(Arrays.toString(mergeTwoSortedArray(new int[] {1,3,5,7,9},new int[] {2,4,6,7,8})));
//		System.out.println(Arrays.toString(selectionSortRecu(new int[] {7,9,4,3,2,1,54,3},0,1,0)));

//		System.out.println(Arrays.toString(insertionSort(new int[] {9,8,6,5,4,3,5})));
		// System.out.println(uniqueOccurance(new int[] {1,1,1,2,2,2,3,4,4,5,4,5}));;
//		System.out.println(reverseKElements(new int[] {1,2,3,4,5,6,7,8,9},2));

		// System.out.println(isArraySortedOrRotated(new int[] {5,6,7,8,1}));
		// System.out.println(Arrays.toString(twoSum2(new int[] {2 ,7,8,5,2,1},9)));
		// System.out.println(longestPrefixs(new String[] {"ab","aba","ad"}));
		// System.out.println(Arrays.toString(removeDuplicatess(new int[]
		// {1,1,2,2,3,4,4,5,55,5})));
		// System.out.println(firstOccurances("hadbadhad","had"));
		// String s[]= {"aaa","aec","adc","ae"};
//		Arrays.sort(s);
//		System.out.println(lastWordLength("hello world jav   "));
		// System.out.println(Arrays.toString(plusOneOptimized(new int[] {9,9,})));
		// System.out.println(isPolindrom("5?6?7?876?5"));
		// System.out.println(reverseWords("A man, a plan, a canal: Panama"));
//		System.out.println(mostOccurrance("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(mostOccurranceInString("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(replaceString("a man is one the street"));
//	System.out.println(replaceAllDigitsWithCharacter("a1b2c3"));
		// System.out.println(removeAllSubstring("aabababa","aba"));
//System.out.println(removeAllDuplicates("aabbccdeffghill"));
		// System.out.println(1%2);
//		char ch[]=new char[] {'a','a','a','b','b','a','a'};
//		int n=countLetters(ch);
//		for(int i=0;i<n;i++) {
//			System.out.print(ch[i]+",");
// 		System.out.println(System.currentTimeMillis());
//		}
//		System.out.println(Arrays.toString(mergeSorted(new int[] {1,2,3,4},3,new int[] {2,5,6},2)));
		// int arr[][] = new int[][] { { 1, 2, 3} ,{ 4, 5, 6} ,{7,8,9}};
//		printWave(arr,2,3);
		// System.out.println(reverseVowels("hello"));
//		printSprial(arr);
//		generateMatrix(5);
//		arr = rotateArray90(arr);
//		for(int i=0;i<arr.length;i++) {
//			for(int j=0;j<arr[0].length;j++)
//				System.out.print(arr[i][j]+" ");
//			System.out.println();
//		}

//		int arr []= {1,2};
		// rotateArrayWithK(arr, 3);
//		int arr[][] = {{1,2,3},{4,5,6},{7,8,9}};  
//		List<List<Integer>> shiftGrid = shiftGrid(arr, 2);
//		for(int i =0 ;i<shiftGrid.size();i++) {
//			System.out.println(shiftGrid.get(i));
//		}

//		System.out.println(maximumSumOfTwoSubStringScore("00111"));
//		System.out.println(convertArrayIn2DArray(new int[] {1,2,3,4,5,5,6,200,200}));
//	System.out.println(missingNumber(new int[] {9,6,4,2,3,5,7,0,1}));	
//		System.out.println(unique(new int[] {1,1,2,2,3,3,9}));
		// System.out.println(Arrays.toString(findErrorNums(new int[] {1,2,2,4})));
		//	kajuKatli(10);
		System.out.println(System.currentTimeMillis());
		System.out.println(minOperations("1000"));
		System.out.println(System.currentTimeMillis());
	}

	public static int minOperations(String s) {
		int count[] = new int[2];
		for(int i=0;i<s.length();i++) {
			count[s.charAt(i)-'0']++;
		}
		if(count[0]>count[1]) {
		return	(count[0]-count[1])/2;
		}
		(count[1]-count[1])/2;
		System.out.println(Arrays.toString(count));
		return 0;
	}
	
	
	public static int[] findErrorNums(int[] arr) {
		Set<Integer> value = new HashSet<>();
		int[] ar = new int[2];
		for (int i = 0; i < arr.length; i++) {
			if (value.contains(arr[i])) {
				ar[0] = arr[i];
				arr[1] = arr[i] + 1;
				System.out.println(arr[i] + 1);
				return ar;
			}
			value.add(arr[i]);
		}
		return ar;
	}

	public static int[] selectionSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			int min = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[j] < arr[min])
					min = j;
			}
			int temp = arr[i];
			arr[i] = arr[min];
			arr[min] = temp;

		}
		return arr;
	}

	public static int[] bubbleSortPr(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}

			}
		}
		return arr;
	}

	public static int unique(int arr[]) {
		int xor = 0;
		for (int i = 0; i < arr.length; i++) {
			xor ^= arr[i];
		}
		return xor;
	}

	public static int xorDuplicate(int arr[]) {

		for (int i = 0; i < arr.length; i++) {

		}
		return 0;
	}

	public static int missingNumber(int arr[]) {
		int max = findMaximum(arr);
		int total = max * (max + 1) / 2, sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return total - sum == 0 ? max + 1 : total - sum;
	}

	public static int countNumber(int arr[], int value) {
		int count = 0;

		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == value)
				count++;
			if (count > 2)
				return count;
		}
		return count;
	}

	public static int uniqueElement(int arr[]) {
		Set<Integer> value = Arrays.stream(arr).boxed().collect(Collectors.toSet());
		Iterator<Integer> iterator = value.iterator();
		while (iterator.hasNext()) {
			int va = iterator.next();
			if (count(arr, va) < 2)
				return va;
		}
		return -1;
	}

	public static int findMaximum(int arr[]) {
		int max = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] > max)
				max = arr[i];
		}
		return max;
	}

	public static List<List<Integer>> convertArrayIn2DArray(int arr[]) {
		// int max = findMaximum(arr);
		int count[] = new int[201];
		for (int i = 0; i < arr.length; i++)
			count[arr[i]]++;
//		System.out.println(Arrays.toString(count));
		int max = findMaximum(count);
		List<List<Integer>> response = new ArrayList<>();
		for (int i = 0; i < max; i++) {
			List<Integer> list = new ArrayList<>();
			for (int j = 0; j < count.length; j++) {
				if (count[j] > 0) {
					list.add(j);
					count[j]--;
				}
			}
			response.add(list);
		}

		return response;
	}

	public static int count(char arr[], int st, int end, char ch) {
		int count = 0;
		while (st <= end) {
			if (arr[st] == ch)
				count++;
			st++;
		}

		return count;
	}

	public static int maximumSumOfTwoSubStringScore(String s) {
		char[] arr = s.toCharArray();
		int i = 0, j = i + 1, max = 0;
		while (i < j && j < arr.length) {
			int cou = count(arr, i, j - 1, '0') + count(arr, j, arr.length - 1, '1');

			if (cou > max)
				max = cou;
			j++;
		}
		return max;
	}

	public static List<List<Integer>> shiftGrid(int arr[][], int k) {
		int row = arr.length, col = arr[0].length, j = row * col - 1, count = 0;
		while (count++ < k) {
			int ele = arr[arr.length - 1][arr[0].length - 1];
			for (j = row * col - 1; j > 0; j--) {
				arr[j / col][j % col] = arr[(j - 1) / col][(j - 1) % col];
			}
			arr[0][0] = ele;

		}
		List<List<Integer>> ar = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			List<Integer> ro = new ArrayList<>();
			for (j = 0; j < arr[0].length; j++) {
				ro.add(arr[i][j]);
			}
			ar.add(ro);

		}
		return ar;
	}

	public static boolean binarySearch2DInSortedRow(int arr[][], int target) {
		int row = 0, col = arr[0].length - 1;

		while (col >= 0 && row <= arr.length - 1) {
			if (arr[row][col] == target)
				return true;
			if (arr[row][col] < target)
				row++;
			else
				col--;
		}
		return false;
	}

	public static boolean binarySearchIn2D(int arr[][], int target) {
		int row = arr.length;
		int col = arr[0].length;
		int st = 0;
		int end = row * col - 1;

		while (st <= end) {
			int mid = st + (end - st) / 2;
			int element = arr[mid / col][mid % col];
			if (element == target)
				return true;
			if (element < target)
				st = mid + 1;
			else
				end = mid - 1;

		}
		return false;

	}

	public static void rotateArrayWithK(int arr[], int k) {
		int arr2[] = new int[arr.length], l = 0;
		int kIndex = arr.length - k;

		if (k >= arr.length) {
			int count = 0;
			while (count++ <= k) {
				int temp = arr[arr.length - 1];
				System.out.println(Arrays.toString(arr));
				for (int j = arr.length - 1; j > 0; j--) {
					arr[j] = arr[j - 1];
				}
				arr[0] = temp;
			}
			return;
		}

		if (kIndex < 0)
			return;
		for (int i = kIndex; i < arr.length; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < kIndex; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < arr.length; i++)
			arr[i] = arr2[i];

	}

	public static int[][] rotateArray90(int arr[][]) {
		int arr3[][] = new int[arr.length][arr[0].length], k = 0;
		for (int col = 0; col < arr[0].length; col++) {
			k = 0;
			for (int row = arr.length - 1; row >= 0; row--) {
				arr3[col][k++] = arr[row][col];
			}

		}
		return arr3;
	}

	public static int[][] generateMatrix(int n) {
		int row = n;
		int col = n;
		int total = n * n;
		int startingCol = 0;
		int startingRow = 0;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int arr[][] = new int[n][n];
		int count = 0;
		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				arr[startingRow][i] = ++count;
			}

			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				arr[i][endingCol] = ++count;
			}

			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				arr[endingRow][i] = ++count;
			}

			endingRow--;

			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				arr[i][startingCol] = ++count;
			}
			startingCol++;

		}
		return arr;
	}

	public static void printSprial(int arr[][]) {
		int startingCol = 0;
		int startingRow = 0;
		int row = arr.length;
		int col = arr[0].length;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int count = 0;
		int total = row * col;

		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				System.out.print(arr[startingRow][i]);
				count++;
			}
			System.out.println();
			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				System.out.print(arr[i][endingCol]);
				count++;
			}

			System.out.println();
			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				System.out.print(arr[endingRow][i]);
				count++;
			}

			endingRow--;
			System.out.println();
			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				System.out.print(arr[i][startingCol]);
				count++;
			}
			startingCol++;
			System.out.println();
		}
	}

	public static boolean isVowel(char ch) {
		ch = Character.toLowerCase(ch);
		if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
			return true;
		return false;
	}

	public static String reverseVowels(String s) {

		char[] arr = s.toCharArray();
		int i = 0, j = arr.length - 1;
		while (i < j) {
			if (isVowel(arr[i]) && isVowel(arr[j])) {
				char t = arr[i];
				arr[i] = arr[j];
				arr[j] = t;
				i++;
				j--;
			} else if (isVowel(arr[i]))
				j--;
			else
				i++;
		}
		return new String(arr);
	}

	public static void printWave(int arr[][], int row, int col) {
		for (int j = 0; j < col; j++) {

			for (int i = 0; i < row; i++) {
				System.out.print(arr[i][j]);
			}

			System.out.println();
			j++;
			for (int i = row - 1; i >= 0 && j < col; i--) {
				System.out.print(arr[i][j]);
			}
			System.out.println();

		}
	}

	public static int[] mergeSorted(int arr[], int m, int arr1[], int n) {
		int arr3[] = new int[m + n], i = 0, j = 0, k = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j] && n > 0) {
				arr3[k++] = arr1[j++];
				n--;
			} else if (m > 0) {
				arr3[k++] = arr[i++];
				m--;
			} else
				break;

		}
		System.out.println(Arrays.toString(arr3));
		while (m > 0 && i < arr.length) {
			arr3[k++] = arr[i++];
			m--;
		}
		while (n > 0 && j < arr1.length) {
			arr3[k++] = arr1[j++];
			n--;
		}
		return arr3;
	}

	public static List<Foodsystem> system = new ArrayList<>();

	public void enterData() {
		String food[] = { "kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi" };
		String country[] = { "korean", "japanese", "japanese", "greek", "japanese", "korean" };
		int arr[] = { 9, 12, 8, 15, 14, 7 };
		for (int i = 0; i < country.length; i++) {
			Map<String, Integer> fs = new LinkedHashMap<>();
			Foodsystem s = new Foodsystem();
			s.count = country[i];
			s.food.put(food[i], arr[i]);
			this.add(s);
		}
		System.out.println(system);

	}

	public void add(Foodsystem o) {
		for (int i = 0; i < this.system.size(); i++) {
			if (system.get(i).count.equals(o.count)) {
				system.get(i).food.putAll(o.food);
				return;
			}

		}
		this.system.add(o);
	}

	public void changeRating(String food, int rating) {
		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem f = system.get(i);
			if (f.food.containsKey(food)) {
				f.food.put(food, rating);
				return;
			}

		}

	}

	public String highestRating(String country) {
		String city = "";

		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem s = system.get(i);
			if (s.count.equals(country)) {
				int max = 0;
				Set<Entry<String, Integer>> entrySet = s.food.entrySet();
				System.out.println(entrySet);
				for (Entry<String, Integer> e : entrySet) {
					if (e.getValue() > max) {
						max = e.getValue();
						city = e.getKey();

					}
					if (e.getValue() == max) {
						s.food.put(e.getKey(), e.getValue());
					}
				}
			}

		}

		return city;
	}

	public static int countLetters(char[] s) {
		int k = 0;
		for (int i = 0; i < s.length;) {
			char ch = s[i];
			int j = i + 1, count = 1;

			while (j < s.length && s[j] == ch) {
				count++;
				j++;
			}
			System.out.println(ch + " " + count + " " + j);
			if (count > 1) {
				s[k++] = ch;
				for (char c : Integer.toString(count).toCharArray()) {
					if (k < s.length)
						s[k++] = c;
					else
						return k;
				}
			} else {
				s[k++] = ch;
			}
			i = j;
		}
		return k;
	}

	public static String removeAllDuplicates(String s) {
		StringBuilder sb = new StringBuilder();
		int count[] = new int[26];
		for (int i = 0; i < s.length(); i++) {
			int num = s.charAt(i) - 'a';
			count[num]++;
		}

		for (int i = 0; i < s.length(); i++) {
			if (count[(s.charAt(i) - 'a')] < 2)
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static String removeAllSubstring(String s, String part) {
		while (s.length() != 0 && s.contains(part))
			s = s.replaceFirst(part, "");

		return s;
	}

	public static String replaceAllDigitsWithCharacter(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
				sb.append((char) (s.charAt(i - 1) + (s.charAt(i) - 48)));
			else
				sb.append(s.charAt(i));
		}
		return sb.toString();

	}

	public static String replaceString(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == ' ')
				sb.append("@40");
			else
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static char mostOccurranceInString(String s) {
		int arr[] = new int[26]; // storing occurance of every letter according to index
		s = s.toLowerCase();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
				int num = s.charAt(i) - 'a';
				arr[num]++;
			}
		}

		// finding max
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < arr.length; i++) {
			if (max < arr[i]) {
				max = arr[i];
				ch = (char) i;
			}

		}
		return (char) (ch + 'a');

	}

	// brute force
	public static char mostOccurrance(String s) {
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < s.length(); i++) {
			int count = 0;
			for (int j = i + 1; j < s.length(); j++) {
				if (s.charAt(i) == s.charAt(j) && s.charAt(i) != ' ')
					count++;
			}

			if (count > max) {
				ch = s.charAt(i);
				max = count;
			}
		}
		return ch;
	}

	public static int climbStairs(int n) {

		if (n < 0)
			return 0;
		if (n == 0)
			return 1;
		return climbStairs(n - 1) + climbStairs(n - 2);
	}

	public static void reverseString(char[] ch, int st, int end) {

		while (st < end) {
			char temp = ch[st];
			ch[st] = ch[end];
			ch[end] = temp;
			st++;
			end--;
		}

	}

	public static char[] reverseWords(String s) {
		char ch[] = s.toCharArray();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ' && s.charAt(i) != ',') {
				int j = i + 1;
				for (; j < s.length(); j++) {
					if (s.charAt(j) == ' ' || s.charAt(j) == ',')
						break;
				}
				reverseString(ch, i, j - 1);
				i = j;
			}
		}
		return ch;
	}

	public static boolean isAlphaNumeric(char c) {
		if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9')
			return true;
		return false;
	}

	public static boolean isPolinromValidAlgo(String s) {
		StringBuilder b = new StringBuilder();
		// remove special characters only left alphanumeric
		for (int i = 0; i < s.length(); i++) {
			if (isAlphaNumeric(s.charAt(i)))
				b.append(s.charAt(i));

		}

		// to lower case
		String str = b.toString().toLowerCase();
		int st = 0, end = str.length() - 1;
		while (st < end) {
			if (str.charAt(st) != str.charAt(end))
				return false;
			st++;
			end--;
		}
		return true;

	}

	public static boolean isPolindrom(String s) {
		int st = 0, end = s.length() - 1;
		while (st < end) {
			if (s.charAt(st) >= '0' && s.charAt(st) <= '9') {
				if (s.charAt(end) >= '0' && s.charAt(end) <= '9') {

					if (s.charAt(st) != s.charAt(end))
						return false;
					else {
						st++;
						end--;
					}
				} else
					end--;
			} else
				st++;
		}
		return true;
	}

	// optimized
	public static int[] plusOneOptimized(int arr[]) {
		for (int i = arr.length - 1; i >= 0; i--) {
			if (arr[i] < 9) {
				arr[i]++;
				return arr;
			}
			arr[i] = 0;
		}
		arr = new int[arr.length + 1];
		arr[0] = 1;
		return arr;
	}

	// brute force
	public static int[] plusOne(int arr[]) {
		if (arr.length < 1)
			return arr;
		int carry = 1;
		for (int i = arr.length - 1; i >= 0; i--) {
			arr[i] = arr[i] + carry;
			carry = 0;
			if (arr[i] > 9) {
				arr[i] = 0;
				carry = 1;
			} else
				break;
		}

		if (carry != 0) {
			int ar[] = new int[arr.length + 1];
			ar[0] = carry;
			for (int i = 1; i < ar.length - 1; i++)
				ar[i] = arr[i];
			return ar;
		}
		return arr;
	}

	public static int countLastWordLength(String s, int index) {
		int count = 0;
		for (; index >= 0; index--) {
			if (s.charAt(index) != ' ')
				count++;
			else
				break;
		}
		return count;
	}

	public static int lastWordLength(String s) {
		for (int i = s.length() - 1; i >= 0; i--) {
			if (s.charAt(i) != ' ')
				return countLastWordLength(s, i);
		}
		return 0;
	}

	public static int firstOccurances(String s, String value) {
		if (s.contains(value)) {
			return s.indexOf(value);
		}
		return -1;
	}

	public static boolean isMatched(String s, String value) {
		if (s.length() < value.length())
			return false;
		for (int i = 0; i < value.length(); i++) {
			if (s.charAt(i) != value.charAt(i))
				return false;
		}
		return true;
	}

	public static int firstOccurance(String s, String value) {
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == value.charAt(0)) {
				if (isMatched(s.substring(i), value))
					return i;
			}
		}
		return -1;
	}

	public static int[] removeDuplicatess(int arr[]) {
		int i = 0, j = 1;
		for (i = 1; i < arr.length; i++) {
			if (arr[i - 1] != arr[i])
				arr[j++] = arr[i];
		}
		return arr;
	}

	public static int[] removeDuplicates(int arr[]) {
		Set<Integer> set = new LinkedHashSet<>();
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		return set.stream().mapToInt(i -> i).toArray();

	}

	public static String longestPrefixs(String arr[]) {
		Arrays.sort(arr);
		StringBuilder b = new StringBuilder();
		String first = arr[0];
		String last = arr[arr.length - 1];
		for (int i = 0; i < Math.min(first.length(), last.length()); i++) {
			if (first.charAt(i) != last.charAt(i))
				return b.toString();
			b.append(first.charAt(i));
		}
		return b.toString();

	}

	public static int[] twoSum2(int[] arr, int target) {
		int f = 0, l = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 1; j < arr.length; j++) {
				if (arr[i] + arr[j] == target) {
					f = i;
					l = j;
				}
			}
		}
		return new int[] { f, l };
	}

	public static Boolean arraySortedOrRotated(int arr[]) {
		int count = 0;
		for (int i = 1; i < arr.length; i++) {
			if (arr[i - 1] > arr[i])
				count++;
		}
		if (arr[0] < arr[arr.length - 1])
			count++;

		return count == 1;
	}

	// brute force
	public static Boolean isArraySortedOrRotated(int arr[]) {
		int i = 0;
		for (i = 0; i < arr.length - 1; i++) {
			if (arr[i] > arr[i + 1])
				break;

		}
		System.out.println(i + " -<");
		i++;
		for (; i < arr.length - 1; i++) {
			System.out.println("->" + i);
			if (arr[0] < arr[i] || arr[i] > arr[i + 1])
				return false;
		}
		if (i < arr.length && arr[0] < arr[i])
			return false;
		return true;
	}

	public static int findUnique(int arr[]) {
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {

			ans = ans ^ arr[i];
		}
		return ans;
	}

	public static int count(int arr[], int value) {
		int count = 0;
		for (int i = 0; i < arr.length; i++) {
			if (value == arr[i])
				count++;
		}
		return count;

	}

	public static int uniqueOccurance(int arr[]) {
		int arr1[] = new int[arr.length], k = 0;
		for (int i = 0; i < arr.length; i++) {
			if (!isPreExists(arr[i], arr, i - 1)) {

				int count = count(arr, arr[i]);
				arr1[k++] = count;
				System.out.println("count " + count);
			}
		}
		return findUniqueElement(arr1);
	}

	public static int[] reverse(int arr[], int st, int end) {
		if (end < arr.length)
			while (st < end) {
				int k = arr[st];
				arr[st++] = arr[end];
				arr[end--] = k;
			}
		return arr;
	}

	public static int[] reverseKElements(int arr[], int k) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length; i += k) {

			reverse(arr, i, i + k - 1);
		}
		System.out.println(Arrays.toString(arr));
		return arr;

	}

	public static boolean isPreExists(int value, int arr[], int k) {
		for (int i = k; i >= 0; i--) {
			if (arr[i] == value)
				return true;
		}
		return false;
	}

	public static int findUniqueElement(int arr[]) {
		System.out.println(Arrays.toString(arr));
		for (int i = 0; i < arr.length; i++) {
			int count = 0;
			if (!isPreExists(arr[i], arr, i - 1))
				for (int j = i; j < arr.length; j++) {

					if (arr[i] == arr[j])
						count++;
				}

			if (count == 1) {
				System.out.println("found " + arr[i]);

				return arr[i];
			}
		}
		return 0;
	}

	public static int[] insertionSort(int arr[]) {
		int j = 0;
		for (int i = 0; i < arr.length; i++) {
			int k = arr[i];
			for (j = i - 1; j >= 0; j--) {
				if (arr[j] < k) {
					arr[j + 1] = arr[j];
				} else
					break;
			}
			arr[j + 1] = k;
		}
		return arr;
	}

	public static int[] selectionSortRecu(int arr[], int i, int j, int min) {
		if (i >= arr.length)
			return arr;
		if (j < arr.length) {
			if (arr[min] > arr[j])
				min = j;
			return selectionSortRecu(arr, i, j + 1, min);
		}
		int k = arr[i];
		arr[i] = arr[min];
		arr[min] = k;
		return selectionSortRecu(arr, i + 1, i + 2, i + 1);
	}

	public static int[] mergeTwoSortedArray(int arr[], int arr1[]) {
		int arr3[] = new int[arr.length + arr1.length], k = 0, i = 0, j = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j]) {
				arr3[k++] = arr1[j++];

			} else {
				arr3[k++] = arr[i++];

			}
		}

		while (i < arr.length) {
			arr3[k++] = arr[i++];
		}
		while (j < arr1.length) {
			arr3[k++] = arr1[i++];
		}
		return arr3;
	}

	public static void recursionBubbleSort(int arr[], int i, int j) {
		if (i == arr.length)
			return;
		if (j < arr.length - i - 1 && arr[j] > arr[j + 1]) {

			int k = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = k;
			System.out.println(Arrays.toString(arr));
			recursionBubbleSort(arr, i, j + 1);

		} else {
			System.out.println("----- " + Arrays.toString(arr));
			recursionBubbleSort(arr, i + 1, 0);
		}

	}

	public static void bubbleSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int k = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = k;
				}

			}
		}
	}

	public static List<List<Integer>> threeSum(int arr[]) {
		int i = 0, j = 0, k = arr.length - 1;
		Set<List<Integer>> output = new HashSet<>();
		for (i = 0; i < arr.length; i++) {
			j = i + 1;
			k = arr.length - 1;
			while (j < k) {
				System.out.println(arr[i] + "->" + arr[j] + "->" + arr[k] + "=> " + (arr[i] + arr[j] + arr[k]) + " ( "
						+ i + "," + j + "," + k);
				if (arr[i] + arr[j] + arr[k] == 0) {
					List<Integer> list = new ArrayList<>();
					list.add(arr[i]);
					list.add(arr[j]);

					list.add(arr[k]);
					output.add(list);
				} else if (arr[i] + arr[j] + arr[k] > 0) {
					k--;
					j--;
				}
				j++;

			}
		}

		return output.stream().toList();

	}

	public static String longestPrefix(String s[]) {

		String prefix = "";

		for (int i = 0; i < s.length; i++) {
			for (int j = i + 1; j < s.length; j++) {
				if (s[i].length() > s[j].length()) {
					String temp = s[i];
					s[i] = s[j];
					s[j] = temp;
				}
			}
		}

		String st = s[0];
		boolean isMatched = false;
		for (int j = 0; j < st.length(); j++) {
			char ch = st.charAt(j);

			for (int k = 1; k < s.length; k++) {
				isMatched = false;

				if (ch == s[k].charAt(j)) {
					isMatched = true;
				} else
					break;
			}
			if (isMatched)
				prefix += ch;
			else
				break;

		}
		;
		return prefix;

	}

	public static String nonRepeatingChar(String s) {
		for (int i = 0; i < s.length(); i++) {
			boolean isPresent = false;
			for (int j = 0; j < s.length(); j++) {
				if (i != j && s.charAt(i) == s.charAt(j)) {
					isPresent = true;
					break;
				}
			}
			if (!isPresent) {
				return s.charAt(i) + "";
			}
		}
		return "All Are repated";
	}

	public static Integer romanToInteger(String s) {
		int num = 0;
		Map<String, Integer> romans = new HashMap<>();
		romans.put("M", 1000);
		romans.put("CM", 900);
		romans.put("D", 500);
		romans.put("CD", 400);
		romans.put("C", 100);
		romans.put("XC", 90);
		romans.put("L", 50);
		romans.put("XL", 40);
		romans.put("X", 10);
		romans.put("IX", 9);
		romans.put("V", 5);
		romans.put("IV", 4);
		romans.put("I", 1);
//System.out.println(romans.get("M"));
		if (s.length() < 2)
			return romans.get(s.charAt(0) + "");
		for (int i = 0; i < s.length() - 1; i++) {

			if (romans.get(s.charAt(i) + "").intValue() >= romans.get(s.charAt(i + 1) + "").intValue()) {
				num += romans.get(s.charAt(i) + "");
				System.out.println("num -> " + num);
			} else {

				int sum = romans.get(s.charAt(i + 1) + "") - romans.get(s.charAt(i) + "");
				System.out.println("num    => " + num + "  sum => " + sum);
				num += sum;
				i++;
				System.out.println("--------- " + num);
			}
			if (i == s.length() - 2)
				if (romans.get(s.charAt(i + 1) + "").intValue() <= romans.get(s.charAt(i) + "").intValue()) {
					num += romans.get(s.charAt(i + 1) + "");

				}
		}
		return num;
	}

	public static String integerToRoman(int num) {
		Integer number[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
		String romans[] = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };
		String result = "";
		for (int i = 0; i < number.length; i++) {

			while (num >= number[i]) {
				num -= number[i];
				result += romans[i];
			}
		}
		return result;

	}

	public static int convertToInteger(String s) {
		String st = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {
				st += s.charAt(i);
			} else if (s.charAt(i) == '-')
				st += s.charAt(i);
		}
		System.out.println(Integer.parseInt(st));
		return 0;
	}

	public static int reverserInteger(int n) {
		int rev = 0;
		while (n != 0) {
			int r = n % 10;
			n /= 10;
			rev = rev * 10 + r;
		}
		System.out.println(rev);
		return 0;
	}

	public static int[] mergeSortedArrays(int a1[], int a2[]) {
		int a3[] = new int[a1.length + a2.length], j = 0, k = 0, i = 0;

		Stack<Character> stack = new Stack();
		String s = "a";
		Character c = s.charAt(i);
		System.out.println(c.equals(c));

		while (i < a1.length && j < a2.length) {

			if (a1[i] >= a2[j])
				a3[k++] = a2[j++];
			else
				a3[k++] = a1[i++];

		}
		while (i < a1.length)
			a3[k++] = a1[i++];

		while (j < a2.length)
			a3[k++] = a2[j++];

		return a3;

	}

	public static int[] insertInSortedArray(int arr[], int value) {
		int temp[] = new int[arr.length + 1], j = 0;
		boolean isInserted = false;
		for (int i = 0; i < arr.length; i++) {

			if (!isInserted && arr[i] > value) {
				temp[j++] = value;
				isInserted = true;
			}
			temp[j++] = arr[i];
		}
		if (!isInserted)
			temp[j++] = value;
		return temp;
	}

	public static int[] inserAtNthPos(int arr[], int value, int pos) {
		int j = 0;
		int temp[] = new int[arr.length + 1];
		if (pos < 1)
			return arr;

		for (int i = 0; i < arr.length; i++) {
			if (i == pos - 1)
				temp[j++] = value;

			temp[j++] = arr[i];
		}
		if (pos > arr.length) {
			temp[j++] = value;
		}

//	for(int i=0;i<temp.length;i++)
//		arr[i]=temp[i];
		return temp;
	}

	public static void righRotation(int arr[], int num) {
		int n = arr.length, temp = 0, count = 0;
		while (count++ < num) {
			temp = arr[n - 1];
			for (int i = n - 1; i > 0; i--)
				arr[i] = arr[i - 1];
			arr[0] = temp;
		}

	}

	public static void leftRotation(int arr[], int num) {
		int temp[] = new int[arr.length], n = arr.length, j = 0;

		for (int i = num; i < n; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < num; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < n; i++)
			arr[i] = temp[i];
	}

	public static char[] copyArray(char[] arr) {
		if (arr == null)
			return new char[1];

		char[] a = Arrays.copyOf(arr, arr.length + 1);
		return a;
	}

	public static String zigzapConversion(String s, int num) {
		char[][] arr = new char[num][];
		int k = 0, i = 0, j = 0, t = 0;
		while (k < s.length()) {
			while (i != num - 1) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i++;
			}
			j++;
			while (i != 0) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i--;
			}
			j++;

		}
		for (char[] a : arr) {
			for (char tt : a)
				System.out.print(tt);
			System.out.println();
		}
		return "";
	}

	public static String longestPolindromSubtString(String s) {
		String ans = "";
		if (s.length() < 1)
			return s;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - 1; j >= 0; j--) {
				if (i < j) {
					String sub = s.substring(i, j + 1);
					if (sub.equals(new StringBuilder(sub).reverse().toString())) {
						if (sub.length() > ans.length()) {
							ans = sub;
						}

					}
				}
			}
		}

		return ans;
	}

	public static double medianOfTwoSortedArray(int[] arr1, int[] arr2) {

		int arr3[] = new int[arr1.length + arr2.length], i = 0, j = 0, k = 0;
		while (true) {
			if (i < arr1.length) {
				arr3[k++] = arr1[i++];
			} else if (j < arr2.length) {
				arr3[k++] = arr2[j++];
			} else
				break;

		}
		double ans = 0;
		Arrays.sort(arr3);
		System.out.println(Arrays.toString(arr3));
		if (arr3.length % 2 == 0) {
			int mid = arr3.length / 2;
			ans = (double) (arr3[mid - 1] + arr3[mid]) / 2;
			System.out.println(arr3[mid - 1]);
		} else {
			ans = arr3[arr3.length / 2];
		}

		return ans;
	}
// 4
// 1,1,1,1
// 2,1,1
// 1,1,2
// 2,2

	public static int[] twoSum(int arr[], int target) {
		int f = 0, sec = 0;
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {
				if (arr[i] + arr[j] == target && i != j) {

					f = i;
					sec = j;
				}
			}

		}
		System.out.println(f + " " + sec);
		return new int[] { f, sec };
	}

	public static char[] stringToArrayOfCharacters(String s) {
		char arr[] = new char[s.length()];
		for (int i = 0; i < s.length(); i++) {
			arr[i] = s.charAt(i);
		}
		return arr;
	}

	public static String[] textToWordsArray(String text) {
		List<String> words = new ArrayList<>();
		for (int i = 0; i < text.length(); i++) {

			for (int j = i; j < text.length() - 1; j++) {
				if (i > 0 && text.charAt(i) == ' ' && text.charAt(j + 1) == ' ' && text.charAt(i - 1) != ' ') {
					words.add(text.substring(i + 1, j + 1));
					break;
				} else if (i == 0 && text.charAt(j + 1) == ' ') {
					words.add(text.substring(i, j + 1));
					break;
				} else if (text.charAt(i) == ' ' && j + 1 == text.length() - 1) {
					words.add(text.substring(i + 1, text.length()));
					break;
				}
			}

		}
		String s[] = new String[words.size()];
		int i = 0;
		ListIterator<String> listIterator = words.listIterator();
		while (listIterator.hasNext()) {
			s[i++] = listIterator.next();
		}
		return s;
	}

	public static int wordCount(String s) {
		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0)
				count++;
			else if (s.charAt(i) == ' ')
				for (int j = i; j < s.length() - 1; j++) {
					if (s.charAt(j + 1) == ' ' && s.charAt(i - 1) != ' ') {
						count++;
						System.out.print(s.charAt(i) + " - > " + s.charAt(j) + " = " + count);
						break;
					}
				}
		}
		return count + 1;

	}

	public static void uniqueFromArrays(int arr[], int arr2[]) {

		List<Integer> list1 = List.of(1, 2, 4);
		List<Integer> list2 = List.of(1, 2, 3, 5);
		List<Integer> unique = new ArrayList<>();
		unique.addAll(list1);
		unique.addAll(list2);
		unique = unique.stream().distinct()
				.filter(a -> list1.contains(a) && !list2.contains(a) || !list1.contains(a) && list2.contains(a))
				.collect(Collectors.toList());
		System.out.println(unique);

		int k = 0;
		for (int i = 0; i < arr.length || k < arr2.length; i++, k++) {
			boolean a = false;
			boolean b = false;
			if (i < arr.length)
				for (int j = 0; j < arr2.length; j++) {
					if (arr[i] == arr2[j])
						a = true;
				}
			for (int j = 0; j < arr.length; j++) {
				if (arr2[k] == arr[j])
					b = true;
			}
			if (!a && i < arr.length)
				System.out.println(arr[i]);
			if (!b)
				System.out.println(arr2[k]);
		}
	}

	public static void arraySum(int arr[], int arr2[]) {
		int carry = 0, total = 0, j = 0, k = arr2.length - 1, i;
		List<Integer> sum = new ArrayList<>();

		for (i = arr.length - 1; i >= 0 && k >= 0; i--, k--) {

			total = arr[i] + arr2[k] + carry;
			carry = 0;
			if (total > 9) {
				carry = total % 10;
				total /= 10;
			}
			sum.add(total);

		}

		if (i < 0 && k >= 0) {
			for (int a = k; a >= 0; a--)
				sum.add(arr2[a]);
		}
		if (k < 0 && i >= 0) {
			for (int a = i; a >= 0; a--)
				sum.add(arr[a]);
		}
		Collections.reverse(sum);
		System.out.println(sum);
	}

	public static void arrayRightRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[arr.length - 1];
			for (j = arr.length - 1; j > 0; j--) {
				arr[j] = arr[j - 1];
			}
			count++;
			arr[0] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static void arrayLeftRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[0];
			for (j = 0; j < arr.length - 1; j++) {
				arr[j] = arr[j + 1];
			}
			count++;
			arr[j] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static boolean anagram(String s, String s1) {

		int count = 0;
		boolean b = false;
		for (int i = 0; i < s.length(); i++) {
			char ch = s.charAt(i);
			count = 0;
			b = false;
			for (int k = 0; k < s.length(); k++) {
				if (ch == s.charAt(k))
					count++;
			}

			for (int j = 0; j < s1.length(); j++) {
				if (count > 0 && ch == s1.charAt(j))
					count--;
			}
			if (count == 0)
				b = true;
		}

		System.out.println(b ? "yes" : "no");
		return b;
	}

	public static int count(int i, int arr[]) {
		int count = 0;
		for (int a : arr) {
			if (a == i)
				count++;
		}
		System.out.println(count);
		return count;
	}

	public static void majorityElement(int arr[]) {
		int max = 0, count = 0;
		for (int i = 0; i < arr.length; i++) {
			count = count(arr[i], arr);
			if (count >= max && count > arr.length / 2)
				max = arr[i];

		}
		System.out.println(max);
	}

	public static void longestPolindrom(String s) {

		int first = 0, last = s.length() - 1, max = 0;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - i; j >= 0; j--) {
				if (i < j && j < s.length())
					if (checkPolindrom(i, j + 1, s) && max < s.substring(i, j).length()) {

						max = s.substring(i, j + 1).length();
						first = i;
						last = j + 1;
					}
			}
			System.out.println("------");

		}
		System.out.println(s.substring(first, last));

	}

	public static boolean checkPolindrom(int f, int l, String s) {
		String st = s.substring(f, l);
		System.out.println(st + "444");
		return st.equals(new StringBuffer(st).reverse().toString());

	}

	public void spiralMatrix() throws ClassNotFoundException, NoSuchMethodException, SecurityException,
			InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		int a[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };
		int j = 0, k = 0, count = 0, max = 10 - 1;
		// int max=a.length*a.length-1;
		// System.out.println(a.length);

		for (int i = 0; i < a.length - i; i++) {

			if (count == max)
				break;

			for (j = i; j < a.length - i && count <= max; j++) {
				count++;
				System.out.println(a[k][j]);
			}
			j--;

			k++;
			while (k < a.length - i && count <= max) {
				System.out.println(a[k][j]);
				k++;
				count++;
			}
			k--;
			j--;

			while (j >= 0 && count <= max) {
				count++;
				System.out.println(a[k][j--]);
			}

			// k=i+1;
			if (k == a.length / 2 && j == a.length / 2)
				break;
			j++;
			while (k > i + 1 && count <= max) {
				System.out.println(a[--k][j]);
				count++;
			}

			k = i + 1;
			System.out.println("-----------------");
		}

	}

	public static ArrayList<Integer> findIndexes(int arr[], int sum) {
		boolean a = false;
		int f = 0, l = arr.length, s = 0;
		for (int i = 0; i < arr.length; i++) {
			s = 0;
			if (a)
				break;

			for (int j = i; j < arr.length; j++) {
				s += arr[j];
				if (s == sum) {
					f = i;
					l = j;
					a = true;
					break;
				}

			}
			System.out.println(s);
		}

		return a ? new ArrayList<Integer>(Arrays.asList(f, l)) : new ArrayList<Integer>(Arrays.asList(-1));
	}

	public int count(char a, String s) {
		class A {
			static int a;

			public void main() {
				System.out.println("hello");
			}
		}

		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == a)
				count++;
		}
		return count;
	}

	public static boolean isPresent(char a, int indx, String s) {
		for (int i = indx; i >= 0; i--) {
			if (s.charAt(i) == a)
				return true;
		}
		return false;
	}

	public static boolean isPresent(int a, int indx, int ar[]) {
		for (int i = indx; i >= 0; i--) {
			if (ar[i] == a)
				return true;
		}
		return false;
	}

	public static void fibonacci(int t1, int t2, int n) {
		if (n == 0)
			return;
		else {
			int t3 = t1 + t2;
			t1 = t2;
			t2 = t3;
			System.out.println(t3);
			fibonacci(t1, t2, n - 1);
		}

	}

	public static int factorial(int n) {
		if (n == 1)
			return 1;
		else
			n = n * factorial(n - 1);
		return n;

	}

	public static String removeSpaces(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ')
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static int[] removeDuplicate(int[] a) {
		int arr[] = new int[a.length];
		int j = 0;
		for (int i = 0; i < a.length; i++) {
			if (!isPresent(a[i], i - 1, a))
				arr[j++] = a[i];
		}
		a = new int[j];
		System.out.println(j);
		for (int i = 0; i < j; i++)
			a[i] = arr[i];
		return a;
	}

	class C {
		static int a;
	}
}

class B {
	int a = 10;

	public String toString() {
		System.out.println("askfjal");
		return new String(this.a + "");
	}

	public void hello(int... a) {

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-12-24 23:21:08.275
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-12-24 23:21:08.276
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-12-24 23:21:08.919
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.pract;

import java.lang.reflect.InvocationTargetException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.springframework.jdbc.core.metadata.OracleCallMetaDataProvider;

interface DD {

}

class AB implements Comparable<AB> {
	int id = 0;
	String name = "rohit";

	@Override
	public int compareTo(AB o) {
		if (this.id < o.id)
			return 1;

		return -1;
	}

	@Override
	public String toString() {
		return "AB [id=" + id + ", name=" + name + "]";
	}

}

abstract class kd {

}

class Foodsystem {
	public String count;
	public Map<String, Integer> food = new LinkedHashMap<>();

	public String toString() {
		return count + " =" + food;
	}

}

public class Test {

	public Test(int a) {

	}

	public static void main(String[] args) throws Exception {
		// fibonacci(0,1,20);
		// Class<?> clas = Class.forName("com.pract.Test");

		// Constructor<?> to = clas.getConstructor(int.class);
		// Test t = (Test) to.newInstance();
		var a = new Test(8);

		// System.out.println(Integer.toBinaryString(2));

		// new Random().ints(1,999).limit(20).sorted().forEach(System.out::println);
		// List<Integer> list = List.of(1,2,3,4,5);
		// System.out.println(list.stream().mapToInt(v->v).max().getAsInt());
		// list.stream().max(Integer::compare);

//		
//		longestPolindrom("bcac");
//	
//	majorityElement(new  int []{1,2,3,4,5,5});
//		
//	anagram("abcda","bcdaa");
//	String sp="TEST@$QWES 89";
//	sp = sp.replaceAll("\\d+","");
//	System.out.println(sp);

//arrayLeftRotation(new int[] {1,2,3,4,5},4);
//arrayRightRotation(new int[] {1,2,3,4,5},2);
//arraySum(new int[] {1,2,3,4},new int[] {1,2,3});
//uniqueFromArrays(new int[] {1,2,4},new int[] {1,2,3,5});
//wordCount("Hello what are you doing here you fucking bitch bastard");
//String s[]=textToWordsArray("Hello what are you doing here you fucking bitch bastard ab bcd");

//char arr[]=stringToArrayOfCharacters("hello what");

//twoSum(new int[] {2,7,11,15},9);
//		System.out.println(medianOfTwoSortedArray(new int[] {3},new int[] {-2,-1}));
//		System.out.println(longestPolindromSubtString("cbbd"));
		// zigzapConversion("PAYPALISHIRING",4);
//		Date d = new Date();
//		SimpleDateFormat f = new SimpleDateFormat("dd/MM/yyyy");
//		Date parse = f.parse("12/9/2023");
//		//LocalDate.now().
//		LocalDate l = LocalDate.now();
//		LocalDate l2 = LocalDate.of(2024, 10, 11);
//		Period period = Period.between(l, l2);
//		period.between(l, l2);
//		DayOfWeek dayOfWeek = l2.getDayOfWeek();
//		System.out.println(dayOfWeek.toString());

//		int arr[] = new int[] { 1, 2, 4 };
//		int arr2[] = new int[] { 1, 3, 4 };
		// righRotation(arr, 2);
//inserAtNthPos(arr,3,3);

//arr=insertInSortedArray(arr,6);
//System.out.println(2%5);
//arr=mergeSortedArrays(arr,arr2);
//System.out.println(Arrays.toString(arr))
		// reverserInteger(-1234);
//convertToInteger("  -1234");

		// AB.main(new String[] {"a","b"});
		// AB ab = new AB();
//		ab.hello();
//Comparator<Integer> com = new Comparator<Integer>() {
//
//	@Override
//	public int compare(Integer o1, Integer o2) {
//	   
//		return o1.intValue()>o2.intValue()?o2:o1;
//	}
//	
//};
//com = (c,b) -> c<b?1:-1;
//
//TreeSet<AB>  t = new TreeSet<>(); 
//		AB a1 = new AB();
//		a1.id=10;
//		AB a2 = new AB();
//		a2.id=20;
//		AB a3 = new AB();
//		a3.id=30;
//		AB a4 = new AB();
//		a4.id=40;
//		AB a5 = new AB();
//		a5.id=50;
//		
//		t.add(a1);
//		t.add(a2);
//		t.add(a3);
//		t.add(a4);
//		t.add(a5);
//		System.out.println(t);
		// System.out.println(integerToRoman(400));
		// System.out.println(romanToInteger("D"));
		// System.out.println(nonRepeatingChar("abcabc"));
		// System.out.println(longestPrefix(new String[] {"flow","flowight","flower"}));
//		int arr1[] = { 10, 8, 7, 5, 4, 11, 78 };
//		int arr3[] = { -1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4 };
//		Arrays.sort(arr3);
		// System.out.println(threeSum(arr3));
//		recursionBubbleSort(arr1,0,0);
//		System.out.println(Arrays.toString(arr1));
//		List.of(arr);

//		System.out.println(Arrays.toString(mergeTwoSortedArray(new int[] {1,3,5,7,9},new int[] {2,4,6,7,8})));
//		System.out.println(Arrays.toString(selectionSortRecu(new int[] {7,9,4,3,2,1,54,3},0,1,0)));

//		System.out.println(Arrays.toString(insertionSort(new int[] {9,8,6,5,4,3,5})));
		// System.out.println(uniqueOccurance(new int[] {1,1,1,2,2,2,3,4,4,5,4,5}));;
//		System.out.println(reverseKElements(new int[] {1,2,3,4,5,6,7,8,9},2));

		// System.out.println(isArraySortedOrRotated(new int[] {5,6,7,8,1}));
		// System.out.println(Arrays.toString(twoSum2(new int[] {2 ,7,8,5,2,1},9)));
		// System.out.println(longestPrefixs(new String[] {"ab","aba","ad"}));
		// System.out.println(Arrays.toString(removeDuplicatess(new int[]
		// {1,1,2,2,3,4,4,5,55,5})));
		// System.out.println(firstOccurances("hadbadhad","had"));
		// String s[]= {"aaa","aec","adc","ae"};
//		Arrays.sort(s);
//		System.out.println(lastWordLength("hello world jav   "));
		// System.out.println(Arrays.toString(plusOneOptimized(new int[] {9,9,})));
		// System.out.println(isPolindrom("5?6?7?876?5"));
		// System.out.println(reverseWords("A man, a plan, a canal: Panama"));
//		System.out.println(mostOccurrance("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(mostOccurranceInString("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(replaceString("a man is one the street"));
//	System.out.println(replaceAllDigitsWithCharacter("a1b2c3"));
		// System.out.println(removeAllSubstring("aabababa","aba"));
//System.out.println(removeAllDuplicates("aabbccdeffghill"));
		// System.out.println(1%2);
//		char ch[]=new char[] {'a','a','a','b','b','a','a'};
//		int n=countLetters(ch);
//		for(int i=0;i<n;i++) {
//			System.out.print(ch[i]+",");
// 		System.out.println(System.currentTimeMillis());
//		}
//		System.out.println(Arrays.toString(mergeSorted(new int[] {1,2,3,4},3,new int[] {2,5,6},2)));
		// int arr[][] = new int[][] { { 1, 2, 3} ,{ 4, 5, 6} ,{7,8,9}};
//		printWave(arr,2,3);
		// System.out.println(reverseVowels("hello"));
//		printSprial(arr);
//		generateMatrix(5);
//		arr = rotateArray90(arr);
//		for(int i=0;i<arr.length;i++) {
//			for(int j=0;j<arr[0].length;j++)
//				System.out.print(arr[i][j]+" ");
//			System.out.println();
//		}

//		int arr []= {1,2};
		// rotateArrayWithK(arr, 3);
//		int arr[][] = {{1,2,3},{4,5,6},{7,8,9}};  
//		List<List<Integer>> shiftGrid = shiftGrid(arr, 2);
//		for(int i =0 ;i<shiftGrid.size();i++) {
//			System.out.println(shiftGrid.get(i));
//		}

//		System.out.println(maximumSumOfTwoSubStringScore("00111"));
//		System.out.println(convertArrayIn2DArray(new int[] {1,2,3,4,5,5,6,200,200}));
//	System.out.println(missingNumber(new int[] {9,6,4,2,3,5,7,0,1}));	
//		System.out.println(unique(new int[] {1,1,2,2,3,3,9}));
		// System.out.println(Arrays.toString(findErrorNums(new int[] {1,2,2,4})));
		//	kajuKatli(10);
		System.out.println(System.currentTimeMillis());
		System.out.println(minOperations("1000"));
		System.out.println(System.currentTimeMillis());
	}

	public static int minOperations(String s) {
		int count[] = new int[2];
		for(int i=0;i<s.length();i++) {
			count[s.charAt(i)-'0']++;
		}
		if(count[0]>count[1]) {
		return	(count[0]-count[1])/2;
		}
		(count[1]-count[1])/2;
		System.out.println(Arrays.toString(count));
		return 0;
	}
	
	
	public static int[] findErrorNums(int[] arr) {
		Set<Integer> value = new HashSet<>();
		int[] ar = new int[2];
		for (int i = 0; i < arr.length; i++) {
			if (value.contains(arr[i])) {
				ar[0] = arr[i];
				arr[1] = arr[i] + 1;
				System.out.println(arr[i] + 1);
				return ar;
			}
			value.add(arr[i]);
		}
		return ar;
	}

	public static int[] selectionSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			int min = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[j] < arr[min])
					min = j;
			}
			int temp = arr[i];
			arr[i] = arr[min];
			arr[min] = temp;

		}
		return arr;
	}

	public static int[] bubbleSortPr(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}

			}
		}
		return arr;
	}

	public static int unique(int arr[]) {
		int xor = 0;
		for (int i = 0; i < arr.length; i++) {
			xor ^= arr[i];
		}
		return xor;
	}

	public static int xorDuplicate(int arr[]) {

		for (int i = 0; i < arr.length; i++) {

		}
		return 0;
	}

	public static int missingNumber(int arr[]) {
		int max = findMaximum(arr);
		int total = max * (max + 1) / 2, sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return total - sum == 0 ? max + 1 : total - sum;
	}

	public static int countNumber(int arr[], int value) {
		int count = 0;

		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == value)
				count++;
			if (count > 2)
				return count;
		}
		return count;
	}

	public static int uniqueElement(int arr[]) {
		Set<Integer> value = Arrays.stream(arr).boxed().collect(Collectors.toSet());
		Iterator<Integer> iterator = value.iterator();
		while (iterator.hasNext()) {
			int va = iterator.next();
			if (count(arr, va) < 2)
				return va;
		}
		return -1;
	}

	public static int findMaximum(int arr[]) {
		int max = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] > max)
				max = arr[i];
		}
		return max;
	}

	public static List<List<Integer>> convertArrayIn2DArray(int arr[]) {
		// int max = findMaximum(arr);
		int count[] = new int[201];
		for (int i = 0; i < arr.length; i++)
			count[arr[i]]++;
//		System.out.println(Arrays.toString(count));
		int max = findMaximum(count);
		List<List<Integer>> response = new ArrayList<>();
		for (int i = 0; i < max; i++) {
			List<Integer> list = new ArrayList<>();
			for (int j = 0; j < count.length; j++) {
				if (count[j] > 0) {
					list.add(j);
					count[j]--;
				}
			}
			response.add(list);
		}

		return response;
	}

	public static int count(char arr[], int st, int end, char ch) {
		int count = 0;
		while (st <= end) {
			if (arr[st] == ch)
				count++;
			st++;
		}

		return count;
	}

	public static int maximumSumOfTwoSubStringScore(String s) {
		char[] arr = s.toCharArray();
		int i = 0, j = i + 1, max = 0;
		while (i < j && j < arr.length) {
			int cou = count(arr, i, j - 1, '0') + count(arr, j, arr.length - 1, '1');

			if (cou > max)
				max = cou;
			j++;
		}
		return max;
	}

	public static List<List<Integer>> shiftGrid(int arr[][], int k) {
		int row = arr.length, col = arr[0].length, j = row * col - 1, count = 0;
		while (count++ < k) {
			int ele = arr[arr.length - 1][arr[0].length - 1];
			for (j = row * col - 1; j > 0; j--) {
				arr[j / col][j % col] = arr[(j - 1) / col][(j - 1) % col];
			}
			arr[0][0] = ele;

		}
		List<List<Integer>> ar = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			List<Integer> ro = new ArrayList<>();
			for (j = 0; j < arr[0].length; j++) {
				ro.add(arr[i][j]);
			}
			ar.add(ro);

		}
		return ar;
	}

	public static boolean binarySearch2DInSortedRow(int arr[][], int target) {
		int row = 0, col = arr[0].length - 1;

		while (col >= 0 && row <= arr.length - 1) {
			if (arr[row][col] == target)
				return true;
			if (arr[row][col] < target)
				row++;
			else
				col--;
		}
		return false;
	}

	public static boolean binarySearchIn2D(int arr[][], int target) {
		int row = arr.length;
		int col = arr[0].length;
		int st = 0;
		int end = row * col - 1;

		while (st <= end) {
			int mid = st + (end - st) / 2;
			int element = arr[mid / col][mid % col];
			if (element == target)
				return true;
			if (element < target)
				st = mid + 1;
			else
				end = mid - 1;

		}
		return false;

	}

	public static void rotateArrayWithK(int arr[], int k) {
		int arr2[] = new int[arr.length], l = 0;
		int kIndex = arr.length - k;

		if (k >= arr.length) {
			int count = 0;
			while (count++ <= k) {
				int temp = arr[arr.length - 1];
				System.out.println(Arrays.toString(arr));
				for (int j = arr.length - 1; j > 0; j--) {
					arr[j] = arr[j - 1];
				}
				arr[0] = temp;
			}
			return;
		}

		if (kIndex < 0)
			return;
		for (int i = kIndex; i < arr.length; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < kIndex; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < arr.length; i++)
			arr[i] = arr2[i];

	}

	public static int[][] rotateArray90(int arr[][]) {
		int arr3[][] = new int[arr.length][arr[0].length], k = 0;
		for (int col = 0; col < arr[0].length; col++) {
			k = 0;
			for (int row = arr.length - 1; row >= 0; row--) {
				arr3[col][k++] = arr[row][col];
			}

		}
		return arr3;
	}

	public static int[][] generateMatrix(int n) {
		int row = n;
		int col = n;
		int total = n * n;
		int startingCol = 0;
		int startingRow = 0;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int arr[][] = new int[n][n];
		int count = 0;
		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				arr[startingRow][i] = ++count;
			}

			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				arr[i][endingCol] = ++count;
			}

			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				arr[endingRow][i] = ++count;
			}

			endingRow--;

			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				arr[i][startingCol] = ++count;
			}
			startingCol++;

		}
		return arr;
	}

	public static void printSprial(int arr[][]) {
		int startingCol = 0;
		int startingRow = 0;
		int row = arr.length;
		int col = arr[0].length;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int count = 0;
		int total = row * col;

		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				System.out.print(arr[startingRow][i]);
				count++;
			}
			System.out.println();
			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				System.out.print(arr[i][endingCol]);
				count++;
			}

			System.out.println();
			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				System.out.print(arr[endingRow][i]);
				count++;
			}

			endingRow--;
			System.out.println();
			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				System.out.print(arr[i][startingCol]);
				count++;
			}
			startingCol++;
			System.out.println();
		}
	}

	public static boolean isVowel(char ch) {
		ch = Character.toLowerCase(ch);
		if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
			return true;
		return false;
	}

	public static String reverseVowels(String s) {

		char[] arr = s.toCharArray();
		int i = 0, j = arr.length - 1;
		while (i < j) {
			if (isVowel(arr[i]) && isVowel(arr[j])) {
				char t = arr[i];
				arr[i] = arr[j];
				arr[j] = t;
				i++;
				j--;
			} else if (isVowel(arr[i]))
				j--;
			else
				i++;
		}
		return new String(arr);
	}

	public static void printWave(int arr[][], int row, int col) {
		for (int j = 0; j < col; j++) {

			for (int i = 0; i < row; i++) {
				System.out.print(arr[i][j]);
			}

			System.out.println();
			j++;
			for (int i = row - 1; i >= 0 && j < col; i--) {
				System.out.print(arr[i][j]);
			}
			System.out.println();

		}
	}

	public static int[] mergeSorted(int arr[], int m, int arr1[], int n) {
		int arr3[] = new int[m + n], i = 0, j = 0, k = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j] && n > 0) {
				arr3[k++] = arr1[j++];
				n--;
			} else if (m > 0) {
				arr3[k++] = arr[i++];
				m--;
			} else
				break;

		}
		System.out.println(Arrays.toString(arr3));
		while (m > 0 && i < arr.length) {
			arr3[k++] = arr[i++];
			m--;
		}
		while (n > 0 && j < arr1.length) {
			arr3[k++] = arr1[j++];
			n--;
		}
		return arr3;
	}

	public static List<Foodsystem> system = new ArrayList<>();

	public void enterData() {
		String food[] = { "kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi" };
		String country[] = { "korean", "japanese", "japanese", "greek", "japanese", "korean" };
		int arr[] = { 9, 12, 8, 15, 14, 7 };
		for (int i = 0; i < country.length; i++) {
			Map<String, Integer> fs = new LinkedHashMap<>();
			Foodsystem s = new Foodsystem();
			s.count = country[i];
			s.food.put(food[i], arr[i]);
			this.add(s);
		}
		System.out.println(system);

	}

	public void add(Foodsystem o) {
		for (int i = 0; i < this.system.size(); i++) {
			if (system.get(i).count.equals(o.count)) {
				system.get(i).food.putAll(o.food);
				return;
			}

		}
		this.system.add(o);
	}

	public void changeRating(String food, int rating) {
		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem f = system.get(i);
			if (f.food.containsKey(food)) {
				f.food.put(food, rating);
				return;
			}

		}

	}

	public String highestRating(String country) {
		String city = "";

		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem s = system.get(i);
			if (s.count.equals(country)) {
				int max = 0;
				Set<Entry<String, Integer>> entrySet = s.food.entrySet();
				System.out.println(entrySet);
				for (Entry<String, Integer> e : entrySet) {
					if (e.getValue() > max) {
						max = e.getValue();
						city = e.getKey();

					}
					if (e.getValue() == max) {
						s.food.put(e.getKey(), e.getValue());
					}
				}
			}

		}

		return city;
	}

	public static int countLetters(char[] s) {
		int k = 0;
		for (int i = 0; i < s.length;) {
			char ch = s[i];
			int j = i + 1, count = 1;

			while (j < s.length && s[j] == ch) {
				count++;
				j++;
			}
			System.out.println(ch + " " + count + " " + j);
			if (count > 1) {
				s[k++] = ch;
				for (char c : Integer.toString(count).toCharArray()) {
					if (k < s.length)
						s[k++] = c;
					else
						return k;
				}
			} else {
				s[k++] = ch;
			}
			i = j;
		}
		return k;
	}

	public static String removeAllDuplicates(String s) {
		StringBuilder sb = new StringBuilder();
		int count[] = new int[26];
		for (int i = 0; i < s.length(); i++) {
			int num = s.charAt(i) - 'a';
			count[num]++;
		}

		for (int i = 0; i < s.length(); i++) {
			if (count[(s.charAt(i) - 'a')] < 2)
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static String removeAllSubstring(String s, String part) {
		while (s.length() != 0 && s.contains(part))
			s = s.replaceFirst(part, "");

		return s;
	}

	public static String replaceAllDigitsWithCharacter(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
				sb.append((char) (s.charAt(i - 1) + (s.charAt(i) - 48)));
			else
				sb.append(s.charAt(i));
		}
		return sb.toString();

	}

	public static String replaceString(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == ' ')
				sb.append("@40");
			else
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static char mostOccurranceInString(String s) {
		int arr[] = new int[26]; // storing occurance of every letter according to index
		s = s.toLowerCase();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
				int num = s.charAt(i) - 'a';
				arr[num]++;
			}
		}

		// finding max
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < arr.length; i++) {
			if (max < arr[i]) {
				max = arr[i];
				ch = (char) i;
			}

		}
		return (char) (ch + 'a');

	}

	// brute force
	public static char mostOccurrance(String s) {
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < s.length(); i++) {
			int count = 0;
			for (int j = i + 1; j < s.length(); j++) {
				if (s.charAt(i) == s.charAt(j) && s.charAt(i) != ' ')
					count++;
			}

			if (count > max) {
				ch = s.charAt(i);
				max = count;
			}
		}
		return ch;
	}

	public static int climbStairs(int n) {

		if (n < 0)
			return 0;
		if (n == 0)
			return 1;
		return climbStairs(n - 1) + climbStairs(n - 2);
	}

	public static void reverseString(char[] ch, int st, int end) {

		while (st < end) {
			char temp = ch[st];
			ch[st] = ch[end];
			ch[end] = temp;
			st++;
			end--;
		}

	}

	public static char[] reverseWords(String s) {
		char ch[] = s.toCharArray();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ' && s.charAt(i) != ',') {
				int j = i + 1;
				for (; j < s.length(); j++) {
					if (s.charAt(j) == ' ' || s.charAt(j) == ',')
						break;
				}
				reverseString(ch, i, j - 1);
				i = j;
			}
		}
		return ch;
	}

	public static boolean isAlphaNumeric(char c) {
		if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9')
			return true;
		return false;
	}

	public static boolean isPolinromValidAlgo(String s) {
		StringBuilder b = new StringBuilder();
		// remove special characters only left alphanumeric
		for (int i = 0; i < s.length(); i++) {
			if (isAlphaNumeric(s.charAt(i)))
				b.append(s.charAt(i));

		}

		// to lower case
		String str = b.toString().toLowerCase();
		int st = 0, end = str.length() - 1;
		while (st < end) {
			if (str.charAt(st) != str.charAt(end))
				return false;
			st++;
			end--;
		}
		return true;

	}

	public static boolean isPolindrom(String s) {
		int st = 0, end = s.length() - 1;
		while (st < end) {
			if (s.charAt(st) >= '0' && s.charAt(st) <= '9') {
				if (s.charAt(end) >= '0' && s.charAt(end) <= '9') {

					if (s.charAt(st) != s.charAt(end))
						return false;
					else {
						st++;
						end--;
					}
				} else
					end--;
			} else
				st++;
		}
		return true;
	}

	// optimized
	public static int[] plusOneOptimized(int arr[]) {
		for (int i = arr.length - 1; i >= 0; i--) {
			if (arr[i] < 9) {
				arr[i]++;
				return arr;
			}
			arr[i] = 0;
		}
		arr = new int[arr.length + 1];
		arr[0] = 1;
		return arr;
	}

	// brute force
	public static int[] plusOne(int arr[]) {
		if (arr.length < 1)
			return arr;
		int carry = 1;
		for (int i = arr.length - 1; i >= 0; i--) {
			arr[i] = arr[i] + carry;
			carry = 0;
			if (arr[i] > 9) {
				arr[i] = 0;
				carry = 1;
			} else
				break;
		}

		if (carry != 0) {
			int ar[] = new int[arr.length + 1];
			ar[0] = carry;
			for (int i = 1; i < ar.length - 1; i++)
				ar[i] = arr[i];
			return ar;
		}
		return arr;
	}

	public static int countLastWordLength(String s, int index) {
		int count = 0;
		for (; index >= 0; index--) {
			if (s.charAt(index) != ' ')
				count++;
			else
				break;
		}
		return count;
	}

	public static int lastWordLength(String s) {
		for (int i = s.length() - 1; i >= 0; i--) {
			if (s.charAt(i) != ' ')
				return countLastWordLength(s, i);
		}
		return 0;
	}

	public static int firstOccurances(String s, String value) {
		if (s.contains(value)) {
			return s.indexOf(value);
		}
		return -1;
	}

	public static boolean isMatched(String s, String value) {
		if (s.length() < value.length())
			return false;
		for (int i = 0; i < value.length(); i++) {
			if (s.charAt(i) != value.charAt(i))
				return false;
		}
		return true;
	}

	public static int firstOccurance(String s, String value) {
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == value.charAt(0)) {
				if (isMatched(s.substring(i), value))
					return i;
			}
		}
		return -1;
	}

	public static int[] removeDuplicatess(int arr[]) {
		int i = 0, j = 1;
		for (i = 1; i < arr.length; i++) {
			if (arr[i - 1] != arr[i])
				arr[j++] = arr[i];
		}
		return arr;
	}

	public static int[] removeDuplicates(int arr[]) {
		Set<Integer> set = new LinkedHashSet<>();
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		return set.stream().mapToInt(i -> i).toArray();

	}

	public static String longestPrefixs(String arr[]) {
		Arrays.sort(arr);
		StringBuilder b = new StringBuilder();
		String first = arr[0];
		String last = arr[arr.length - 1];
		for (int i = 0; i < Math.min(first.length(), last.length()); i++) {
			if (first.charAt(i) != last.charAt(i))
				return b.toString();
			b.append(first.charAt(i));
		}
		return b.toString();

	}

	public static int[] twoSum2(int[] arr, int target) {
		int f = 0, l = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 1; j < arr.length; j++) {
				if (arr[i] + arr[j] == target) {
					f = i;
					l = j;
				}
			}
		}
		return new int[] { f, l };
	}

	public static Boolean arraySortedOrRotated(int arr[]) {
		int count = 0;
		for (int i = 1; i < arr.length; i++) {
			if (arr[i - 1] > arr[i])
				count++;
		}
		if (arr[0] < arr[arr.length - 1])
			count++;

		return count == 1;
	}

	// brute force
	public static Boolean isArraySortedOrRotated(int arr[]) {
		int i = 0;
		for (i = 0; i < arr.length - 1; i++) {
			if (arr[i] > arr[i + 1])
				break;

		}
		System.out.println(i + " -<");
		i++;
		for (; i < arr.length - 1; i++) {
			System.out.println("->" + i);
			if (arr[0] < arr[i] || arr[i] > arr[i + 1])
				return false;
		}
		if (i < arr.length && arr[0] < arr[i])
			return false;
		return true;
	}

	public static int findUnique(int arr[]) {
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {

			ans = ans ^ arr[i];
		}
		return ans;
	}

	public static int count(int arr[], int value) {
		int count = 0;
		for (int i = 0; i < arr.length; i++) {
			if (value == arr[i])
				count++;
		}
		return count;

	}

	public static int uniqueOccurance(int arr[]) {
		int arr1[] = new int[arr.length], k = 0;
		for (int i = 0; i < arr.length; i++) {
			if (!isPreExists(arr[i], arr, i - 1)) {

				int count = count(arr, arr[i]);
				arr1[k++] = count;
				System.out.println("count " + count);
			}
		}
		return findUniqueElement(arr1);
	}

	public static int[] reverse(int arr[], int st, int end) {
		if (end < arr.length)
			while (st < end) {
				int k = arr[st];
				arr[st++] = arr[end];
				arr[end--] = k;
			}
		return arr;
	}

	public static int[] reverseKElements(int arr[], int k) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length; i += k) {

			reverse(arr, i, i + k - 1);
		}
		System.out.println(Arrays.toString(arr));
		return arr;

	}

	public static boolean isPreExists(int value, int arr[], int k) {
		for (int i = k; i >= 0; i--) {
			if (arr[i] == value)
				return true;
		}
		return false;
	}

	public static int findUniqueElement(int arr[]) {
		System.out.println(Arrays.toString(arr));
		for (int i = 0; i < arr.length; i++) {
			int count = 0;
			if (!isPreExists(arr[i], arr, i - 1))
				for (int j = i; j < arr.length; j++) {

					if (arr[i] == arr[j])
						count++;
				}

			if (count == 1) {
				System.out.println("found " + arr[i]);

				return arr[i];
			}
		}
		return 0;
	}

	public static int[] insertionSort(int arr[]) {
		int j = 0;
		for (int i = 0; i < arr.length; i++) {
			int k = arr[i];
			for (j = i - 1; j >= 0; j--) {
				if (arr[j] < k) {
					arr[j + 1] = arr[j];
				} else
					break;
			}
			arr[j + 1] = k;
		}
		return arr;
	}

	public static int[] selectionSortRecu(int arr[], int i, int j, int min) {
		if (i >= arr.length)
			return arr;
		if (j < arr.length) {
			if (arr[min] > arr[j])
				min = j;
			return selectionSortRecu(arr, i, j + 1, min);
		}
		int k = arr[i];
		arr[i] = arr[min];
		arr[min] = k;
		return selectionSortRecu(arr, i + 1, i + 2, i + 1);
	}

	public static int[] mergeTwoSortedArray(int arr[], int arr1[]) {
		int arr3[] = new int[arr.length + arr1.length], k = 0, i = 0, j = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j]) {
				arr3[k++] = arr1[j++];

			} else {
				arr3[k++] = arr[i++];

			}
		}

		while (i < arr.length) {
			arr3[k++] = arr[i++];
		}
		while (j < arr1.length) {
			arr3[k++] = arr1[i++];
		}
		return arr3;
	}

	public static void recursionBubbleSort(int arr[], int i, int j) {
		if (i == arr.length)
			return;
		if (j < arr.length - i - 1 && arr[j] > arr[j + 1]) {

			int k = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = k;
			System.out.println(Arrays.toString(arr));
			recursionBubbleSort(arr, i, j + 1);

		} else {
			System.out.println("----- " + Arrays.toString(arr));
			recursionBubbleSort(arr, i + 1, 0);
		}

	}

	public static void bubbleSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int k = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = k;
				}

			}
		}
	}

	public static List<List<Integer>> threeSum(int arr[]) {
		int i = 0, j = 0, k = arr.length - 1;
		Set<List<Integer>> output = new HashSet<>();
		for (i = 0; i < arr.length; i++) {
			j = i + 1;
			k = arr.length - 1;
			while (j < k) {
				System.out.println(arr[i] + "->" + arr[j] + "->" + arr[k] + "=> " + (arr[i] + arr[j] + arr[k]) + " ( "
						+ i + "," + j + "," + k);
				if (arr[i] + arr[j] + arr[k] == 0) {
					List<Integer> list = new ArrayList<>();
					list.add(arr[i]);
					list.add(arr[j]);

					list.add(arr[k]);
					output.add(list);
				} else if (arr[i] + arr[j] + arr[k] > 0) {
					k--;
					j--;
				}
				j++;

			}
		}

		return output.stream().toList();

	}

	public static String longestPrefix(String s[]) {

		String prefix = "";

		for (int i = 0; i < s.length; i++) {
			for (int j = i + 1; j < s.length; j++) {
				if (s[i].length() > s[j].length()) {
					String temp = s[i];
					s[i] = s[j];
					s[j] = temp;
				}
			}
		}

		String st = s[0];
		boolean isMatched = false;
		for (int j = 0; j < st.length(); j++) {
			char ch = st.charAt(j);

			for (int k = 1; k < s.length; k++) {
				isMatched = false;

				if (ch == s[k].charAt(j)) {
					isMatched = true;
				} else
					break;
			}
			if (isMatched)
				prefix += ch;
			else
				break;

		}
		;
		return prefix;

	}

	public static String nonRepeatingChar(String s) {
		for (int i = 0; i < s.length(); i++) {
			boolean isPresent = false;
			for (int j = 0; j < s.length(); j++) {
				if (i != j && s.charAt(i) == s.charAt(j)) {
					isPresent = true;
					break;
				}
			}
			if (!isPresent) {
				return s.charAt(i) + "";
			}
		}
		return "All Are repated";
	}

	public static Integer romanToInteger(String s) {
		int num = 0;
		Map<String, Integer> romans = new HashMap<>();
		romans.put("M", 1000);
		romans.put("CM", 900);
		romans.put("D", 500);
		romans.put("CD", 400);
		romans.put("C", 100);
		romans.put("XC", 90);
		romans.put("L", 50);
		romans.put("XL", 40);
		romans.put("X", 10);
		romans.put("IX", 9);
		romans.put("V", 5);
		romans.put("IV", 4);
		romans.put("I", 1);
//System.out.println(romans.get("M"));
		if (s.length() < 2)
			return romans.get(s.charAt(0) + "");
		for (int i = 0; i < s.length() - 1; i++) {

			if (romans.get(s.charAt(i) + "").intValue() >= romans.get(s.charAt(i + 1) + "").intValue()) {
				num += romans.get(s.charAt(i) + "");
				System.out.println("num -> " + num);
			} else {

				int sum = romans.get(s.charAt(i + 1) + "") - romans.get(s.charAt(i) + "");
				System.out.println("num    => " + num + "  sum => " + sum);
				num += sum;
				i++;
				System.out.println("--------- " + num);
			}
			if (i == s.length() - 2)
				if (romans.get(s.charAt(i + 1) + "").intValue() <= romans.get(s.charAt(i) + "").intValue()) {
					num += romans.get(s.charAt(i + 1) + "");

				}
		}
		return num;
	}

	public static String integerToRoman(int num) {
		Integer number[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
		String romans[] = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };
		String result = "";
		for (int i = 0; i < number.length; i++) {

			while (num >= number[i]) {
				num -= number[i];
				result += romans[i];
			}
		}
		return result;

	}

	public static int convertToInteger(String s) {
		String st = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {
				st += s.charAt(i);
			} else if (s.charAt(i) == '-')
				st += s.charAt(i);
		}
		System.out.println(Integer.parseInt(st));
		return 0;
	}

	public static int reverserInteger(int n) {
		int rev = 0;
		while (n != 0) {
			int r = n % 10;
			n /= 10;
			rev = rev * 10 + r;
		}
		System.out.println(rev);
		return 0;
	}

	public static int[] mergeSortedArrays(int a1[], int a2[]) {
		int a3[] = new int[a1.length + a2.length], j = 0, k = 0, i = 0;

		Stack<Character> stack = new Stack();
		String s = "a";
		Character c = s.charAt(i);
		System.out.println(c.equals(c));

		while (i < a1.length && j < a2.length) {

			if (a1[i] >= a2[j])
				a3[k++] = a2[j++];
			else
				a3[k++] = a1[i++];

		}
		while (i < a1.length)
			a3[k++] = a1[i++];

		while (j < a2.length)
			a3[k++] = a2[j++];

		return a3;

	}

	public static int[] insertInSortedArray(int arr[], int value) {
		int temp[] = new int[arr.length + 1], j = 0;
		boolean isInserted = false;
		for (int i = 0; i < arr.length; i++) {

			if (!isInserted && arr[i] > value) {
				temp[j++] = value;
				isInserted = true;
			}
			temp[j++] = arr[i];
		}
		if (!isInserted)
			temp[j++] = value;
		return temp;
	}

	public static int[] inserAtNthPos(int arr[], int value, int pos) {
		int j = 0;
		int temp[] = new int[arr.length + 1];
		if (pos < 1)
			return arr;

		for (int i = 0; i < arr.length; i++) {
			if (i == pos - 1)
				temp[j++] = value;

			temp[j++] = arr[i];
		}
		if (pos > arr.length) {
			temp[j++] = value;
		}

//	for(int i=0;i<temp.length;i++)
//		arr[i]=temp[i];
		return temp;
	}

	public static void righRotation(int arr[], int num) {
		int n = arr.length, temp = 0, count = 0;
		while (count++ < num) {
			temp = arr[n - 1];
			for (int i = n - 1; i > 0; i--)
				arr[i] = arr[i - 1];
			arr[0] = temp;
		}

	}

	public static void leftRotation(int arr[], int num) {
		int temp[] = new int[arr.length], n = arr.length, j = 0;

		for (int i = num; i < n; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < num; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < n; i++)
			arr[i] = temp[i];
	}

	public static char[] copyArray(char[] arr) {
		if (arr == null)
			return new char[1];

		char[] a = Arrays.copyOf(arr, arr.length + 1);
		return a;
	}

	public static String zigzapConversion(String s, int num) {
		char[][] arr = new char[num][];
		int k = 0, i = 0, j = 0, t = 0;
		while (k < s.length()) {
			while (i != num - 1) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i++;
			}
			j++;
			while (i != 0) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i--;
			}
			j++;

		}
		for (char[] a : arr) {
			for (char tt : a)
				System.out.print(tt);
			System.out.println();
		}
		return "";
	}

	public static String longestPolindromSubtString(String s) {
		String ans = "";
		if (s.length() < 1)
			return s;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - 1; j >= 0; j--) {
				if (i < j) {
					String sub = s.substring(i, j + 1);
					if (sub.equals(new StringBuilder(sub).reverse().toString())) {
						if (sub.length() > ans.length()) {
							ans = sub;
						}

					}
				}
			}
		}

		return ans;
	}

	public static double medianOfTwoSortedArray(int[] arr1, int[] arr2) {

		int arr3[] = new int[arr1.length + arr2.length], i = 0, j = 0, k = 0;
		while (true) {
			if (i < arr1.length) {
				arr3[k++] = arr1[i++];
			} else if (j < arr2.length) {
				arr3[k++] = arr2[j++];
			} else
				break;

		}
		double ans = 0;
		Arrays.sort(arr3);
		System.out.println(Arrays.toString(arr3));
		if (arr3.length % 2 == 0) {
			int mid = arr3.length / 2;
			ans = (double) (arr3[mid - 1] + arr3[mid]) / 2;
			System.out.println(arr3[mid - 1]);
		} else {
			ans = arr3[arr3.length / 2];
		}

		return ans;
	}
// 4
// 1,1,1,1
// 2,1,1
// 1,1,2
// 2,2

	public static int[] twoSum(int arr[], int target) {
		int f = 0, sec = 0;
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {
				if (arr[i] + arr[j] == target && i != j) {

					f = i;
					sec = j;
				}
			}

		}
		System.out.println(f + " " + sec);
		return new int[] { f, sec };
	}

	public static char[] stringToArrayOfCharacters(String s) {
		char arr[] = new char[s.length()];
		for (int i = 0; i < s.length(); i++) {
			arr[i] = s.charAt(i);
		}
		return arr;
	}

	public static String[] textToWordsArray(String text) {
		List<String> words = new ArrayList<>();
		for (int i = 0; i < text.length(); i++) {

			for (int j = i; j < text.length() - 1; j++) {
				if (i > 0 && text.charAt(i) == ' ' && text.charAt(j + 1) == ' ' && text.charAt(i - 1) != ' ') {
					words.add(text.substring(i + 1, j + 1));
					break;
				} else if (i == 0 && text.charAt(j + 1) == ' ') {
					words.add(text.substring(i, j + 1));
					break;
				} else if (text.charAt(i) == ' ' && j + 1 == text.length() - 1) {
					words.add(text.substring(i + 1, text.length()));
					break;
				}
			}

		}
		String s[] = new String[words.size()];
		int i = 0;
		ListIterator<String> listIterator = words.listIterator();
		while (listIterator.hasNext()) {
			s[i++] = listIterator.next();
		}
		return s;
	}

	public static int wordCount(String s) {
		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0)
				count++;
			else if (s.charAt(i) == ' ')
				for (int j = i; j < s.length() - 1; j++) {
					if (s.charAt(j + 1) == ' ' && s.charAt(i - 1) != ' ') {
						count++;
						System.out.print(s.charAt(i) + " - > " + s.charAt(j) + " = " + count);
						break;
					}
				}
		}
		return count + 1;

	}

	public static void uniqueFromArrays(int arr[], int arr2[]) {

		List<Integer> list1 = List.of(1, 2, 4);
		List<Integer> list2 = List.of(1, 2, 3, 5);
		List<Integer> unique = new ArrayList<>();
		unique.addAll(list1);
		unique.addAll(list2);
		unique = unique.stream().distinct()
				.filter(a -> list1.contains(a) && !list2.contains(a) || !list1.contains(a) && list2.contains(a))
				.collect(Collectors.toList());
		System.out.println(unique);

		int k = 0;
		for (int i = 0; i < arr.length || k < arr2.length; i++, k++) {
			boolean a = false;
			boolean b = false;
			if (i < arr.length)
				for (int j = 0; j < arr2.length; j++) {
					if (arr[i] == arr2[j])
						a = true;
				}
			for (int j = 0; j < arr.length; j++) {
				if (arr2[k] == arr[j])
					b = true;
			}
			if (!a && i < arr.length)
				System.out.println(arr[i]);
			if (!b)
				System.out.println(arr2[k]);
		}
	}

	public static void arraySum(int arr[], int arr2[]) {
		int carry = 0, total = 0, j = 0, k = arr2.length - 1, i;
		List<Integer> sum = new ArrayList<>();

		for (i = arr.length - 1; i >= 0 && k >= 0; i--, k--) {

			total = arr[i] + arr2[k] + carry;
			carry = 0;
			if (total > 9) {
				carry = total % 10;
				total /= 10;
			}
			sum.add(total);

		}

		if (i < 0 && k >= 0) {
			for (int a = k; a >= 0; a--)
				sum.add(arr2[a]);
		}
		if (k < 0 && i >= 0) {
			for (int a = i; a >= 0; a--)
				sum.add(arr[a]);
		}
		Collections.reverse(sum);
		System.out.println(sum);
	}

	public static void arrayRightRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[arr.length - 1];
			for (j = arr.length - 1; j > 0; j--) {
				arr[j] = arr[j - 1];
			}
			count++;
			arr[0] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static void arrayLeftRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[0];
			for (j = 0; j < arr.length - 1; j++) {
				arr[j] = arr[j + 1];
			}
			count++;
			arr[j] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static boolean anagram(String s, String s1) {

		int count = 0;
		boolean b = false;
		for (int i = 0; i < s.length(); i++) {
			char ch = s.charAt(i);
			count = 0;
			b = false;
			for (int k = 0; k < s.length(); k++) {
				if (ch == s.charAt(k))
					count++;
			}

			for (int j = 0; j < s1.length(); j++) {
				if (count > 0 && ch == s1.charAt(j))
					count--;
			}
			if (count == 0)
				b = true;
		}

		System.out.println(b ? "yes" : "no");
		return b;
	}

	public static int count(int i, int arr[]) {
		int count = 0;
		for (int a : arr) {
			if (a == i)
				count++;
		}
		System.out.println(count);
		return count;
	}

	public static void majorityElement(int arr[]) {
		int max = 0, count = 0;
		for (int i = 0; i < arr.length; i++) {
			count = count(arr[i], arr);
			if (count >= max && count > arr.length / 2)
				max = arr[i];

		}
		System.out.println(max);
	}

	public static void longestPolindrom(String s) {

		int first = 0, last = s.length() - 1, max = 0;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - i; j >= 0; j--) {
				if (i < j && j < s.length())
					if (checkPolindrom(i, j + 1, s) && max < s.substring(i, j).length()) {

						max = s.substring(i, j + 1).length();
						first = i;
						last = j + 1;
					}
			}
			System.out.println("------");

		}
		System.out.println(s.substring(first, last));

	}

	public static boolean checkPolindrom(int f, int l, String s) {
		String st = s.substring(f, l);
		System.out.println(st + "444");
		return st.equals(new StringBuffer(st).reverse().toString());

	}

	public void spiralMatrix() throws ClassNotFoundException, NoSuchMethodException, SecurityException,
			InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		int a[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };
		int j = 0, k = 0, count = 0, max = 10 - 1;
		// int max=a.length*a.length-1;
		// System.out.println(a.length);

		for (int i = 0; i < a.length - i; i++) {

			if (count == max)
				break;

			for (j = i; j < a.length - i && count <= max; j++) {
				count++;
				System.out.println(a[k][j]);
			}
			j--;

			k++;
			while (k < a.length - i && count <= max) {
				System.out.println(a[k][j]);
				k++;
				count++;
			}
			k--;
			j--;

			while (j >= 0 && count <= max) {
				count++;
				System.out.println(a[k][j--]);
			}

			// k=i+1;
			if (k == a.length / 2 && j == a.length / 2)
				break;
			j++;
			while (k > i + 1 && count <= max) {
				System.out.println(a[--k][j]);
				count++;
			}

			k = i + 1;
			System.out.println("-----------------");
		}

	}

	public static ArrayList<Integer> findIndexes(int arr[], int sum) {
		boolean a = false;
		int f = 0, l = arr.length, s = 0;
		for (int i = 0; i < arr.length; i++) {
			s = 0;
			if (a)
				break;

			for (int j = i; j < arr.length; j++) {
				s += arr[j];
				if (s == sum) {
					f = i;
					l = j;
					a = true;
					break;
				}

			}
			System.out.println(s);
		}

		return a ? new ArrayList<Integer>(Arrays.asList(f, l)) : new ArrayList<Integer>(Arrays.asList(-1));
	}

	public int count(char a, String s) {
		class A {
			static int a;

			public void main() {
				System.out.println("hello");
			}
		}

		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == a)
				count++;
		}
		return count;
	}

	public static boolean isPresent(char a, int indx, String s) {
		for (int i = indx; i >= 0; i--) {
			if (s.charAt(i) == a)
				return true;
		}
		return false;
	}

	public static boolean isPresent(int a, int indx, int ar[]) {
		for (int i = indx; i >= 0; i--) {
			if (ar[i] == a)
				return true;
		}
		return false;
	}

	public static void fibonacci(int t1, int t2, int n) {
		if (n == 0)
			return;
		else {
			int t3 = t1 + t2;
			t1 = t2;
			t2 = t3;
			System.out.println(t3);
			fibonacci(t1, t2, n - 1);
		}

	}

	public static int factorial(int n) {
		if (n == 1)
			return 1;
		else
			n = n * factorial(n - 1);
		return n;

	}

	public static String removeSpaces(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ')
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static int[] removeDuplicate(int[] a) {
		int arr[] = new int[a.length];
		int j = 0;
		for (int i = 0; i < a.length; i++) {
			if (!isPresent(a[i], i - 1, a))
				arr[j++] = a[i];
		}
		a = new int[j];
		System.out.println(j);
		for (int i = 0; i < j; i++)
			a[i] = arr[i];
		return a;
	}

	class C {
		static int a;
	}
}

class B {
	int a = 10;

	public String toString() {
		System.out.println("askfjal");
		return new String(this.a + "");
	}

	public void hello(int... a) {

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-12-24 23:21:08.921
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-12-24 23:21:08.922
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-12-24 23:21:10.352
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.pract;

import java.lang.reflect.InvocationTargetException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.springframework.jdbc.core.metadata.OracleCallMetaDataProvider;

interface DD {

}

class AB implements Comparable<AB> {
	int id = 0;
	String name = "rohit";

	@Override
	public int compareTo(AB o) {
		if (this.id < o.id)
			return 1;

		return -1;
	}

	@Override
	public String toString() {
		return "AB [id=" + id + ", name=" + name + "]";
	}

}

abstract class kd {

}

class Foodsystem {
	public String count;
	public Map<String, Integer> food = new LinkedHashMap<>();

	public String toString() {
		return count + " =" + food;
	}

}

public class Test {

	public Test(int a) {

	}

	public static void main(String[] args) throws Exception {
		// fibonacci(0,1,20);
		// Class<?> clas = Class.forName("com.pract.Test");

		// Constructor<?> to = clas.getConstructor(int.class);
		// Test t = (Test) to.newInstance();
		var a = new Test(8);

		// System.out.println(Integer.toBinaryString(2));

		// new Random().ints(1,999).limit(20).sorted().forEach(System.out::println);
		// List<Integer> list = List.of(1,2,3,4,5);
		// System.out.println(list.stream().mapToInt(v->v).max().getAsInt());
		// list.stream().max(Integer::compare);

//		
//		longestPolindrom("bcac");
//	
//	majorityElement(new  int []{1,2,3,4,5,5});
//		
//	anagram("abcda","bcdaa");
//	String sp="TEST@$QWES 89";
//	sp = sp.replaceAll("\\d+","");
//	System.out.println(sp);

//arrayLeftRotation(new int[] {1,2,3,4,5},4);
//arrayRightRotation(new int[] {1,2,3,4,5},2);
//arraySum(new int[] {1,2,3,4},new int[] {1,2,3});
//uniqueFromArrays(new int[] {1,2,4},new int[] {1,2,3,5});
//wordCount("Hello what are you doing here you fucking bitch bastard");
//String s[]=textToWordsArray("Hello what are you doing here you fucking bitch bastard ab bcd");

//char arr[]=stringToArrayOfCharacters("hello what");

//twoSum(new int[] {2,7,11,15},9);
//		System.out.println(medianOfTwoSortedArray(new int[] {3},new int[] {-2,-1}));
//		System.out.println(longestPolindromSubtString("cbbd"));
		// zigzapConversion("PAYPALISHIRING",4);
//		Date d = new Date();
//		SimpleDateFormat f = new SimpleDateFormat("dd/MM/yyyy");
//		Date parse = f.parse("12/9/2023");
//		//LocalDate.now().
//		LocalDate l = LocalDate.now();
//		LocalDate l2 = LocalDate.of(2024, 10, 11);
//		Period period = Period.between(l, l2);
//		period.between(l, l2);
//		DayOfWeek dayOfWeek = l2.getDayOfWeek();
//		System.out.println(dayOfWeek.toString());

//		int arr[] = new int[] { 1, 2, 4 };
//		int arr2[] = new int[] { 1, 3, 4 };
		// righRotation(arr, 2);
//inserAtNthPos(arr,3,3);

//arr=insertInSortedArray(arr,6);
//System.out.println(2%5);
//arr=mergeSortedArrays(arr,arr2);
//System.out.println(Arrays.toString(arr))
		// reverserInteger(-1234);
//convertToInteger("  -1234");

		// AB.main(new String[] {"a","b"});
		// AB ab = new AB();
//		ab.hello();
//Comparator<Integer> com = new Comparator<Integer>() {
//
//	@Override
//	public int compare(Integer o1, Integer o2) {
//	   
//		return o1.intValue()>o2.intValue()?o2:o1;
//	}
//	
//};
//com = (c,b) -> c<b?1:-1;
//
//TreeSet<AB>  t = new TreeSet<>(); 
//		AB a1 = new AB();
//		a1.id=10;
//		AB a2 = new AB();
//		a2.id=20;
//		AB a3 = new AB();
//		a3.id=30;
//		AB a4 = new AB();
//		a4.id=40;
//		AB a5 = new AB();
//		a5.id=50;
//		
//		t.add(a1);
//		t.add(a2);
//		t.add(a3);
//		t.add(a4);
//		t.add(a5);
//		System.out.println(t);
		// System.out.println(integerToRoman(400));
		// System.out.println(romanToInteger("D"));
		// System.out.println(nonRepeatingChar("abcabc"));
		// System.out.println(longestPrefix(new String[] {"flow","flowight","flower"}));
//		int arr1[] = { 10, 8, 7, 5, 4, 11, 78 };
//		int arr3[] = { -1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4 };
//		Arrays.sort(arr3);
		// System.out.println(threeSum(arr3));
//		recursionBubbleSort(arr1,0,0);
//		System.out.println(Arrays.toString(arr1));
//		List.of(arr);

//		System.out.println(Arrays.toString(mergeTwoSortedArray(new int[] {1,3,5,7,9},new int[] {2,4,6,7,8})));
//		System.out.println(Arrays.toString(selectionSortRecu(new int[] {7,9,4,3,2,1,54,3},0,1,0)));

//		System.out.println(Arrays.toString(insertionSort(new int[] {9,8,6,5,4,3,5})));
		// System.out.println(uniqueOccurance(new int[] {1,1,1,2,2,2,3,4,4,5,4,5}));;
//		System.out.println(reverseKElements(new int[] {1,2,3,4,5,6,7,8,9},2));

		// System.out.println(isArraySortedOrRotated(new int[] {5,6,7,8,1}));
		// System.out.println(Arrays.toString(twoSum2(new int[] {2 ,7,8,5,2,1},9)));
		// System.out.println(longestPrefixs(new String[] {"ab","aba","ad"}));
		// System.out.println(Arrays.toString(removeDuplicatess(new int[]
		// {1,1,2,2,3,4,4,5,55,5})));
		// System.out.println(firstOccurances("hadbadhad","had"));
		// String s[]= {"aaa","aec","adc","ae"};
//		Arrays.sort(s);
//		System.out.println(lastWordLength("hello world jav   "));
		// System.out.println(Arrays.toString(plusOneOptimized(new int[] {9,9,})));
		// System.out.println(isPolindrom("5?6?7?876?5"));
		// System.out.println(reverseWords("A man, a plan, a canal: Panama"));
//		System.out.println(mostOccurrance("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(mostOccurranceInString("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(replaceString("a man is one the street"));
//	System.out.println(replaceAllDigitsWithCharacter("a1b2c3"));
		// System.out.println(removeAllSubstring("aabababa","aba"));
//System.out.println(removeAllDuplicates("aabbccdeffghill"));
		// System.out.println(1%2);
//		char ch[]=new char[] {'a','a','a','b','b','a','a'};
//		int n=countLetters(ch);
//		for(int i=0;i<n;i++) {
//			System.out.print(ch[i]+",");
// 		System.out.println(System.currentTimeMillis());
//		}
//		System.out.println(Arrays.toString(mergeSorted(new int[] {1,2,3,4},3,new int[] {2,5,6},2)));
		// int arr[][] = new int[][] { { 1, 2, 3} ,{ 4, 5, 6} ,{7,8,9}};
//		printWave(arr,2,3);
		// System.out.println(reverseVowels("hello"));
//		printSprial(arr);
//		generateMatrix(5);
//		arr = rotateArray90(arr);
//		for(int i=0;i<arr.length;i++) {
//			for(int j=0;j<arr[0].length;j++)
//				System.out.print(arr[i][j]+" ");
//			System.out.println();
//		}

//		int arr []= {1,2};
		// rotateArrayWithK(arr, 3);
//		int arr[][] = {{1,2,3},{4,5,6},{7,8,9}};  
//		List<List<Integer>> shiftGrid = shiftGrid(arr, 2);
//		for(int i =0 ;i<shiftGrid.size();i++) {
//			System.out.println(shiftGrid.get(i));
//		}

//		System.out.println(maximumSumOfTwoSubStringScore("00111"));
//		System.out.println(convertArrayIn2DArray(new int[] {1,2,3,4,5,5,6,200,200}));
//	System.out.println(missingNumber(new int[] {9,6,4,2,3,5,7,0,1}));	
//		System.out.println(unique(new int[] {1,1,2,2,3,3,9}));
		// System.out.println(Arrays.toString(findErrorNums(new int[] {1,2,2,4})));
		//	kajuKatli(10);
		System.out.println(System.currentTimeMillis());
		System.out.println(minOperations("1000"));
		System.out.println(System.currentTimeMillis());
	}

	public static int minOperations(String s) {
		int count[] = new int[2];
		for(int i=0;i<s.length();i++) {
			count[s.charAt(i)-'0']++;
		}
		if(count[0]>count[1]) {
		return	(count[0]-count[1])/2;
		}
		(count[1]-count[0])/2;
		System.out.println(Arrays.toString(count));
		return 0;
	}
	
	
	public static int[] findErrorNums(int[] arr) {
		Set<Integer> value = new HashSet<>();
		int[] ar = new int[2];
		for (int i = 0; i < arr.length; i++) {
			if (value.contains(arr[i])) {
				ar[0] = arr[i];
				arr[1] = arr[i] + 1;
				System.out.println(arr[i] + 1);
				return ar;
			}
			value.add(arr[i]);
		}
		return ar;
	}

	public static int[] selectionSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			int min = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[j] < arr[min])
					min = j;
			}
			int temp = arr[i];
			arr[i] = arr[min];
			arr[min] = temp;

		}
		return arr;
	}

	public static int[] bubbleSortPr(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}

			}
		}
		return arr;
	}

	public static int unique(int arr[]) {
		int xor = 0;
		for (int i = 0; i < arr.length; i++) {
			xor ^= arr[i];
		}
		return xor;
	}

	public static int xorDuplicate(int arr[]) {

		for (int i = 0; i < arr.length; i++) {

		}
		return 0;
	}

	public static int missingNumber(int arr[]) {
		int max = findMaximum(arr);
		int total = max * (max + 1) / 2, sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return total - sum == 0 ? max + 1 : total - sum;
	}

	public static int countNumber(int arr[], int value) {
		int count = 0;

		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == value)
				count++;
			if (count > 2)
				return count;
		}
		return count;
	}

	public static int uniqueElement(int arr[]) {
		Set<Integer> value = Arrays.stream(arr).boxed().collect(Collectors.toSet());
		Iterator<Integer> iterator = value.iterator();
		while (iterator.hasNext()) {
			int va = iterator.next();
			if (count(arr, va) < 2)
				return va;
		}
		return -1;
	}

	public static int findMaximum(int arr[]) {
		int max = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] > max)
				max = arr[i];
		}
		return max;
	}

	public static List<List<Integer>> convertArrayIn2DArray(int arr[]) {
		// int max = findMaximum(arr);
		int count[] = new int[201];
		for (int i = 0; i < arr.length; i++)
			count[arr[i]]++;
//		System.out.println(Arrays.toString(count));
		int max = findMaximum(count);
		List<List<Integer>> response = new ArrayList<>();
		for (int i = 0; i < max; i++) {
			List<Integer> list = new ArrayList<>();
			for (int j = 0; j < count.length; j++) {
				if (count[j] > 0) {
					list.add(j);
					count[j]--;
				}
			}
			response.add(list);
		}

		return response;
	}

	public static int count(char arr[], int st, int end, char ch) {
		int count = 0;
		while (st <= end) {
			if (arr[st] == ch)
				count++;
			st++;
		}

		return count;
	}

	public static int maximumSumOfTwoSubStringScore(String s) {
		char[] arr = s.toCharArray();
		int i = 0, j = i + 1, max = 0;
		while (i < j && j < arr.length) {
			int cou = count(arr, i, j - 1, '0') + count(arr, j, arr.length - 1, '1');

			if (cou > max)
				max = cou;
			j++;
		}
		return max;
	}

	public static List<List<Integer>> shiftGrid(int arr[][], int k) {
		int row = arr.length, col = arr[0].length, j = row * col - 1, count = 0;
		while (count++ < k) {
			int ele = arr[arr.length - 1][arr[0].length - 1];
			for (j = row * col - 1; j > 0; j--) {
				arr[j / col][j % col] = arr[(j - 1) / col][(j - 1) % col];
			}
			arr[0][0] = ele;

		}
		List<List<Integer>> ar = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			List<Integer> ro = new ArrayList<>();
			for (j = 0; j < arr[0].length; j++) {
				ro.add(arr[i][j]);
			}
			ar.add(ro);

		}
		return ar;
	}

	public static boolean binarySearch2DInSortedRow(int arr[][], int target) {
		int row = 0, col = arr[0].length - 1;

		while (col >= 0 && row <= arr.length - 1) {
			if (arr[row][col] == target)
				return true;
			if (arr[row][col] < target)
				row++;
			else
				col--;
		}
		return false;
	}

	public static boolean binarySearchIn2D(int arr[][], int target) {
		int row = arr.length;
		int col = arr[0].length;
		int st = 0;
		int end = row * col - 1;

		while (st <= end) {
			int mid = st + (end - st) / 2;
			int element = arr[mid / col][mid % col];
			if (element == target)
				return true;
			if (element < target)
				st = mid + 1;
			else
				end = mid - 1;

		}
		return false;

	}

	public static void rotateArrayWithK(int arr[], int k) {
		int arr2[] = new int[arr.length], l = 0;
		int kIndex = arr.length - k;

		if (k >= arr.length) {
			int count = 0;
			while (count++ <= k) {
				int temp = arr[arr.length - 1];
				System.out.println(Arrays.toString(arr));
				for (int j = arr.length - 1; j > 0; j--) {
					arr[j] = arr[j - 1];
				}
				arr[0] = temp;
			}
			return;
		}

		if (kIndex < 0)
			return;
		for (int i = kIndex; i < arr.length; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < kIndex; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < arr.length; i++)
			arr[i] = arr2[i];

	}

	public static int[][] rotateArray90(int arr[][]) {
		int arr3[][] = new int[arr.length][arr[0].length], k = 0;
		for (int col = 0; col < arr[0].length; col++) {
			k = 0;
			for (int row = arr.length - 1; row >= 0; row--) {
				arr3[col][k++] = arr[row][col];
			}

		}
		return arr3;
	}

	public static int[][] generateMatrix(int n) {
		int row = n;
		int col = n;
		int total = n * n;
		int startingCol = 0;
		int startingRow = 0;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int arr[][] = new int[n][n];
		int count = 0;
		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				arr[startingRow][i] = ++count;
			}

			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				arr[i][endingCol] = ++count;
			}

			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				arr[endingRow][i] = ++count;
			}

			endingRow--;

			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				arr[i][startingCol] = ++count;
			}
			startingCol++;

		}
		return arr;
	}

	public static void printSprial(int arr[][]) {
		int startingCol = 0;
		int startingRow = 0;
		int row = arr.length;
		int col = arr[0].length;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int count = 0;
		int total = row * col;

		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				System.out.print(arr[startingRow][i]);
				count++;
			}
			System.out.println();
			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				System.out.print(arr[i][endingCol]);
				count++;
			}

			System.out.println();
			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				System.out.print(arr[endingRow][i]);
				count++;
			}

			endingRow--;
			System.out.println();
			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				System.out.print(arr[i][startingCol]);
				count++;
			}
			startingCol++;
			System.out.println();
		}
	}

	public static boolean isVowel(char ch) {
		ch = Character.toLowerCase(ch);
		if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
			return true;
		return false;
	}

	public static String reverseVowels(String s) {

		char[] arr = s.toCharArray();
		int i = 0, j = arr.length - 1;
		while (i < j) {
			if (isVowel(arr[i]) && isVowel(arr[j])) {
				char t = arr[i];
				arr[i] = arr[j];
				arr[j] = t;
				i++;
				j--;
			} else if (isVowel(arr[i]))
				j--;
			else
				i++;
		}
		return new String(arr);
	}

	public static void printWave(int arr[][], int row, int col) {
		for (int j = 0; j < col; j++) {

			for (int i = 0; i < row; i++) {
				System.out.print(arr[i][j]);
			}

			System.out.println();
			j++;
			for (int i = row - 1; i >= 0 && j < col; i--) {
				System.out.print(arr[i][j]);
			}
			System.out.println();

		}
	}

	public static int[] mergeSorted(int arr[], int m, int arr1[], int n) {
		int arr3[] = new int[m + n], i = 0, j = 0, k = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j] && n > 0) {
				arr3[k++] = arr1[j++];
				n--;
			} else if (m > 0) {
				arr3[k++] = arr[i++];
				m--;
			} else
				break;

		}
		System.out.println(Arrays.toString(arr3));
		while (m > 0 && i < arr.length) {
			arr3[k++] = arr[i++];
			m--;
		}
		while (n > 0 && j < arr1.length) {
			arr3[k++] = arr1[j++];
			n--;
		}
		return arr3;
	}

	public static List<Foodsystem> system = new ArrayList<>();

	public void enterData() {
		String food[] = { "kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi" };
		String country[] = { "korean", "japanese", "japanese", "greek", "japanese", "korean" };
		int arr[] = { 9, 12, 8, 15, 14, 7 };
		for (int i = 0; i < country.length; i++) {
			Map<String, Integer> fs = new LinkedHashMap<>();
			Foodsystem s = new Foodsystem();
			s.count = country[i];
			s.food.put(food[i], arr[i]);
			this.add(s);
		}
		System.out.println(system);

	}

	public void add(Foodsystem o) {
		for (int i = 0; i < this.system.size(); i++) {
			if (system.get(i).count.equals(o.count)) {
				system.get(i).food.putAll(o.food);
				return;
			}

		}
		this.system.add(o);
	}

	public void changeRating(String food, int rating) {
		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem f = system.get(i);
			if (f.food.containsKey(food)) {
				f.food.put(food, rating);
				return;
			}

		}

	}

	public String highestRating(String country) {
		String city = "";

		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem s = system.get(i);
			if (s.count.equals(country)) {
				int max = 0;
				Set<Entry<String, Integer>> entrySet = s.food.entrySet();
				System.out.println(entrySet);
				for (Entry<String, Integer> e : entrySet) {
					if (e.getValue() > max) {
						max = e.getValue();
						city = e.getKey();

					}
					if (e.getValue() == max) {
						s.food.put(e.getKey(), e.getValue());
					}
				}
			}

		}

		return city;
	}

	public static int countLetters(char[] s) {
		int k = 0;
		for (int i = 0; i < s.length;) {
			char ch = s[i];
			int j = i + 1, count = 1;

			while (j < s.length && s[j] == ch) {
				count++;
				j++;
			}
			System.out.println(ch + " " + count + " " + j);
			if (count > 1) {
				s[k++] = ch;
				for (char c : Integer.toString(count).toCharArray()) {
					if (k < s.length)
						s[k++] = c;
					else
						return k;
				}
			} else {
				s[k++] = ch;
			}
			i = j;
		}
		return k;
	}

	public static String removeAllDuplicates(String s) {
		StringBuilder sb = new StringBuilder();
		int count[] = new int[26];
		for (int i = 0; i < s.length(); i++) {
			int num = s.charAt(i) - 'a';
			count[num]++;
		}

		for (int i = 0; i < s.length(); i++) {
			if (count[(s.charAt(i) - 'a')] < 2)
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static String removeAllSubstring(String s, String part) {
		while (s.length() != 0 && s.contains(part))
			s = s.replaceFirst(part, "");

		return s;
	}

	public static String replaceAllDigitsWithCharacter(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
				sb.append((char) (s.charAt(i - 1) + (s.charAt(i) - 48)));
			else
				sb.append(s.charAt(i));
		}
		return sb.toString();

	}

	public static String replaceString(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == ' ')
				sb.append("@40");
			else
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static char mostOccurranceInString(String s) {
		int arr[] = new int[26]; // storing occurance of every letter according to index
		s = s.toLowerCase();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
				int num = s.charAt(i) - 'a';
				arr[num]++;
			}
		}

		// finding max
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < arr.length; i++) {
			if (max < arr[i]) {
				max = arr[i];
				ch = (char) i;
			}

		}
		return (char) (ch + 'a');

	}

	// brute force
	public static char mostOccurrance(String s) {
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < s.length(); i++) {
			int count = 0;
			for (int j = i + 1; j < s.length(); j++) {
				if (s.charAt(i) == s.charAt(j) && s.charAt(i) != ' ')
					count++;
			}

			if (count > max) {
				ch = s.charAt(i);
				max = count;
			}
		}
		return ch;
	}

	public static int climbStairs(int n) {

		if (n < 0)
			return 0;
		if (n == 0)
			return 1;
		return climbStairs(n - 1) + climbStairs(n - 2);
	}

	public static void reverseString(char[] ch, int st, int end) {

		while (st < end) {
			char temp = ch[st];
			ch[st] = ch[end];
			ch[end] = temp;
			st++;
			end--;
		}

	}

	public static char[] reverseWords(String s) {
		char ch[] = s.toCharArray();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ' && s.charAt(i) != ',') {
				int j = i + 1;
				for (; j < s.length(); j++) {
					if (s.charAt(j) == ' ' || s.charAt(j) == ',')
						break;
				}
				reverseString(ch, i, j - 1);
				i = j;
			}
		}
		return ch;
	}

	public static boolean isAlphaNumeric(char c) {
		if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9')
			return true;
		return false;
	}

	public static boolean isPolinromValidAlgo(String s) {
		StringBuilder b = new StringBuilder();
		// remove special characters only left alphanumeric
		for (int i = 0; i < s.length(); i++) {
			if (isAlphaNumeric(s.charAt(i)))
				b.append(s.charAt(i));

		}

		// to lower case
		String str = b.toString().toLowerCase();
		int st = 0, end = str.length() - 1;
		while (st < end) {
			if (str.charAt(st) != str.charAt(end))
				return false;
			st++;
			end--;
		}
		return true;

	}

	public static boolean isPolindrom(String s) {
		int st = 0, end = s.length() - 1;
		while (st < end) {
			if (s.charAt(st) >= '0' && s.charAt(st) <= '9') {
				if (s.charAt(end) >= '0' && s.charAt(end) <= '9') {

					if (s.charAt(st) != s.charAt(end))
						return false;
					else {
						st++;
						end--;
					}
				} else
					end--;
			} else
				st++;
		}
		return true;
	}

	// optimized
	public static int[] plusOneOptimized(int arr[]) {
		for (int i = arr.length - 1; i >= 0; i--) {
			if (arr[i] < 9) {
				arr[i]++;
				return arr;
			}
			arr[i] = 0;
		}
		arr = new int[arr.length + 1];
		arr[0] = 1;
		return arr;
	}

	// brute force
	public static int[] plusOne(int arr[]) {
		if (arr.length < 1)
			return arr;
		int carry = 1;
		for (int i = arr.length - 1; i >= 0; i--) {
			arr[i] = arr[i] + carry;
			carry = 0;
			if (arr[i] > 9) {
				arr[i] = 0;
				carry = 1;
			} else
				break;
		}

		if (carry != 0) {
			int ar[] = new int[arr.length + 1];
			ar[0] = carry;
			for (int i = 1; i < ar.length - 1; i++)
				ar[i] = arr[i];
			return ar;
		}
		return arr;
	}

	public static int countLastWordLength(String s, int index) {
		int count = 0;
		for (; index >= 0; index--) {
			if (s.charAt(index) != ' ')
				count++;
			else
				break;
		}
		return count;
	}

	public static int lastWordLength(String s) {
		for (int i = s.length() - 1; i >= 0; i--) {
			if (s.charAt(i) != ' ')
				return countLastWordLength(s, i);
		}
		return 0;
	}

	public static int firstOccurances(String s, String value) {
		if (s.contains(value)) {
			return s.indexOf(value);
		}
		return -1;
	}

	public static boolean isMatched(String s, String value) {
		if (s.length() < value.length())
			return false;
		for (int i = 0; i < value.length(); i++) {
			if (s.charAt(i) != value.charAt(i))
				return false;
		}
		return true;
	}

	public static int firstOccurance(String s, String value) {
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == value.charAt(0)) {
				if (isMatched(s.substring(i), value))
					return i;
			}
		}
		return -1;
	}

	public static int[] removeDuplicatess(int arr[]) {
		int i = 0, j = 1;
		for (i = 1; i < arr.length; i++) {
			if (arr[i - 1] != arr[i])
				arr[j++] = arr[i];
		}
		return arr;
	}

	public static int[] removeDuplicates(int arr[]) {
		Set<Integer> set = new LinkedHashSet<>();
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		return set.stream().mapToInt(i -> i).toArray();

	}

	public static String longestPrefixs(String arr[]) {
		Arrays.sort(arr);
		StringBuilder b = new StringBuilder();
		String first = arr[0];
		String last = arr[arr.length - 1];
		for (int i = 0; i < Math.min(first.length(), last.length()); i++) {
			if (first.charAt(i) != last.charAt(i))
				return b.toString();
			b.append(first.charAt(i));
		}
		return b.toString();

	}

	public static int[] twoSum2(int[] arr, int target) {
		int f = 0, l = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 1; j < arr.length; j++) {
				if (arr[i] + arr[j] == target) {
					f = i;
					l = j;
				}
			}
		}
		return new int[] { f, l };
	}

	public static Boolean arraySortedOrRotated(int arr[]) {
		int count = 0;
		for (int i = 1; i < arr.length; i++) {
			if (arr[i - 1] > arr[i])
				count++;
		}
		if (arr[0] < arr[arr.length - 1])
			count++;

		return count == 1;
	}

	// brute force
	public static Boolean isArraySortedOrRotated(int arr[]) {
		int i = 0;
		for (i = 0; i < arr.length - 1; i++) {
			if (arr[i] > arr[i + 1])
				break;

		}
		System.out.println(i + " -<");
		i++;
		for (; i < arr.length - 1; i++) {
			System.out.println("->" + i);
			if (arr[0] < arr[i] || arr[i] > arr[i + 1])
				return false;
		}
		if (i < arr.length && arr[0] < arr[i])
			return false;
		return true;
	}

	public static int findUnique(int arr[]) {
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {

			ans = ans ^ arr[i];
		}
		return ans;
	}

	public static int count(int arr[], int value) {
		int count = 0;
		for (int i = 0; i < arr.length; i++) {
			if (value == arr[i])
				count++;
		}
		return count;

	}

	public static int uniqueOccurance(int arr[]) {
		int arr1[] = new int[arr.length], k = 0;
		for (int i = 0; i < arr.length; i++) {
			if (!isPreExists(arr[i], arr, i - 1)) {

				int count = count(arr, arr[i]);
				arr1[k++] = count;
				System.out.println("count " + count);
			}
		}
		return findUniqueElement(arr1);
	}

	public static int[] reverse(int arr[], int st, int end) {
		if (end < arr.length)
			while (st < end) {
				int k = arr[st];
				arr[st++] = arr[end];
				arr[end--] = k;
			}
		return arr;
	}

	public static int[] reverseKElements(int arr[], int k) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length; i += k) {

			reverse(arr, i, i + k - 1);
		}
		System.out.println(Arrays.toString(arr));
		return arr;

	}

	public static boolean isPreExists(int value, int arr[], int k) {
		for (int i = k; i >= 0; i--) {
			if (arr[i] == value)
				return true;
		}
		return false;
	}

	public static int findUniqueElement(int arr[]) {
		System.out.println(Arrays.toString(arr));
		for (int i = 0; i < arr.length; i++) {
			int count = 0;
			if (!isPreExists(arr[i], arr, i - 1))
				for (int j = i; j < arr.length; j++) {

					if (arr[i] == arr[j])
						count++;
				}

			if (count == 1) {
				System.out.println("found " + arr[i]);

				return arr[i];
			}
		}
		return 0;
	}

	public static int[] insertionSort(int arr[]) {
		int j = 0;
		for (int i = 0; i < arr.length; i++) {
			int k = arr[i];
			for (j = i - 1; j >= 0; j--) {
				if (arr[j] < k) {
					arr[j + 1] = arr[j];
				} else
					break;
			}
			arr[j + 1] = k;
		}
		return arr;
	}

	public static int[] selectionSortRecu(int arr[], int i, int j, int min) {
		if (i >= arr.length)
			return arr;
		if (j < arr.length) {
			if (arr[min] > arr[j])
				min = j;
			return selectionSortRecu(arr, i, j + 1, min);
		}
		int k = arr[i];
		arr[i] = arr[min];
		arr[min] = k;
		return selectionSortRecu(arr, i + 1, i + 2, i + 1);
	}

	public static int[] mergeTwoSortedArray(int arr[], int arr1[]) {
		int arr3[] = new int[arr.length + arr1.length], k = 0, i = 0, j = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j]) {
				arr3[k++] = arr1[j++];

			} else {
				arr3[k++] = arr[i++];

			}
		}

		while (i < arr.length) {
			arr3[k++] = arr[i++];
		}
		while (j < arr1.length) {
			arr3[k++] = arr1[i++];
		}
		return arr3;
	}

	public static void recursionBubbleSort(int arr[], int i, int j) {
		if (i == arr.length)
			return;
		if (j < arr.length - i - 1 && arr[j] > arr[j + 1]) {

			int k = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = k;
			System.out.println(Arrays.toString(arr));
			recursionBubbleSort(arr, i, j + 1);

		} else {
			System.out.println("----- " + Arrays.toString(arr));
			recursionBubbleSort(arr, i + 1, 0);
		}

	}

	public static void bubbleSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int k = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = k;
				}

			}
		}
	}

	public static List<List<Integer>> threeSum(int arr[]) {
		int i = 0, j = 0, k = arr.length - 1;
		Set<List<Integer>> output = new HashSet<>();
		for (i = 0; i < arr.length; i++) {
			j = i + 1;
			k = arr.length - 1;
			while (j < k) {
				System.out.println(arr[i] + "->" + arr[j] + "->" + arr[k] + "=> " + (arr[i] + arr[j] + arr[k]) + " ( "
						+ i + "," + j + "," + k);
				if (arr[i] + arr[j] + arr[k] == 0) {
					List<Integer> list = new ArrayList<>();
					list.add(arr[i]);
					list.add(arr[j]);

					list.add(arr[k]);
					output.add(list);
				} else if (arr[i] + arr[j] + arr[k] > 0) {
					k--;
					j--;
				}
				j++;

			}
		}

		return output.stream().toList();

	}

	public static String longestPrefix(String s[]) {

		String prefix = "";

		for (int i = 0; i < s.length; i++) {
			for (int j = i + 1; j < s.length; j++) {
				if (s[i].length() > s[j].length()) {
					String temp = s[i];
					s[i] = s[j];
					s[j] = temp;
				}
			}
		}

		String st = s[0];
		boolean isMatched = false;
		for (int j = 0; j < st.length(); j++) {
			char ch = st.charAt(j);

			for (int k = 1; k < s.length; k++) {
				isMatched = false;

				if (ch == s[k].charAt(j)) {
					isMatched = true;
				} else
					break;
			}
			if (isMatched)
				prefix += ch;
			else
				break;

		}
		;
		return prefix;

	}

	public static String nonRepeatingChar(String s) {
		for (int i = 0; i < s.length(); i++) {
			boolean isPresent = false;
			for (int j = 0; j < s.length(); j++) {
				if (i != j && s.charAt(i) == s.charAt(j)) {
					isPresent = true;
					break;
				}
			}
			if (!isPresent) {
				return s.charAt(i) + "";
			}
		}
		return "All Are repated";
	}

	public static Integer romanToInteger(String s) {
		int num = 0;
		Map<String, Integer> romans = new HashMap<>();
		romans.put("M", 1000);
		romans.put("CM", 900);
		romans.put("D", 500);
		romans.put("CD", 400);
		romans.put("C", 100);
		romans.put("XC", 90);
		romans.put("L", 50);
		romans.put("XL", 40);
		romans.put("X", 10);
		romans.put("IX", 9);
		romans.put("V", 5);
		romans.put("IV", 4);
		romans.put("I", 1);
//System.out.println(romans.get("M"));
		if (s.length() < 2)
			return romans.get(s.charAt(0) + "");
		for (int i = 0; i < s.length() - 1; i++) {

			if (romans.get(s.charAt(i) + "").intValue() >= romans.get(s.charAt(i + 1) + "").intValue()) {
				num += romans.get(s.charAt(i) + "");
				System.out.println("num -> " + num);
			} else {

				int sum = romans.get(s.charAt(i + 1) + "") - romans.get(s.charAt(i) + "");
				System.out.println("num    => " + num + "  sum => " + sum);
				num += sum;
				i++;
				System.out.println("--------- " + num);
			}
			if (i == s.length() - 2)
				if (romans.get(s.charAt(i + 1) + "").intValue() <= romans.get(s.charAt(i) + "").intValue()) {
					num += romans.get(s.charAt(i + 1) + "");

				}
		}
		return num;
	}

	public static String integerToRoman(int num) {
		Integer number[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
		String romans[] = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };
		String result = "";
		for (int i = 0; i < number.length; i++) {

			while (num >= number[i]) {
				num -= number[i];
				result += romans[i];
			}
		}
		return result;

	}

	public static int convertToInteger(String s) {
		String st = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {
				st += s.charAt(i);
			} else if (s.charAt(i) == '-')
				st += s.charAt(i);
		}
		System.out.println(Integer.parseInt(st));
		return 0;
	}

	public static int reverserInteger(int n) {
		int rev = 0;
		while (n != 0) {
			int r = n % 10;
			n /= 10;
			rev = rev * 10 + r;
		}
		System.out.println(rev);
		return 0;
	}

	public static int[] mergeSortedArrays(int a1[], int a2[]) {
		int a3[] = new int[a1.length + a2.length], j = 0, k = 0, i = 0;

		Stack<Character> stack = new Stack();
		String s = "a";
		Character c = s.charAt(i);
		System.out.println(c.equals(c));

		while (i < a1.length && j < a2.length) {

			if (a1[i] >= a2[j])
				a3[k++] = a2[j++];
			else
				a3[k++] = a1[i++];

		}
		while (i < a1.length)
			a3[k++] = a1[i++];

		while (j < a2.length)
			a3[k++] = a2[j++];

		return a3;

	}

	public static int[] insertInSortedArray(int arr[], int value) {
		int temp[] = new int[arr.length + 1], j = 0;
		boolean isInserted = false;
		for (int i = 0; i < arr.length; i++) {

			if (!isInserted && arr[i] > value) {
				temp[j++] = value;
				isInserted = true;
			}
			temp[j++] = arr[i];
		}
		if (!isInserted)
			temp[j++] = value;
		return temp;
	}

	public static int[] inserAtNthPos(int arr[], int value, int pos) {
		int j = 0;
		int temp[] = new int[arr.length + 1];
		if (pos < 1)
			return arr;

		for (int i = 0; i < arr.length; i++) {
			if (i == pos - 1)
				temp[j++] = value;

			temp[j++] = arr[i];
		}
		if (pos > arr.length) {
			temp[j++] = value;
		}

//	for(int i=0;i<temp.length;i++)
//		arr[i]=temp[i];
		return temp;
	}

	public static void righRotation(int arr[], int num) {
		int n = arr.length, temp = 0, count = 0;
		while (count++ < num) {
			temp = arr[n - 1];
			for (int i = n - 1; i > 0; i--)
				arr[i] = arr[i - 1];
			arr[0] = temp;
		}

	}

	public static void leftRotation(int arr[], int num) {
		int temp[] = new int[arr.length], n = arr.length, j = 0;

		for (int i = num; i < n; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < num; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < n; i++)
			arr[i] = temp[i];
	}

	public static char[] copyArray(char[] arr) {
		if (arr == null)
			return new char[1];

		char[] a = Arrays.copyOf(arr, arr.length + 1);
		return a;
	}

	public static String zigzapConversion(String s, int num) {
		char[][] arr = new char[num][];
		int k = 0, i = 0, j = 0, t = 0;
		while (k < s.length()) {
			while (i != num - 1) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i++;
			}
			j++;
			while (i != 0) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i--;
			}
			j++;

		}
		for (char[] a : arr) {
			for (char tt : a)
				System.out.print(tt);
			System.out.println();
		}
		return "";
	}

	public static String longestPolindromSubtString(String s) {
		String ans = "";
		if (s.length() < 1)
			return s;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - 1; j >= 0; j--) {
				if (i < j) {
					String sub = s.substring(i, j + 1);
					if (sub.equals(new StringBuilder(sub).reverse().toString())) {
						if (sub.length() > ans.length()) {
							ans = sub;
						}

					}
				}
			}
		}

		return ans;
	}

	public static double medianOfTwoSortedArray(int[] arr1, int[] arr2) {

		int arr3[] = new int[arr1.length + arr2.length], i = 0, j = 0, k = 0;
		while (true) {
			if (i < arr1.length) {
				arr3[k++] = arr1[i++];
			} else if (j < arr2.length) {
				arr3[k++] = arr2[j++];
			} else
				break;

		}
		double ans = 0;
		Arrays.sort(arr3);
		System.out.println(Arrays.toString(arr3));
		if (arr3.length % 2 == 0) {
			int mid = arr3.length / 2;
			ans = (double) (arr3[mid - 1] + arr3[mid]) / 2;
			System.out.println(arr3[mid - 1]);
		} else {
			ans = arr3[arr3.length / 2];
		}

		return ans;
	}
// 4
// 1,1,1,1
// 2,1,1
// 1,1,2
// 2,2

	public static int[] twoSum(int arr[], int target) {
		int f = 0, sec = 0;
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {
				if (arr[i] + arr[j] == target && i != j) {

					f = i;
					sec = j;
				}
			}

		}
		System.out.println(f + " " + sec);
		return new int[] { f, sec };
	}

	public static char[] stringToArrayOfCharacters(String s) {
		char arr[] = new char[s.length()];
		for (int i = 0; i < s.length(); i++) {
			arr[i] = s.charAt(i);
		}
		return arr;
	}

	public static String[] textToWordsArray(String text) {
		List<String> words = new ArrayList<>();
		for (int i = 0; i < text.length(); i++) {

			for (int j = i; j < text.length() - 1; j++) {
				if (i > 0 && text.charAt(i) == ' ' && text.charAt(j + 1) == ' ' && text.charAt(i - 1) != ' ') {
					words.add(text.substring(i + 1, j + 1));
					break;
				} else if (i == 0 && text.charAt(j + 1) == ' ') {
					words.add(text.substring(i, j + 1));
					break;
				} else if (text.charAt(i) == ' ' && j + 1 == text.length() - 1) {
					words.add(text.substring(i + 1, text.length()));
					break;
				}
			}

		}
		String s[] = new String[words.size()];
		int i = 0;
		ListIterator<String> listIterator = words.listIterator();
		while (listIterator.hasNext()) {
			s[i++] = listIterator.next();
		}
		return s;
	}

	public static int wordCount(String s) {
		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0)
				count++;
			else if (s.charAt(i) == ' ')
				for (int j = i; j < s.length() - 1; j++) {
					if (s.charAt(j + 1) == ' ' && s.charAt(i - 1) != ' ') {
						count++;
						System.out.print(s.charAt(i) + " - > " + s.charAt(j) + " = " + count);
						break;
					}
				}
		}
		return count + 1;

	}

	public static void uniqueFromArrays(int arr[], int arr2[]) {

		List<Integer> list1 = List.of(1, 2, 4);
		List<Integer> list2 = List.of(1, 2, 3, 5);
		List<Integer> unique = new ArrayList<>();
		unique.addAll(list1);
		unique.addAll(list2);
		unique = unique.stream().distinct()
				.filter(a -> list1.contains(a) && !list2.contains(a) || !list1.contains(a) && list2.contains(a))
				.collect(Collectors.toList());
		System.out.println(unique);

		int k = 0;
		for (int i = 0; i < arr.length || k < arr2.length; i++, k++) {
			boolean a = false;
			boolean b = false;
			if (i < arr.length)
				for (int j = 0; j < arr2.length; j++) {
					if (arr[i] == arr2[j])
						a = true;
				}
			for (int j = 0; j < arr.length; j++) {
				if (arr2[k] == arr[j])
					b = true;
			}
			if (!a && i < arr.length)
				System.out.println(arr[i]);
			if (!b)
				System.out.println(arr2[k]);
		}
	}

	public static void arraySum(int arr[], int arr2[]) {
		int carry = 0, total = 0, j = 0, k = arr2.length - 1, i;
		List<Integer> sum = new ArrayList<>();

		for (i = arr.length - 1; i >= 0 && k >= 0; i--, k--) {

			total = arr[i] + arr2[k] + carry;
			carry = 0;
			if (total > 9) {
				carry = total % 10;
				total /= 10;
			}
			sum.add(total);

		}

		if (i < 0 && k >= 0) {
			for (int a = k; a >= 0; a--)
				sum.add(arr2[a]);
		}
		if (k < 0 && i >= 0) {
			for (int a = i; a >= 0; a--)
				sum.add(arr[a]);
		}
		Collections.reverse(sum);
		System.out.println(sum);
	}

	public static void arrayRightRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[arr.length - 1];
			for (j = arr.length - 1; j > 0; j--) {
				arr[j] = arr[j - 1];
			}
			count++;
			arr[0] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static void arrayLeftRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[0];
			for (j = 0; j < arr.length - 1; j++) {
				arr[j] = arr[j + 1];
			}
			count++;
			arr[j] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static boolean anagram(String s, String s1) {

		int count = 0;
		boolean b = false;
		for (int i = 0; i < s.length(); i++) {
			char ch = s.charAt(i);
			count = 0;
			b = false;
			for (int k = 0; k < s.length(); k++) {
				if (ch == s.charAt(k))
					count++;
			}

			for (int j = 0; j < s1.length(); j++) {
				if (count > 0 && ch == s1.charAt(j))
					count--;
			}
			if (count == 0)
				b = true;
		}

		System.out.println(b ? "yes" : "no");
		return b;
	}

	public static int count(int i, int arr[]) {
		int count = 0;
		for (int a : arr) {
			if (a == i)
				count++;
		}
		System.out.println(count);
		return count;
	}

	public static void majorityElement(int arr[]) {
		int max = 0, count = 0;
		for (int i = 0; i < arr.length; i++) {
			count = count(arr[i], arr);
			if (count >= max && count > arr.length / 2)
				max = arr[i];

		}
		System.out.println(max);
	}

	public static void longestPolindrom(String s) {

		int first = 0, last = s.length() - 1, max = 0;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - i; j >= 0; j--) {
				if (i < j && j < s.length())
					if (checkPolindrom(i, j + 1, s) && max < s.substring(i, j).length()) {

						max = s.substring(i, j + 1).length();
						first = i;
						last = j + 1;
					}
			}
			System.out.println("------");

		}
		System.out.println(s.substring(first, last));

	}

	public static boolean checkPolindrom(int f, int l, String s) {
		String st = s.substring(f, l);
		System.out.println(st + "444");
		return st.equals(new StringBuffer(st).reverse().toString());

	}

	public void spiralMatrix() throws ClassNotFoundException, NoSuchMethodException, SecurityException,
			InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		int a[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };
		int j = 0, k = 0, count = 0, max = 10 - 1;
		// int max=a.length*a.length-1;
		// System.out.println(a.length);

		for (int i = 0; i < a.length - i; i++) {

			if (count == max)
				break;

			for (j = i; j < a.length - i && count <= max; j++) {
				count++;
				System.out.println(a[k][j]);
			}
			j--;

			k++;
			while (k < a.length - i && count <= max) {
				System.out.println(a[k][j]);
				k++;
				count++;
			}
			k--;
			j--;

			while (j >= 0 && count <= max) {
				count++;
				System.out.println(a[k][j--]);
			}

			// k=i+1;
			if (k == a.length / 2 && j == a.length / 2)
				break;
			j++;
			while (k > i + 1 && count <= max) {
				System.out.println(a[--k][j]);
				count++;
			}

			k = i + 1;
			System.out.println("-----------------");
		}

	}

	public static ArrayList<Integer> findIndexes(int arr[], int sum) {
		boolean a = false;
		int f = 0, l = arr.length, s = 0;
		for (int i = 0; i < arr.length; i++) {
			s = 0;
			if (a)
				break;

			for (int j = i; j < arr.length; j++) {
				s += arr[j];
				if (s == sum) {
					f = i;
					l = j;
					a = true;
					break;
				}

			}
			System.out.println(s);
		}

		return a ? new ArrayList<Integer>(Arrays.asList(f, l)) : new ArrayList<Integer>(Arrays.asList(-1));
	}

	public int count(char a, String s) {
		class A {
			static int a;

			public void main() {
				System.out.println("hello");
			}
		}

		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == a)
				count++;
		}
		return count;
	}

	public static boolean isPresent(char a, int indx, String s) {
		for (int i = indx; i >= 0; i--) {
			if (s.charAt(i) == a)
				return true;
		}
		return false;
	}

	public static boolean isPresent(int a, int indx, int ar[]) {
		for (int i = indx; i >= 0; i--) {
			if (ar[i] == a)
				return true;
		}
		return false;
	}

	public static void fibonacci(int t1, int t2, int n) {
		if (n == 0)
			return;
		else {
			int t3 = t1 + t2;
			t1 = t2;
			t2 = t3;
			System.out.println(t3);
			fibonacci(t1, t2, n - 1);
		}

	}

	public static int factorial(int n) {
		if (n == 1)
			return 1;
		else
			n = n * factorial(n - 1);
		return n;

	}

	public static String removeSpaces(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ')
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static int[] removeDuplicate(int[] a) {
		int arr[] = new int[a.length];
		int j = 0;
		for (int i = 0; i < a.length; i++) {
			if (!isPresent(a[i], i - 1, a))
				arr[j++] = a[i];
		}
		a = new int[j];
		System.out.println(j);
		for (int i = 0; i < j; i++)
			a[i] = arr[i];
		return a;
	}

	class C {
		static int a;
	}
}

class B {
	int a = 10;

	public String toString() {
		System.out.println("askfjal");
		return new String(this.a + "");
	}

	public void hello(int... a) {

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-12-24 23:21:10.354
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-12-24 23:21:10.355
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-12-24 23:21:10.372
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.pract;

import java.lang.reflect.InvocationTargetException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.springframework.jdbc.core.metadata.OracleCallMetaDataProvider;

interface DD {

}

class AB implements Comparable<AB> {
	int id = 0;
	String name = "rohit";

	@Override
	public int compareTo(AB o) {
		if (this.id < o.id)
			return 1;

		return -1;
	}

	@Override
	public String toString() {
		return "AB [id=" + id + ", name=" + name + "]";
	}

}

abstract class kd {

}

class Foodsystem {
	public String count;
	public Map<String, Integer> food = new LinkedHashMap<>();

	public String toString() {
		return count + " =" + food;
	}

}

public class Test {

	public Test(int a) {

	}

	public static void main(String[] args) throws Exception {
		// fibonacci(0,1,20);
		// Class<?> clas = Class.forName("com.pract.Test");

		// Constructor<?> to = clas.getConstructor(int.class);
		// Test t = (Test) to.newInstance();
		var a = new Test(8);

		// System.out.println(Integer.toBinaryString(2));

		// new Random().ints(1,999).limit(20).sorted().forEach(System.out::println);
		// List<Integer> list = List.of(1,2,3,4,5);
		// System.out.println(list.stream().mapToInt(v->v).max().getAsInt());
		// list.stream().max(Integer::compare);

//		
//		longestPolindrom("bcac");
//	
//	majorityElement(new  int []{1,2,3,4,5,5});
//		
//	anagram("abcda","bcdaa");
//	String sp="TEST@$QWES 89";
//	sp = sp.replaceAll("\\d+","");
//	System.out.println(sp);

//arrayLeftRotation(new int[] {1,2,3,4,5},4);
//arrayRightRotation(new int[] {1,2,3,4,5},2);
//arraySum(new int[] {1,2,3,4},new int[] {1,2,3});
//uniqueFromArrays(new int[] {1,2,4},new int[] {1,2,3,5});
//wordCount("Hello what are you doing here you fucking bitch bastard");
//String s[]=textToWordsArray("Hello what are you doing here you fucking bitch bastard ab bcd");

//char arr[]=stringToArrayOfCharacters("hello what");

//twoSum(new int[] {2,7,11,15},9);
//		System.out.println(medianOfTwoSortedArray(new int[] {3},new int[] {-2,-1}));
//		System.out.println(longestPolindromSubtString("cbbd"));
		// zigzapConversion("PAYPALISHIRING",4);
//		Date d = new Date();
//		SimpleDateFormat f = new SimpleDateFormat("dd/MM/yyyy");
//		Date parse = f.parse("12/9/2023");
//		//LocalDate.now().
//		LocalDate l = LocalDate.now();
//		LocalDate l2 = LocalDate.of(2024, 10, 11);
//		Period period = Period.between(l, l2);
//		period.between(l, l2);
//		DayOfWeek dayOfWeek = l2.getDayOfWeek();
//		System.out.println(dayOfWeek.toString());

//		int arr[] = new int[] { 1, 2, 4 };
//		int arr2[] = new int[] { 1, 3, 4 };
		// righRotation(arr, 2);
//inserAtNthPos(arr,3,3);

//arr=insertInSortedArray(arr,6);
//System.out.println(2%5);
//arr=mergeSortedArrays(arr,arr2);
//System.out.println(Arrays.toString(arr))
		// reverserInteger(-1234);
//convertToInteger("  -1234");

		// AB.main(new String[] {"a","b"});
		// AB ab = new AB();
//		ab.hello();
//Comparator<Integer> com = new Comparator<Integer>() {
//
//	@Override
//	public int compare(Integer o1, Integer o2) {
//	   
//		return o1.intValue()>o2.intValue()?o2:o1;
//	}
//	
//};
//com = (c,b) -> c<b?1:-1;
//
//TreeSet<AB>  t = new TreeSet<>(); 
//		AB a1 = new AB();
//		a1.id=10;
//		AB a2 = new AB();
//		a2.id=20;
//		AB a3 = new AB();
//		a3.id=30;
//		AB a4 = new AB();
//		a4.id=40;
//		AB a5 = new AB();
//		a5.id=50;
//		
//		t.add(a1);
//		t.add(a2);
//		t.add(a3);
//		t.add(a4);
//		t.add(a5);
//		System.out.println(t);
		// System.out.println(integerToRoman(400));
		// System.out.println(romanToInteger("D"));
		// System.out.println(nonRepeatingChar("abcabc"));
		// System.out.println(longestPrefix(new String[] {"flow","flowight","flower"}));
//		int arr1[] = { 10, 8, 7, 5, 4, 11, 78 };
//		int arr3[] = { -1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4 };
//		Arrays.sort(arr3);
		// System.out.println(threeSum(arr3));
//		recursionBubbleSort(arr1,0,0);
//		System.out.println(Arrays.toString(arr1));
//		List.of(arr);

//		System.out.println(Arrays.toString(mergeTwoSortedArray(new int[] {1,3,5,7,9},new int[] {2,4,6,7,8})));
//		System.out.println(Arrays.toString(selectionSortRecu(new int[] {7,9,4,3,2,1,54,3},0,1,0)));

//		System.out.println(Arrays.toString(insertionSort(new int[] {9,8,6,5,4,3,5})));
		// System.out.println(uniqueOccurance(new int[] {1,1,1,2,2,2,3,4,4,5,4,5}));;
//		System.out.println(reverseKElements(new int[] {1,2,3,4,5,6,7,8,9},2));

		// System.out.println(isArraySortedOrRotated(new int[] {5,6,7,8,1}));
		// System.out.println(Arrays.toString(twoSum2(new int[] {2 ,7,8,5,2,1},9)));
		// System.out.println(longestPrefixs(new String[] {"ab","aba","ad"}));
		// System.out.println(Arrays.toString(removeDuplicatess(new int[]
		// {1,1,2,2,3,4,4,5,55,5})));
		// System.out.println(firstOccurances("hadbadhad","had"));
		// String s[]= {"aaa","aec","adc","ae"};
//		Arrays.sort(s);
//		System.out.println(lastWordLength("hello world jav   "));
		// System.out.println(Arrays.toString(plusOneOptimized(new int[] {9,9,})));
		// System.out.println(isPolindrom("5?6?7?876?5"));
		// System.out.println(reverseWords("A man, a plan, a canal: Panama"));
//		System.out.println(mostOccurrance("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(mostOccurranceInString("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(replaceString("a man is one the street"));
//	System.out.println(replaceAllDigitsWithCharacter("a1b2c3"));
		// System.out.println(removeAllSubstring("aabababa","aba"));
//System.out.println(removeAllDuplicates("aabbccdeffghill"));
		// System.out.println(1%2);
//		char ch[]=new char[] {'a','a','a','b','b','a','a'};
//		int n=countLetters(ch);
//		for(int i=0;i<n;i++) {
//			System.out.print(ch[i]+",");
// 		System.out.println(System.currentTimeMillis());
//		}
//		System.out.println(Arrays.toString(mergeSorted(new int[] {1,2,3,4},3,new int[] {2,5,6},2)));
		// int arr[][] = new int[][] { { 1, 2, 3} ,{ 4, 5, 6} ,{7,8,9}};
//		printWave(arr,2,3);
		// System.out.println(reverseVowels("hello"));
//		printSprial(arr);
//		generateMatrix(5);
//		arr = rotateArray90(arr);
//		for(int i=0;i<arr.length;i++) {
//			for(int j=0;j<arr[0].length;j++)
//				System.out.print(arr[i][j]+" ");
//			System.out.println();
//		}

//		int arr []= {1,2};
		// rotateArrayWithK(arr, 3);
//		int arr[][] = {{1,2,3},{4,5,6},{7,8,9}};  
//		List<List<Integer>> shiftGrid = shiftGrid(arr, 2);
//		for(int i =0 ;i<shiftGrid.size();i++) {
//			System.out.println(shiftGrid.get(i));
//		}

//		System.out.println(maximumSumOfTwoSubStringScore("00111"));
//		System.out.println(convertArrayIn2DArray(new int[] {1,2,3,4,5,5,6,200,200}));
//	System.out.println(missingNumber(new int[] {9,6,4,2,3,5,7,0,1}));	
//		System.out.println(unique(new int[] {1,1,2,2,3,3,9}));
		// System.out.println(Arrays.toString(findErrorNums(new int[] {1,2,2,4})));
		//	kajuKatli(10);
		System.out.println(System.currentTimeMillis());
		System.out.println(minOperations("1000"));
		System.out.println(System.currentTimeMillis());
	}

	public static int minOperations(String s) {
		int count[] = new int[2];
		for(int i=0;i<s.length();i++) {
			count[s.charAt(i)-'0']++;
		}
		if(count[0]>count[1]) {
		return	(count[0]-count[1])/2;
		}
		(count[1]-count[0])/2;
		System.out.println(Arrays.toString(count));
		return 0;
	}
	
	
	public static int[] findErrorNums(int[] arr) {
		Set<Integer> value = new HashSet<>();
		int[] ar = new int[2];
		for (int i = 0; i < arr.length; i++) {
			if (value.contains(arr[i])) {
				ar[0] = arr[i];
				arr[1] = arr[i] + 1;
				System.out.println(arr[i] + 1);
				return ar;
			}
			value.add(arr[i]);
		}
		return ar;
	}

	public static int[] selectionSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			int min = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[j] < arr[min])
					min = j;
			}
			int temp = arr[i];
			arr[i] = arr[min];
			arr[min] = temp;

		}
		return arr;
	}

	public static int[] bubbleSortPr(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}

			}
		}
		return arr;
	}

	public static int unique(int arr[]) {
		int xor = 0;
		for (int i = 0; i < arr.length; i++) {
			xor ^= arr[i];
		}
		return xor;
	}

	public static int xorDuplicate(int arr[]) {

		for (int i = 0; i < arr.length; i++) {

		}
		return 0;
	}

	public static int missingNumber(int arr[]) {
		int max = findMaximum(arr);
		int total = max * (max + 1) / 2, sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return total - sum == 0 ? max + 1 : total - sum;
	}

	public static int countNumber(int arr[], int value) {
		int count = 0;

		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == value)
				count++;
			if (count > 2)
				return count;
		}
		return count;
	}

	public static int uniqueElement(int arr[]) {
		Set<Integer> value = Arrays.stream(arr).boxed().collect(Collectors.toSet());
		Iterator<Integer> iterator = value.iterator();
		while (iterator.hasNext()) {
			int va = iterator.next();
			if (count(arr, va) < 2)
				return va;
		}
		return -1;
	}

	public static int findMaximum(int arr[]) {
		int max = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] > max)
				max = arr[i];
		}
		return max;
	}

	public static List<List<Integer>> convertArrayIn2DArray(int arr[]) {
		// int max = findMaximum(arr);
		int count[] = new int[201];
		for (int i = 0; i < arr.length; i++)
			count[arr[i]]++;
//		System.out.println(Arrays.toString(count));
		int max = findMaximum(count);
		List<List<Integer>> response = new ArrayList<>();
		for (int i = 0; i < max; i++) {
			List<Integer> list = new ArrayList<>();
			for (int j = 0; j < count.length; j++) {
				if (count[j] > 0) {
					list.add(j);
					count[j]--;
				}
			}
			response.add(list);
		}

		return response;
	}

	public static int count(char arr[], int st, int end, char ch) {
		int count = 0;
		while (st <= end) {
			if (arr[st] == ch)
				count++;
			st++;
		}

		return count;
	}

	public static int maximumSumOfTwoSubStringScore(String s) {
		char[] arr = s.toCharArray();
		int i = 0, j = i + 1, max = 0;
		while (i < j && j < arr.length) {
			int cou = count(arr, i, j - 1, '0') + count(arr, j, arr.length - 1, '1');

			if (cou > max)
				max = cou;
			j++;
		}
		return max;
	}

	public static List<List<Integer>> shiftGrid(int arr[][], int k) {
		int row = arr.length, col = arr[0].length, j = row * col - 1, count = 0;
		while (count++ < k) {
			int ele = arr[arr.length - 1][arr[0].length - 1];
			for (j = row * col - 1; j > 0; j--) {
				arr[j / col][j % col] = arr[(j - 1) / col][(j - 1) % col];
			}
			arr[0][0] = ele;

		}
		List<List<Integer>> ar = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			List<Integer> ro = new ArrayList<>();
			for (j = 0; j < arr[0].length; j++) {
				ro.add(arr[i][j]);
			}
			ar.add(ro);

		}
		return ar;
	}

	public static boolean binarySearch2DInSortedRow(int arr[][], int target) {
		int row = 0, col = arr[0].length - 1;

		while (col >= 0 && row <= arr.length - 1) {
			if (arr[row][col] == target)
				return true;
			if (arr[row][col] < target)
				row++;
			else
				col--;
		}
		return false;
	}

	public static boolean binarySearchIn2D(int arr[][], int target) {
		int row = arr.length;
		int col = arr[0].length;
		int st = 0;
		int end = row * col - 1;

		while (st <= end) {
			int mid = st + (end - st) / 2;
			int element = arr[mid / col][mid % col];
			if (element == target)
				return true;
			if (element < target)
				st = mid + 1;
			else
				end = mid - 1;

		}
		return false;

	}

	public static void rotateArrayWithK(int arr[], int k) {
		int arr2[] = new int[arr.length], l = 0;
		int kIndex = arr.length - k;

		if (k >= arr.length) {
			int count = 0;
			while (count++ <= k) {
				int temp = arr[arr.length - 1];
				System.out.println(Arrays.toString(arr));
				for (int j = arr.length - 1; j > 0; j--) {
					arr[j] = arr[j - 1];
				}
				arr[0] = temp;
			}
			return;
		}

		if (kIndex < 0)
			return;
		for (int i = kIndex; i < arr.length; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < kIndex; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < arr.length; i++)
			arr[i] = arr2[i];

	}

	public static int[][] rotateArray90(int arr[][]) {
		int arr3[][] = new int[arr.length][arr[0].length], k = 0;
		for (int col = 0; col < arr[0].length; col++) {
			k = 0;
			for (int row = arr.length - 1; row >= 0; row--) {
				arr3[col][k++] = arr[row][col];
			}

		}
		return arr3;
	}

	public static int[][] generateMatrix(int n) {
		int row = n;
		int col = n;
		int total = n * n;
		int startingCol = 0;
		int startingRow = 0;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int arr[][] = new int[n][n];
		int count = 0;
		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				arr[startingRow][i] = ++count;
			}

			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				arr[i][endingCol] = ++count;
			}

			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				arr[endingRow][i] = ++count;
			}

			endingRow--;

			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				arr[i][startingCol] = ++count;
			}
			startingCol++;

		}
		return arr;
	}

	public static void printSprial(int arr[][]) {
		int startingCol = 0;
		int startingRow = 0;
		int row = arr.length;
		int col = arr[0].length;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int count = 0;
		int total = row * col;

		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				System.out.print(arr[startingRow][i]);
				count++;
			}
			System.out.println();
			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				System.out.print(arr[i][endingCol]);
				count++;
			}

			System.out.println();
			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				System.out.print(arr[endingRow][i]);
				count++;
			}

			endingRow--;
			System.out.println();
			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				System.out.print(arr[i][startingCol]);
				count++;
			}
			startingCol++;
			System.out.println();
		}
	}

	public static boolean isVowel(char ch) {
		ch = Character.toLowerCase(ch);
		if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
			return true;
		return false;
	}

	public static String reverseVowels(String s) {

		char[] arr = s.toCharArray();
		int i = 0, j = arr.length - 1;
		while (i < j) {
			if (isVowel(arr[i]) && isVowel(arr[j])) {
				char t = arr[i];
				arr[i] = arr[j];
				arr[j] = t;
				i++;
				j--;
			} else if (isVowel(arr[i]))
				j--;
			else
				i++;
		}
		return new String(arr);
	}

	public static void printWave(int arr[][], int row, int col) {
		for (int j = 0; j < col; j++) {

			for (int i = 0; i < row; i++) {
				System.out.print(arr[i][j]);
			}

			System.out.println();
			j++;
			for (int i = row - 1; i >= 0 && j < col; i--) {
				System.out.print(arr[i][j]);
			}
			System.out.println();

		}
	}

	public static int[] mergeSorted(int arr[], int m, int arr1[], int n) {
		int arr3[] = new int[m + n], i = 0, j = 0, k = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j] && n > 0) {
				arr3[k++] = arr1[j++];
				n--;
			} else if (m > 0) {
				arr3[k++] = arr[i++];
				m--;
			} else
				break;

		}
		System.out.println(Arrays.toString(arr3));
		while (m > 0 && i < arr.length) {
			arr3[k++] = arr[i++];
			m--;
		}
		while (n > 0 && j < arr1.length) {
			arr3[k++] = arr1[j++];
			n--;
		}
		return arr3;
	}

	public static List<Foodsystem> system = new ArrayList<>();

	public void enterData() {
		String food[] = { "kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi" };
		String country[] = { "korean", "japanese", "japanese", "greek", "japanese", "korean" };
		int arr[] = { 9, 12, 8, 15, 14, 7 };
		for (int i = 0; i < country.length; i++) {
			Map<String, Integer> fs = new LinkedHashMap<>();
			Foodsystem s = new Foodsystem();
			s.count = country[i];
			s.food.put(food[i], arr[i]);
			this.add(s);
		}
		System.out.println(system);

	}

	public void add(Foodsystem o) {
		for (int i = 0; i < this.system.size(); i++) {
			if (system.get(i).count.equals(o.count)) {
				system.get(i).food.putAll(o.food);
				return;
			}

		}
		this.system.add(o);
	}

	public void changeRating(String food, int rating) {
		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem f = system.get(i);
			if (f.food.containsKey(food)) {
				f.food.put(food, rating);
				return;
			}

		}

	}

	public String highestRating(String country) {
		String city = "";

		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem s = system.get(i);
			if (s.count.equals(country)) {
				int max = 0;
				Set<Entry<String, Integer>> entrySet = s.food.entrySet();
				System.out.println(entrySet);
				for (Entry<String, Integer> e : entrySet) {
					if (e.getValue() > max) {
						max = e.getValue();
						city = e.getKey();

					}
					if (e.getValue() == max) {
						s.food.put(e.getKey(), e.getValue());
					}
				}
			}

		}

		return city;
	}

	public static int countLetters(char[] s) {
		int k = 0;
		for (int i = 0; i < s.length;) {
			char ch = s[i];
			int j = i + 1, count = 1;

			while (j < s.length && s[j] == ch) {
				count++;
				j++;
			}
			System.out.println(ch + " " + count + " " + j);
			if (count > 1) {
				s[k++] = ch;
				for (char c : Integer.toString(count).toCharArray()) {
					if (k < s.length)
						s[k++] = c;
					else
						return k;
				}
			} else {
				s[k++] = ch;
			}
			i = j;
		}
		return k;
	}

	public static String removeAllDuplicates(String s) {
		StringBuilder sb = new StringBuilder();
		int count[] = new int[26];
		for (int i = 0; i < s.length(); i++) {
			int num = s.charAt(i) - 'a';
			count[num]++;
		}

		for (int i = 0; i < s.length(); i++) {
			if (count[(s.charAt(i) - 'a')] < 2)
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static String removeAllSubstring(String s, String part) {
		while (s.length() != 0 && s.contains(part))
			s = s.replaceFirst(part, "");

		return s;
	}

	public static String replaceAllDigitsWithCharacter(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
				sb.append((char) (s.charAt(i - 1) + (s.charAt(i) - 48)));
			else
				sb.append(s.charAt(i));
		}
		return sb.toString();

	}

	public static String replaceString(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == ' ')
				sb.append("@40");
			else
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static char mostOccurranceInString(String s) {
		int arr[] = new int[26]; // storing occurance of every letter according to index
		s = s.toLowerCase();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
				int num = s.charAt(i) - 'a';
				arr[num]++;
			}
		}

		// finding max
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < arr.length; i++) {
			if (max < arr[i]) {
				max = arr[i];
				ch = (char) i;
			}

		}
		return (char) (ch + 'a');

	}

	// brute force
	public static char mostOccurrance(String s) {
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < s.length(); i++) {
			int count = 0;
			for (int j = i + 1; j < s.length(); j++) {
				if (s.charAt(i) == s.charAt(j) && s.charAt(i) != ' ')
					count++;
			}

			if (count > max) {
				ch = s.charAt(i);
				max = count;
			}
		}
		return ch;
	}

	public static int climbStairs(int n) {

		if (n < 0)
			return 0;
		if (n == 0)
			return 1;
		return climbStairs(n - 1) + climbStairs(n - 2);
	}

	public static void reverseString(char[] ch, int st, int end) {

		while (st < end) {
			char temp = ch[st];
			ch[st] = ch[end];
			ch[end] = temp;
			st++;
			end--;
		}

	}

	public static char[] reverseWords(String s) {
		char ch[] = s.toCharArray();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ' && s.charAt(i) != ',') {
				int j = i + 1;
				for (; j < s.length(); j++) {
					if (s.charAt(j) == ' ' || s.charAt(j) == ',')
						break;
				}
				reverseString(ch, i, j - 1);
				i = j;
			}
		}
		return ch;
	}

	public static boolean isAlphaNumeric(char c) {
		if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9')
			return true;
		return false;
	}

	public static boolean isPolinromValidAlgo(String s) {
		StringBuilder b = new StringBuilder();
		// remove special characters only left alphanumeric
		for (int i = 0; i < s.length(); i++) {
			if (isAlphaNumeric(s.charAt(i)))
				b.append(s.charAt(i));

		}

		// to lower case
		String str = b.toString().toLowerCase();
		int st = 0, end = str.length() - 1;
		while (st < end) {
			if (str.charAt(st) != str.charAt(end))
				return false;
			st++;
			end--;
		}
		return true;

	}

	public static boolean isPolindrom(String s) {
		int st = 0, end = s.length() - 1;
		while (st < end) {
			if (s.charAt(st) >= '0' && s.charAt(st) <= '9') {
				if (s.charAt(end) >= '0' && s.charAt(end) <= '9') {

					if (s.charAt(st) != s.charAt(end))
						return false;
					else {
						st++;
						end--;
					}
				} else
					end--;
			} else
				st++;
		}
		return true;
	}

	// optimized
	public static int[] plusOneOptimized(int arr[]) {
		for (int i = arr.length - 1; i >= 0; i--) {
			if (arr[i] < 9) {
				arr[i]++;
				return arr;
			}
			arr[i] = 0;
		}
		arr = new int[arr.length + 1];
		arr[0] = 1;
		return arr;
	}

	// brute force
	public static int[] plusOne(int arr[]) {
		if (arr.length < 1)
			return arr;
		int carry = 1;
		for (int i = arr.length - 1; i >= 0; i--) {
			arr[i] = arr[i] + carry;
			carry = 0;
			if (arr[i] > 9) {
				arr[i] = 0;
				carry = 1;
			} else
				break;
		}

		if (carry != 0) {
			int ar[] = new int[arr.length + 1];
			ar[0] = carry;
			for (int i = 1; i < ar.length - 1; i++)
				ar[i] = arr[i];
			return ar;
		}
		return arr;
	}

	public static int countLastWordLength(String s, int index) {
		int count = 0;
		for (; index >= 0; index--) {
			if (s.charAt(index) != ' ')
				count++;
			else
				break;
		}
		return count;
	}

	public static int lastWordLength(String s) {
		for (int i = s.length() - 1; i >= 0; i--) {
			if (s.charAt(i) != ' ')
				return countLastWordLength(s, i);
		}
		return 0;
	}

	public static int firstOccurances(String s, String value) {
		if (s.contains(value)) {
			return s.indexOf(value);
		}
		return -1;
	}

	public static boolean isMatched(String s, String value) {
		if (s.length() < value.length())
			return false;
		for (int i = 0; i < value.length(); i++) {
			if (s.charAt(i) != value.charAt(i))
				return false;
		}
		return true;
	}

	public static int firstOccurance(String s, String value) {
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == value.charAt(0)) {
				if (isMatched(s.substring(i), value))
					return i;
			}
		}
		return -1;
	}

	public static int[] removeDuplicatess(int arr[]) {
		int i = 0, j = 1;
		for (i = 1; i < arr.length; i++) {
			if (arr[i - 1] != arr[i])
				arr[j++] = arr[i];
		}
		return arr;
	}

	public static int[] removeDuplicates(int arr[]) {
		Set<Integer> set = new LinkedHashSet<>();
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		return set.stream().mapToInt(i -> i).toArray();

	}

	public static String longestPrefixs(String arr[]) {
		Arrays.sort(arr);
		StringBuilder b = new StringBuilder();
		String first = arr[0];
		String last = arr[arr.length - 1];
		for (int i = 0; i < Math.min(first.length(), last.length()); i++) {
			if (first.charAt(i) != last.charAt(i))
				return b.toString();
			b.append(first.charAt(i));
		}
		return b.toString();

	}

	public static int[] twoSum2(int[] arr, int target) {
		int f = 0, l = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 1; j < arr.length; j++) {
				if (arr[i] + arr[j] == target) {
					f = i;
					l = j;
				}
			}
		}
		return new int[] { f, l };
	}

	public static Boolean arraySortedOrRotated(int arr[]) {
		int count = 0;
		for (int i = 1; i < arr.length; i++) {
			if (arr[i - 1] > arr[i])
				count++;
		}
		if (arr[0] < arr[arr.length - 1])
			count++;

		return count == 1;
	}

	// brute force
	public static Boolean isArraySortedOrRotated(int arr[]) {
		int i = 0;
		for (i = 0; i < arr.length - 1; i++) {
			if (arr[i] > arr[i + 1])
				break;

		}
		System.out.println(i + " -<");
		i++;
		for (; i < arr.length - 1; i++) {
			System.out.println("->" + i);
			if (arr[0] < arr[i] || arr[i] > arr[i + 1])
				return false;
		}
		if (i < arr.length && arr[0] < arr[i])
			return false;
		return true;
	}

	public static int findUnique(int arr[]) {
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {

			ans = ans ^ arr[i];
		}
		return ans;
	}

	public static int count(int arr[], int value) {
		int count = 0;
		for (int i = 0; i < arr.length; i++) {
			if (value == arr[i])
				count++;
		}
		return count;

	}

	public static int uniqueOccurance(int arr[]) {
		int arr1[] = new int[arr.length], k = 0;
		for (int i = 0; i < arr.length; i++) {
			if (!isPreExists(arr[i], arr, i - 1)) {

				int count = count(arr, arr[i]);
				arr1[k++] = count;
				System.out.println("count " + count);
			}
		}
		return findUniqueElement(arr1);
	}

	public static int[] reverse(int arr[], int st, int end) {
		if (end < arr.length)
			while (st < end) {
				int k = arr[st];
				arr[st++] = arr[end];
				arr[end--] = k;
			}
		return arr;
	}

	public static int[] reverseKElements(int arr[], int k) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length; i += k) {

			reverse(arr, i, i + k - 1);
		}
		System.out.println(Arrays.toString(arr));
		return arr;

	}

	public static boolean isPreExists(int value, int arr[], int k) {
		for (int i = k; i >= 0; i--) {
			if (arr[i] == value)
				return true;
		}
		return false;
	}

	public static int findUniqueElement(int arr[]) {
		System.out.println(Arrays.toString(arr));
		for (int i = 0; i < arr.length; i++) {
			int count = 0;
			if (!isPreExists(arr[i], arr, i - 1))
				for (int j = i; j < arr.length; j++) {

					if (arr[i] == arr[j])
						count++;
				}

			if (count == 1) {
				System.out.println("found " + arr[i]);

				return arr[i];
			}
		}
		return 0;
	}

	public static int[] insertionSort(int arr[]) {
		int j = 0;
		for (int i = 0; i < arr.length; i++) {
			int k = arr[i];
			for (j = i - 1; j >= 0; j--) {
				if (arr[j] < k) {
					arr[j + 1] = arr[j];
				} else
					break;
			}
			arr[j + 1] = k;
		}
		return arr;
	}

	public static int[] selectionSortRecu(int arr[], int i, int j, int min) {
		if (i >= arr.length)
			return arr;
		if (j < arr.length) {
			if (arr[min] > arr[j])
				min = j;
			return selectionSortRecu(arr, i, j + 1, min);
		}
		int k = arr[i];
		arr[i] = arr[min];
		arr[min] = k;
		return selectionSortRecu(arr, i + 1, i + 2, i + 1);
	}

	public static int[] mergeTwoSortedArray(int arr[], int arr1[]) {
		int arr3[] = new int[arr.length + arr1.length], k = 0, i = 0, j = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j]) {
				arr3[k++] = arr1[j++];

			} else {
				arr3[k++] = arr[i++];

			}
		}

		while (i < arr.length) {
			arr3[k++] = arr[i++];
		}
		while (j < arr1.length) {
			arr3[k++] = arr1[i++];
		}
		return arr3;
	}

	public static void recursionBubbleSort(int arr[], int i, int j) {
		if (i == arr.length)
			return;
		if (j < arr.length - i - 1 && arr[j] > arr[j + 1]) {

			int k = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = k;
			System.out.println(Arrays.toString(arr));
			recursionBubbleSort(arr, i, j + 1);

		} else {
			System.out.println("----- " + Arrays.toString(arr));
			recursionBubbleSort(arr, i + 1, 0);
		}

	}

	public static void bubbleSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int k = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = k;
				}

			}
		}
	}

	public static List<List<Integer>> threeSum(int arr[]) {
		int i = 0, j = 0, k = arr.length - 1;
		Set<List<Integer>> output = new HashSet<>();
		for (i = 0; i < arr.length; i++) {
			j = i + 1;
			k = arr.length - 1;
			while (j < k) {
				System.out.println(arr[i] + "->" + arr[j] + "->" + arr[k] + "=> " + (arr[i] + arr[j] + arr[k]) + " ( "
						+ i + "," + j + "," + k);
				if (arr[i] + arr[j] + arr[k] == 0) {
					List<Integer> list = new ArrayList<>();
					list.add(arr[i]);
					list.add(arr[j]);

					list.add(arr[k]);
					output.add(list);
				} else if (arr[i] + arr[j] + arr[k] > 0) {
					k--;
					j--;
				}
				j++;

			}
		}

		return output.stream().toList();

	}

	public static String longestPrefix(String s[]) {

		String prefix = "";

		for (int i = 0; i < s.length; i++) {
			for (int j = i + 1; j < s.length; j++) {
				if (s[i].length() > s[j].length()) {
					String temp = s[i];
					s[i] = s[j];
					s[j] = temp;
				}
			}
		}

		String st = s[0];
		boolean isMatched = false;
		for (int j = 0; j < st.length(); j++) {
			char ch = st.charAt(j);

			for (int k = 1; k < s.length; k++) {
				isMatched = false;

				if (ch == s[k].charAt(j)) {
					isMatched = true;
				} else
					break;
			}
			if (isMatched)
				prefix += ch;
			else
				break;

		}
		;
		return prefix;

	}

	public static String nonRepeatingChar(String s) {
		for (int i = 0; i < s.length(); i++) {
			boolean isPresent = false;
			for (int j = 0; j < s.length(); j++) {
				if (i != j && s.charAt(i) == s.charAt(j)) {
					isPresent = true;
					break;
				}
			}
			if (!isPresent) {
				return s.charAt(i) + "";
			}
		}
		return "All Are repated";
	}

	public static Integer romanToInteger(String s) {
		int num = 0;
		Map<String, Integer> romans = new HashMap<>();
		romans.put("M", 1000);
		romans.put("CM", 900);
		romans.put("D", 500);
		romans.put("CD", 400);
		romans.put("C", 100);
		romans.put("XC", 90);
		romans.put("L", 50);
		romans.put("XL", 40);
		romans.put("X", 10);
		romans.put("IX", 9);
		romans.put("V", 5);
		romans.put("IV", 4);
		romans.put("I", 1);
//System.out.println(romans.get("M"));
		if (s.length() < 2)
			return romans.get(s.charAt(0) + "");
		for (int i = 0; i < s.length() - 1; i++) {

			if (romans.get(s.charAt(i) + "").intValue() >= romans.get(s.charAt(i + 1) + "").intValue()) {
				num += romans.get(s.charAt(i) + "");
				System.out.println("num -> " + num);
			} else {

				int sum = romans.get(s.charAt(i + 1) + "") - romans.get(s.charAt(i) + "");
				System.out.println("num    => " + num + "  sum => " + sum);
				num += sum;
				i++;
				System.out.println("--------- " + num);
			}
			if (i == s.length() - 2)
				if (romans.get(s.charAt(i + 1) + "").intValue() <= romans.get(s.charAt(i) + "").intValue()) {
					num += romans.get(s.charAt(i + 1) + "");

				}
		}
		return num;
	}

	public static String integerToRoman(int num) {
		Integer number[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
		String romans[] = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };
		String result = "";
		for (int i = 0; i < number.length; i++) {

			while (num >= number[i]) {
				num -= number[i];
				result += romans[i];
			}
		}
		return result;

	}

	public static int convertToInteger(String s) {
		String st = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {
				st += s.charAt(i);
			} else if (s.charAt(i) == '-')
				st += s.charAt(i);
		}
		System.out.println(Integer.parseInt(st));
		return 0;
	}

	public static int reverserInteger(int n) {
		int rev = 0;
		while (n != 0) {
			int r = n % 10;
			n /= 10;
			rev = rev * 10 + r;
		}
		System.out.println(rev);
		return 0;
	}

	public static int[] mergeSortedArrays(int a1[], int a2[]) {
		int a3[] = new int[a1.length + a2.length], j = 0, k = 0, i = 0;

		Stack<Character> stack = new Stack();
		String s = "a";
		Character c = s.charAt(i);
		System.out.println(c.equals(c));

		while (i < a1.length && j < a2.length) {

			if (a1[i] >= a2[j])
				a3[k++] = a2[j++];
			else
				a3[k++] = a1[i++];

		}
		while (i < a1.length)
			a3[k++] = a1[i++];

		while (j < a2.length)
			a3[k++] = a2[j++];

		return a3;

	}

	public static int[] insertInSortedArray(int arr[], int value) {
		int temp[] = new int[arr.length + 1], j = 0;
		boolean isInserted = false;
		for (int i = 0; i < arr.length; i++) {

			if (!isInserted && arr[i] > value) {
				temp[j++] = value;
				isInserted = true;
			}
			temp[j++] = arr[i];
		}
		if (!isInserted)
			temp[j++] = value;
		return temp;
	}

	public static int[] inserAtNthPos(int arr[], int value, int pos) {
		int j = 0;
		int temp[] = new int[arr.length + 1];
		if (pos < 1)
			return arr;

		for (int i = 0; i < arr.length; i++) {
			if (i == pos - 1)
				temp[j++] = value;

			temp[j++] = arr[i];
		}
		if (pos > arr.length) {
			temp[j++] = value;
		}

//	for(int i=0;i<temp.length;i++)
//		arr[i]=temp[i];
		return temp;
	}

	public static void righRotation(int arr[], int num) {
		int n = arr.length, temp = 0, count = 0;
		while (count++ < num) {
			temp = arr[n - 1];
			for (int i = n - 1; i > 0; i--)
				arr[i] = arr[i - 1];
			arr[0] = temp;
		}

	}

	public static void leftRotation(int arr[], int num) {
		int temp[] = new int[arr.length], n = arr.length, j = 0;

		for (int i = num; i < n; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < num; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < n; i++)
			arr[i] = temp[i];
	}

	public static char[] copyArray(char[] arr) {
		if (arr == null)
			return new char[1];

		char[] a = Arrays.copyOf(arr, arr.length + 1);
		return a;
	}

	public static String zigzapConversion(String s, int num) {
		char[][] arr = new char[num][];
		int k = 0, i = 0, j = 0, t = 0;
		while (k < s.length()) {
			while (i != num - 1) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i++;
			}
			j++;
			while (i != 0) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i--;
			}
			j++;

		}
		for (char[] a : arr) {
			for (char tt : a)
				System.out.print(tt);
			System.out.println();
		}
		return "";
	}

	public static String longestPolindromSubtString(String s) {
		String ans = "";
		if (s.length() < 1)
			return s;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - 1; j >= 0; j--) {
				if (i < j) {
					String sub = s.substring(i, j + 1);
					if (sub.equals(new StringBuilder(sub).reverse().toString())) {
						if (sub.length() > ans.length()) {
							ans = sub;
						}

					}
				}
			}
		}

		return ans;
	}

	public static double medianOfTwoSortedArray(int[] arr1, int[] arr2) {

		int arr3[] = new int[arr1.length + arr2.length], i = 0, j = 0, k = 0;
		while (true) {
			if (i < arr1.length) {
				arr3[k++] = arr1[i++];
			} else if (j < arr2.length) {
				arr3[k++] = arr2[j++];
			} else
				break;

		}
		double ans = 0;
		Arrays.sort(arr3);
		System.out.println(Arrays.toString(arr3));
		if (arr3.length % 2 == 0) {
			int mid = arr3.length / 2;
			ans = (double) (arr3[mid - 1] + arr3[mid]) / 2;
			System.out.println(arr3[mid - 1]);
		} else {
			ans = arr3[arr3.length / 2];
		}

		return ans;
	}
// 4
// 1,1,1,1
// 2,1,1
// 1,1,2
// 2,2

	public static int[] twoSum(int arr[], int target) {
		int f = 0, sec = 0;
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {
				if (arr[i] + arr[j] == target && i != j) {

					f = i;
					sec = j;
				}
			}

		}
		System.out.println(f + " " + sec);
		return new int[] { f, sec };
	}

	public static char[] stringToArrayOfCharacters(String s) {
		char arr[] = new char[s.length()];
		for (int i = 0; i < s.length(); i++) {
			arr[i] = s.charAt(i);
		}
		return arr;
	}

	public static String[] textToWordsArray(String text) {
		List<String> words = new ArrayList<>();
		for (int i = 0; i < text.length(); i++) {

			for (int j = i; j < text.length() - 1; j++) {
				if (i > 0 && text.charAt(i) == ' ' && text.charAt(j + 1) == ' ' && text.charAt(i - 1) != ' ') {
					words.add(text.substring(i + 1, j + 1));
					break;
				} else if (i == 0 && text.charAt(j + 1) == ' ') {
					words.add(text.substring(i, j + 1));
					break;
				} else if (text.charAt(i) == ' ' && j + 1 == text.length() - 1) {
					words.add(text.substring(i + 1, text.length()));
					break;
				}
			}

		}
		String s[] = new String[words.size()];
		int i = 0;
		ListIterator<String> listIterator = words.listIterator();
		while (listIterator.hasNext()) {
			s[i++] = listIterator.next();
		}
		return s;
	}

	public static int wordCount(String s) {
		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0)
				count++;
			else if (s.charAt(i) == ' ')
				for (int j = i; j < s.length() - 1; j++) {
					if (s.charAt(j + 1) == ' ' && s.charAt(i - 1) != ' ') {
						count++;
						System.out.print(s.charAt(i) + " - > " + s.charAt(j) + " = " + count);
						break;
					}
				}
		}
		return count + 1;

	}

	public static void uniqueFromArrays(int arr[], int arr2[]) {

		List<Integer> list1 = List.of(1, 2, 4);
		List<Integer> list2 = List.of(1, 2, 3, 5);
		List<Integer> unique = new ArrayList<>();
		unique.addAll(list1);
		unique.addAll(list2);
		unique = unique.stream().distinct()
				.filter(a -> list1.contains(a) && !list2.contains(a) || !list1.contains(a) && list2.contains(a))
				.collect(Collectors.toList());
		System.out.println(unique);

		int k = 0;
		for (int i = 0; i < arr.length || k < arr2.length; i++, k++) {
			boolean a = false;
			boolean b = false;
			if (i < arr.length)
				for (int j = 0; j < arr2.length; j++) {
					if (arr[i] == arr2[j])
						a = true;
				}
			for (int j = 0; j < arr.length; j++) {
				if (arr2[k] == arr[j])
					b = true;
			}
			if (!a && i < arr.length)
				System.out.println(arr[i]);
			if (!b)
				System.out.println(arr2[k]);
		}
	}

	public static void arraySum(int arr[], int arr2[]) {
		int carry = 0, total = 0, j = 0, k = arr2.length - 1, i;
		List<Integer> sum = new ArrayList<>();

		for (i = arr.length - 1; i >= 0 && k >= 0; i--, k--) {

			total = arr[i] + arr2[k] + carry;
			carry = 0;
			if (total > 9) {
				carry = total % 10;
				total /= 10;
			}
			sum.add(total);

		}

		if (i < 0 && k >= 0) {
			for (int a = k; a >= 0; a--)
				sum.add(arr2[a]);
		}
		if (k < 0 && i >= 0) {
			for (int a = i; a >= 0; a--)
				sum.add(arr[a]);
		}
		Collections.reverse(sum);
		System.out.println(sum);
	}

	public static void arrayRightRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[arr.length - 1];
			for (j = arr.length - 1; j > 0; j--) {
				arr[j] = arr[j - 1];
			}
			count++;
			arr[0] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static void arrayLeftRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[0];
			for (j = 0; j < arr.length - 1; j++) {
				arr[j] = arr[j + 1];
			}
			count++;
			arr[j] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static boolean anagram(String s, String s1) {

		int count = 0;
		boolean b = false;
		for (int i = 0; i < s.length(); i++) {
			char ch = s.charAt(i);
			count = 0;
			b = false;
			for (int k = 0; k < s.length(); k++) {
				if (ch == s.charAt(k))
					count++;
			}

			for (int j = 0; j < s1.length(); j++) {
				if (count > 0 && ch == s1.charAt(j))
					count--;
			}
			if (count == 0)
				b = true;
		}

		System.out.println(b ? "yes" : "no");
		return b;
	}

	public static int count(int i, int arr[]) {
		int count = 0;
		for (int a : arr) {
			if (a == i)
				count++;
		}
		System.out.println(count);
		return count;
	}

	public static void majorityElement(int arr[]) {
		int max = 0, count = 0;
		for (int i = 0; i < arr.length; i++) {
			count = count(arr[i], arr);
			if (count >= max && count > arr.length / 2)
				max = arr[i];

		}
		System.out.println(max);
	}

	public static void longestPolindrom(String s) {

		int first = 0, last = s.length() - 1, max = 0;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - i; j >= 0; j--) {
				if (i < j && j < s.length())
					if (checkPolindrom(i, j + 1, s) && max < s.substring(i, j).length()) {

						max = s.substring(i, j + 1).length();
						first = i;
						last = j + 1;
					}
			}
			System.out.println("------");

		}
		System.out.println(s.substring(first, last));

	}

	public static boolean checkPolindrom(int f, int l, String s) {
		String st = s.substring(f, l);
		System.out.println(st + "444");
		return st.equals(new StringBuffer(st).reverse().toString());

	}

	public void spiralMatrix() throws ClassNotFoundException, NoSuchMethodException, SecurityException,
			InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		int a[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };
		int j = 0, k = 0, count = 0, max = 10 - 1;
		// int max=a.length*a.length-1;
		// System.out.println(a.length);

		for (int i = 0; i < a.length - i; i++) {

			if (count == max)
				break;

			for (j = i; j < a.length - i && count <= max; j++) {
				count++;
				System.out.println(a[k][j]);
			}
			j--;

			k++;
			while (k < a.length - i && count <= max) {
				System.out.println(a[k][j]);
				k++;
				count++;
			}
			k--;
			j--;

			while (j >= 0 && count <= max) {
				count++;
				System.out.println(a[k][j--]);
			}

			// k=i+1;
			if (k == a.length / 2 && j == a.length / 2)
				break;
			j++;
			while (k > i + 1 && count <= max) {
				System.out.println(a[--k][j]);
				count++;
			}

			k = i + 1;
			System.out.println("-----------------");
		}

	}

	public static ArrayList<Integer> findIndexes(int arr[], int sum) {
		boolean a = false;
		int f = 0, l = arr.length, s = 0;
		for (int i = 0; i < arr.length; i++) {
			s = 0;
			if (a)
				break;

			for (int j = i; j < arr.length; j++) {
				s += arr[j];
				if (s == sum) {
					f = i;
					l = j;
					a = true;
					break;
				}

			}
			System.out.println(s);
		}

		return a ? new ArrayList<Integer>(Arrays.asList(f, l)) : new ArrayList<Integer>(Arrays.asList(-1));
	}

	public int count(char a, String s) {
		class A {
			static int a;

			public void main() {
				System.out.println("hello");
			}
		}

		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == a)
				count++;
		}
		return count;
	}

	public static boolean isPresent(char a, int indx, String s) {
		for (int i = indx; i >= 0; i--) {
			if (s.charAt(i) == a)
				return true;
		}
		return false;
	}

	public static boolean isPresent(int a, int indx, int ar[]) {
		for (int i = indx; i >= 0; i--) {
			if (ar[i] == a)
				return true;
		}
		return false;
	}

	public static void fibonacci(int t1, int t2, int n) {
		if (n == 0)
			return;
		else {
			int t3 = t1 + t2;
			t1 = t2;
			t2 = t3;
			System.out.println(t3);
			fibonacci(t1, t2, n - 1);
		}

	}

	public static int factorial(int n) {
		if (n == 1)
			return 1;
		else
			n = n * factorial(n - 1);
		return n;

	}

	public static String removeSpaces(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ')
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static int[] removeDuplicate(int[] a) {
		int arr[] = new int[a.length];
		int j = 0;
		for (int i = 0; i < a.length; i++) {
			if (!isPresent(a[i], i - 1, a))
				arr[j++] = a[i];
		}
		a = new int[j];
		System.out.println(j);
		for (int i = 0; i < j; i++)
			a[i] = arr[i];
		return a;
	}

	class C {
		static int a;
	}
}

class B {
	int a = 10;

	public String toString() {
		System.out.println("askfjal");
		return new String(this.a + "");
	}

	public void hello(int... a) {

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-12-24 23:21:10.374
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-12-24 23:21:10.375
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-12-24 23:21:11.014
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.pract;

import java.lang.reflect.InvocationTargetException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.springframework.jdbc.core.metadata.OracleCallMetaDataProvider;

interface DD {

}

class AB implements Comparable<AB> {
	int id = 0;
	String name = "rohit";

	@Override
	public int compareTo(AB o) {
		if (this.id < o.id)
			return 1;

		return -1;
	}

	@Override
	public String toString() {
		return "AB [id=" + id + ", name=" + name + "]";
	}

}

abstract class kd {

}

class Foodsystem {
	public String count;
	public Map<String, Integer> food = new LinkedHashMap<>();

	public String toString() {
		return count + " =" + food;
	}

}

public class Test {

	public Test(int a) {

	}

	public static void main(String[] args) throws Exception {
		// fibonacci(0,1,20);
		// Class<?> clas = Class.forName("com.pract.Test");

		// Constructor<?> to = clas.getConstructor(int.class);
		// Test t = (Test) to.newInstance();
		var a = new Test(8);

		// System.out.println(Integer.toBinaryString(2));

		// new Random().ints(1,999).limit(20).sorted().forEach(System.out::println);
		// List<Integer> list = List.of(1,2,3,4,5);
		// System.out.println(list.stream().mapToInt(v->v).max().getAsInt());
		// list.stream().max(Integer::compare);

//		
//		longestPolindrom("bcac");
//	
//	majorityElement(new  int []{1,2,3,4,5,5});
//		
//	anagram("abcda","bcdaa");
//	String sp="TEST@$QWES 89";
//	sp = sp.replaceAll("\\d+","");
//	System.out.println(sp);

//arrayLeftRotation(new int[] {1,2,3,4,5},4);
//arrayRightRotation(new int[] {1,2,3,4,5},2);
//arraySum(new int[] {1,2,3,4},new int[] {1,2,3});
//uniqueFromArrays(new int[] {1,2,4},new int[] {1,2,3,5});
//wordCount("Hello what are you doing here you fucking bitch bastard");
//String s[]=textToWordsArray("Hello what are you doing here you fucking bitch bastard ab bcd");

//char arr[]=stringToArrayOfCharacters("hello what");

//twoSum(new int[] {2,7,11,15},9);
//		System.out.println(medianOfTwoSortedArray(new int[] {3},new int[] {-2,-1}));
//		System.out.println(longestPolindromSubtString("cbbd"));
		// zigzapConversion("PAYPALISHIRING",4);
//		Date d = new Date();
//		SimpleDateFormat f = new SimpleDateFormat("dd/MM/yyyy");
//		Date parse = f.parse("12/9/2023");
//		//LocalDate.now().
//		LocalDate l = LocalDate.now();
//		LocalDate l2 = LocalDate.of(2024, 10, 11);
//		Period period = Period.between(l, l2);
//		period.between(l, l2);
//		DayOfWeek dayOfWeek = l2.getDayOfWeek();
//		System.out.println(dayOfWeek.toString());

//		int arr[] = new int[] { 1, 2, 4 };
//		int arr2[] = new int[] { 1, 3, 4 };
		// righRotation(arr, 2);
//inserAtNthPos(arr,3,3);

//arr=insertInSortedArray(arr,6);
//System.out.println(2%5);
//arr=mergeSortedArrays(arr,arr2);
//System.out.println(Arrays.toString(arr))
		// reverserInteger(-1234);
//convertToInteger("  -1234");

		// AB.main(new String[] {"a","b"});
		// AB ab = new AB();
//		ab.hello();
//Comparator<Integer> com = new Comparator<Integer>() {
//
//	@Override
//	public int compare(Integer o1, Integer o2) {
//	   
//		return o1.intValue()>o2.intValue()?o2:o1;
//	}
//	
//};
//com = (c,b) -> c<b?1:-1;
//
//TreeSet<AB>  t = new TreeSet<>(); 
//		AB a1 = new AB();
//		a1.id=10;
//		AB a2 = new AB();
//		a2.id=20;
//		AB a3 = new AB();
//		a3.id=30;
//		AB a4 = new AB();
//		a4.id=40;
//		AB a5 = new AB();
//		a5.id=50;
//		
//		t.add(a1);
//		t.add(a2);
//		t.add(a3);
//		t.add(a4);
//		t.add(a5);
//		System.out.println(t);
		// System.out.println(integerToRoman(400));
		// System.out.println(romanToInteger("D"));
		// System.out.println(nonRepeatingChar("abcabc"));
		// System.out.println(longestPrefix(new String[] {"flow","flowight","flower"}));
//		int arr1[] = { 10, 8, 7, 5, 4, 11, 78 };
//		int arr3[] = { -1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4 };
//		Arrays.sort(arr3);
		// System.out.println(threeSum(arr3));
//		recursionBubbleSort(arr1,0,0);
//		System.out.println(Arrays.toString(arr1));
//		List.of(arr);

//		System.out.println(Arrays.toString(mergeTwoSortedArray(new int[] {1,3,5,7,9},new int[] {2,4,6,7,8})));
//		System.out.println(Arrays.toString(selectionSortRecu(new int[] {7,9,4,3,2,1,54,3},0,1,0)));

//		System.out.println(Arrays.toString(insertionSort(new int[] {9,8,6,5,4,3,5})));
		// System.out.println(uniqueOccurance(new int[] {1,1,1,2,2,2,3,4,4,5,4,5}));;
//		System.out.println(reverseKElements(new int[] {1,2,3,4,5,6,7,8,9},2));

		// System.out.println(isArraySortedOrRotated(new int[] {5,6,7,8,1}));
		// System.out.println(Arrays.toString(twoSum2(new int[] {2 ,7,8,5,2,1},9)));
		// System.out.println(longestPrefixs(new String[] {"ab","aba","ad"}));
		// System.out.println(Arrays.toString(removeDuplicatess(new int[]
		// {1,1,2,2,3,4,4,5,55,5})));
		// System.out.println(firstOccurances("hadbadhad","had"));
		// String s[]= {"aaa","aec","adc","ae"};
//		Arrays.sort(s);
//		System.out.println(lastWordLength("hello world jav   "));
		// System.out.println(Arrays.toString(plusOneOptimized(new int[] {9,9,})));
		// System.out.println(isPolindrom("5?6?7?876?5"));
		// System.out.println(reverseWords("A man, a plan, a canal: Panama"));
//		System.out.println(mostOccurrance("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(mostOccurranceInString("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(replaceString("a man is one the street"));
//	System.out.println(replaceAllDigitsWithCharacter("a1b2c3"));
		// System.out.println(removeAllSubstring("aabababa","aba"));
//System.out.println(removeAllDuplicates("aabbccdeffghill"));
		// System.out.println(1%2);
//		char ch[]=new char[] {'a','a','a','b','b','a','a'};
//		int n=countLetters(ch);
//		for(int i=0;i<n;i++) {
//			System.out.print(ch[i]+",");
// 		System.out.println(System.currentTimeMillis());
//		}
//		System.out.println(Arrays.toString(mergeSorted(new int[] {1,2,3,4},3,new int[] {2,5,6},2)));
		// int arr[][] = new int[][] { { 1, 2, 3} ,{ 4, 5, 6} ,{7,8,9}};
//		printWave(arr,2,3);
		// System.out.println(reverseVowels("hello"));
//		printSprial(arr);
//		generateMatrix(5);
//		arr = rotateArray90(arr);
//		for(int i=0;i<arr.length;i++) {
//			for(int j=0;j<arr[0].length;j++)
//				System.out.print(arr[i][j]+" ");
//			System.out.println();
//		}

//		int arr []= {1,2};
		// rotateArrayWithK(arr, 3);
//		int arr[][] = {{1,2,3},{4,5,6},{7,8,9}};  
//		List<List<Integer>> shiftGrid = shiftGrid(arr, 2);
//		for(int i =0 ;i<shiftGrid.size();i++) {
//			System.out.println(shiftGrid.get(i));
//		}

//		System.out.println(maximumSumOfTwoSubStringScore("00111"));
//		System.out.println(convertArrayIn2DArray(new int[] {1,2,3,4,5,5,6,200,200}));
//	System.out.println(missingNumber(new int[] {9,6,4,2,3,5,7,0,1}));	
//		System.out.println(unique(new int[] {1,1,2,2,3,3,9}));
		// System.out.println(Arrays.toString(findErrorNums(new int[] {1,2,2,4})));
		//	kajuKatli(10);
		System.out.println(System.currentTimeMillis());
		System.out.println(minOperations("1000"));
		System.out.println(System.currentTimeMillis());
	}

	public static int minOperations(String s) {
		int count[] = new int[2];
		for(int i=0;i<s.length();i++) {
			count[s.charAt(i)-'0']++;
		}
		if(count[0]>count[1]) {
		return	(count[0]-count[1])/2;
		}
		(count[1]-count[0])/2;
		System.out.println(Arrays.toString(count));
		return 0;
	}
	
	
	public static int[] findErrorNums(int[] arr) {
		Set<Integer> value = new HashSet<>();
		int[] ar = new int[2];
		for (int i = 0; i < arr.length; i++) {
			if (value.contains(arr[i])) {
				ar[0] = arr[i];
				arr[1] = arr[i] + 1;
				System.out.println(arr[i] + 1);
				return ar;
			}
			value.add(arr[i]);
		}
		return ar;
	}

	public static int[] selectionSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			int min = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[j] < arr[min])
					min = j;
			}
			int temp = arr[i];
			arr[i] = arr[min];
			arr[min] = temp;

		}
		return arr;
	}

	public static int[] bubbleSortPr(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}

			}
		}
		return arr;
	}

	public static int unique(int arr[]) {
		int xor = 0;
		for (int i = 0; i < arr.length; i++) {
			xor ^= arr[i];
		}
		return xor;
	}

	public static int xorDuplicate(int arr[]) {

		for (int i = 0; i < arr.length; i++) {

		}
		return 0;
	}

	public static int missingNumber(int arr[]) {
		int max = findMaximum(arr);
		int total = max * (max + 1) / 2, sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return total - sum == 0 ? max + 1 : total - sum;
	}

	public static int countNumber(int arr[], int value) {
		int count = 0;

		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == value)
				count++;
			if (count > 2)
				return count;
		}
		return count;
	}

	public static int uniqueElement(int arr[]) {
		Set<Integer> value = Arrays.stream(arr).boxed().collect(Collectors.toSet());
		Iterator<Integer> iterator = value.iterator();
		while (iterator.hasNext()) {
			int va = iterator.next();
			if (count(arr, va) < 2)
				return va;
		}
		return -1;
	}

	public static int findMaximum(int arr[]) {
		int max = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] > max)
				max = arr[i];
		}
		return max;
	}

	public static List<List<Integer>> convertArrayIn2DArray(int arr[]) {
		// int max = findMaximum(arr);
		int count[] = new int[201];
		for (int i = 0; i < arr.length; i++)
			count[arr[i]]++;
//		System.out.println(Arrays.toString(count));
		int max = findMaximum(count);
		List<List<Integer>> response = new ArrayList<>();
		for (int i = 0; i < max; i++) {
			List<Integer> list = new ArrayList<>();
			for (int j = 0; j < count.length; j++) {
				if (count[j] > 0) {
					list.add(j);
					count[j]--;
				}
			}
			response.add(list);
		}

		return response;
	}

	public static int count(char arr[], int st, int end, char ch) {
		int count = 0;
		while (st <= end) {
			if (arr[st] == ch)
				count++;
			st++;
		}

		return count;
	}

	public static int maximumSumOfTwoSubStringScore(String s) {
		char[] arr = s.toCharArray();
		int i = 0, j = i + 1, max = 0;
		while (i < j && j < arr.length) {
			int cou = count(arr, i, j - 1, '0') + count(arr, j, arr.length - 1, '1');

			if (cou > max)
				max = cou;
			j++;
		}
		return max;
	}

	public static List<List<Integer>> shiftGrid(int arr[][], int k) {
		int row = arr.length, col = arr[0].length, j = row * col - 1, count = 0;
		while (count++ < k) {
			int ele = arr[arr.length - 1][arr[0].length - 1];
			for (j = row * col - 1; j > 0; j--) {
				arr[j / col][j % col] = arr[(j - 1) / col][(j - 1) % col];
			}
			arr[0][0] = ele;

		}
		List<List<Integer>> ar = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			List<Integer> ro = new ArrayList<>();
			for (j = 0; j < arr[0].length; j++) {
				ro.add(arr[i][j]);
			}
			ar.add(ro);

		}
		return ar;
	}

	public static boolean binarySearch2DInSortedRow(int arr[][], int target) {
		int row = 0, col = arr[0].length - 1;

		while (col >= 0 && row <= arr.length - 1) {
			if (arr[row][col] == target)
				return true;
			if (arr[row][col] < target)
				row++;
			else
				col--;
		}
		return false;
	}

	public static boolean binarySearchIn2D(int arr[][], int target) {
		int row = arr.length;
		int col = arr[0].length;
		int st = 0;
		int end = row * col - 1;

		while (st <= end) {
			int mid = st + (end - st) / 2;
			int element = arr[mid / col][mid % col];
			if (element == target)
				return true;
			if (element < target)
				st = mid + 1;
			else
				end = mid - 1;

		}
		return false;

	}

	public static void rotateArrayWithK(int arr[], int k) {
		int arr2[] = new int[arr.length], l = 0;
		int kIndex = arr.length - k;

		if (k >= arr.length) {
			int count = 0;
			while (count++ <= k) {
				int temp = arr[arr.length - 1];
				System.out.println(Arrays.toString(arr));
				for (int j = arr.length - 1; j > 0; j--) {
					arr[j] = arr[j - 1];
				}
				arr[0] = temp;
			}
			return;
		}

		if (kIndex < 0)
			return;
		for (int i = kIndex; i < arr.length; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < kIndex; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < arr.length; i++)
			arr[i] = arr2[i];

	}

	public static int[][] rotateArray90(int arr[][]) {
		int arr3[][] = new int[arr.length][arr[0].length], k = 0;
		for (int col = 0; col < arr[0].length; col++) {
			k = 0;
			for (int row = arr.length - 1; row >= 0; row--) {
				arr3[col][k++] = arr[row][col];
			}

		}
		return arr3;
	}

	public static int[][] generateMatrix(int n) {
		int row = n;
		int col = n;
		int total = n * n;
		int startingCol = 0;
		int startingRow = 0;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int arr[][] = new int[n][n];
		int count = 0;
		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				arr[startingRow][i] = ++count;
			}

			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				arr[i][endingCol] = ++count;
			}

			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				arr[endingRow][i] = ++count;
			}

			endingRow--;

			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				arr[i][startingCol] = ++count;
			}
			startingCol++;

		}
		return arr;
	}

	public static void printSprial(int arr[][]) {
		int startingCol = 0;
		int startingRow = 0;
		int row = arr.length;
		int col = arr[0].length;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int count = 0;
		int total = row * col;

		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				System.out.print(arr[startingRow][i]);
				count++;
			}
			System.out.println();
			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				System.out.print(arr[i][endingCol]);
				count++;
			}

			System.out.println();
			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				System.out.print(arr[endingRow][i]);
				count++;
			}

			endingRow--;
			System.out.println();
			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				System.out.print(arr[i][startingCol]);
				count++;
			}
			startingCol++;
			System.out.println();
		}
	}

	public static boolean isVowel(char ch) {
		ch = Character.toLowerCase(ch);
		if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
			return true;
		return false;
	}

	public static String reverseVowels(String s) {

		char[] arr = s.toCharArray();
		int i = 0, j = arr.length - 1;
		while (i < j) {
			if (isVowel(arr[i]) && isVowel(arr[j])) {
				char t = arr[i];
				arr[i] = arr[j];
				arr[j] = t;
				i++;
				j--;
			} else if (isVowel(arr[i]))
				j--;
			else
				i++;
		}
		return new String(arr);
	}

	public static void printWave(int arr[][], int row, int col) {
		for (int j = 0; j < col; j++) {

			for (int i = 0; i < row; i++) {
				System.out.print(arr[i][j]);
			}

			System.out.println();
			j++;
			for (int i = row - 1; i >= 0 && j < col; i--) {
				System.out.print(arr[i][j]);
			}
			System.out.println();

		}
	}

	public static int[] mergeSorted(int arr[], int m, int arr1[], int n) {
		int arr3[] = new int[m + n], i = 0, j = 0, k = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j] && n > 0) {
				arr3[k++] = arr1[j++];
				n--;
			} else if (m > 0) {
				arr3[k++] = arr[i++];
				m--;
			} else
				break;

		}
		System.out.println(Arrays.toString(arr3));
		while (m > 0 && i < arr.length) {
			arr3[k++] = arr[i++];
			m--;
		}
		while (n > 0 && j < arr1.length) {
			arr3[k++] = arr1[j++];
			n--;
		}
		return arr3;
	}

	public static List<Foodsystem> system = new ArrayList<>();

	public void enterData() {
		String food[] = { "kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi" };
		String country[] = { "korean", "japanese", "japanese", "greek", "japanese", "korean" };
		int arr[] = { 9, 12, 8, 15, 14, 7 };
		for (int i = 0; i < country.length; i++) {
			Map<String, Integer> fs = new LinkedHashMap<>();
			Foodsystem s = new Foodsystem();
			s.count = country[i];
			s.food.put(food[i], arr[i]);
			this.add(s);
		}
		System.out.println(system);

	}

	public void add(Foodsystem o) {
		for (int i = 0; i < this.system.size(); i++) {
			if (system.get(i).count.equals(o.count)) {
				system.get(i).food.putAll(o.food);
				return;
			}

		}
		this.system.add(o);
	}

	public void changeRating(String food, int rating) {
		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem f = system.get(i);
			if (f.food.containsKey(food)) {
				f.food.put(food, rating);
				return;
			}

		}

	}

	public String highestRating(String country) {
		String city = "";

		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem s = system.get(i);
			if (s.count.equals(country)) {
				int max = 0;
				Set<Entry<String, Integer>> entrySet = s.food.entrySet();
				System.out.println(entrySet);
				for (Entry<String, Integer> e : entrySet) {
					if (e.getValue() > max) {
						max = e.getValue();
						city = e.getKey();

					}
					if (e.getValue() == max) {
						s.food.put(e.getKey(), e.getValue());
					}
				}
			}

		}

		return city;
	}

	public static int countLetters(char[] s) {
		int k = 0;
		for (int i = 0; i < s.length;) {
			char ch = s[i];
			int j = i + 1, count = 1;

			while (j < s.length && s[j] == ch) {
				count++;
				j++;
			}
			System.out.println(ch + " " + count + " " + j);
			if (count > 1) {
				s[k++] = ch;
				for (char c : Integer.toString(count).toCharArray()) {
					if (k < s.length)
						s[k++] = c;
					else
						return k;
				}
			} else {
				s[k++] = ch;
			}
			i = j;
		}
		return k;
	}

	public static String removeAllDuplicates(String s) {
		StringBuilder sb = new StringBuilder();
		int count[] = new int[26];
		for (int i = 0; i < s.length(); i++) {
			int num = s.charAt(i) - 'a';
			count[num]++;
		}

		for (int i = 0; i < s.length(); i++) {
			if (count[(s.charAt(i) - 'a')] < 2)
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static String removeAllSubstring(String s, String part) {
		while (s.length() != 0 && s.contains(part))
			s = s.replaceFirst(part, "");

		return s;
	}

	public static String replaceAllDigitsWithCharacter(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
				sb.append((char) (s.charAt(i - 1) + (s.charAt(i) - 48)));
			else
				sb.append(s.charAt(i));
		}
		return sb.toString();

	}

	public static String replaceString(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == ' ')
				sb.append("@40");
			else
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static char mostOccurranceInString(String s) {
		int arr[] = new int[26]; // storing occurance of every letter according to index
		s = s.toLowerCase();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
				int num = s.charAt(i) - 'a';
				arr[num]++;
			}
		}

		// finding max
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < arr.length; i++) {
			if (max < arr[i]) {
				max = arr[i];
				ch = (char) i;
			}

		}
		return (char) (ch + 'a');

	}

	// brute force
	public static char mostOccurrance(String s) {
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < s.length(); i++) {
			int count = 0;
			for (int j = i + 1; j < s.length(); j++) {
				if (s.charAt(i) == s.charAt(j) && s.charAt(i) != ' ')
					count++;
			}

			if (count > max) {
				ch = s.charAt(i);
				max = count;
			}
		}
		return ch;
	}

	public static int climbStairs(int n) {

		if (n < 0)
			return 0;
		if (n == 0)
			return 1;
		return climbStairs(n - 1) + climbStairs(n - 2);
	}

	public static void reverseString(char[] ch, int st, int end) {

		while (st < end) {
			char temp = ch[st];
			ch[st] = ch[end];
			ch[end] = temp;
			st++;
			end--;
		}

	}

	public static char[] reverseWords(String s) {
		char ch[] = s.toCharArray();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ' && s.charAt(i) != ',') {
				int j = i + 1;
				for (; j < s.length(); j++) {
					if (s.charAt(j) == ' ' || s.charAt(j) == ',')
						break;
				}
				reverseString(ch, i, j - 1);
				i = j;
			}
		}
		return ch;
	}

	public static boolean isAlphaNumeric(char c) {
		if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9')
			return true;
		return false;
	}

	public static boolean isPolinromValidAlgo(String s) {
		StringBuilder b = new StringBuilder();
		// remove special characters only left alphanumeric
		for (int i = 0; i < s.length(); i++) {
			if (isAlphaNumeric(s.charAt(i)))
				b.append(s.charAt(i));

		}

		// to lower case
		String str = b.toString().toLowerCase();
		int st = 0, end = str.length() - 1;
		while (st < end) {
			if (str.charAt(st) != str.charAt(end))
				return false;
			st++;
			end--;
		}
		return true;

	}

	public static boolean isPolindrom(String s) {
		int st = 0, end = s.length() - 1;
		while (st < end) {
			if (s.charAt(st) >= '0' && s.charAt(st) <= '9') {
				if (s.charAt(end) >= '0' && s.charAt(end) <= '9') {

					if (s.charAt(st) != s.charAt(end))
						return false;
					else {
						st++;
						end--;
					}
				} else
					end--;
			} else
				st++;
		}
		return true;
	}

	// optimized
	public static int[] plusOneOptimized(int arr[]) {
		for (int i = arr.length - 1; i >= 0; i--) {
			if (arr[i] < 9) {
				arr[i]++;
				return arr;
			}
			arr[i] = 0;
		}
		arr = new int[arr.length + 1];
		arr[0] = 1;
		return arr;
	}

	// brute force
	public static int[] plusOne(int arr[]) {
		if (arr.length < 1)
			return arr;
		int carry = 1;
		for (int i = arr.length - 1; i >= 0; i--) {
			arr[i] = arr[i] + carry;
			carry = 0;
			if (arr[i] > 9) {
				arr[i] = 0;
				carry = 1;
			} else
				break;
		}

		if (carry != 0) {
			int ar[] = new int[arr.length + 1];
			ar[0] = carry;
			for (int i = 1; i < ar.length - 1; i++)
				ar[i] = arr[i];
			return ar;
		}
		return arr;
	}

	public static int countLastWordLength(String s, int index) {
		int count = 0;
		for (; index >= 0; index--) {
			if (s.charAt(index) != ' ')
				count++;
			else
				break;
		}
		return count;
	}

	public static int lastWordLength(String s) {
		for (int i = s.length() - 1; i >= 0; i--) {
			if (s.charAt(i) != ' ')
				return countLastWordLength(s, i);
		}
		return 0;
	}

	public static int firstOccurances(String s, String value) {
		if (s.contains(value)) {
			return s.indexOf(value);
		}
		return -1;
	}

	public static boolean isMatched(String s, String value) {
		if (s.length() < value.length())
			return false;
		for (int i = 0; i < value.length(); i++) {
			if (s.charAt(i) != value.charAt(i))
				return false;
		}
		return true;
	}

	public static int firstOccurance(String s, String value) {
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == value.charAt(0)) {
				if (isMatched(s.substring(i), value))
					return i;
			}
		}
		return -1;
	}

	public static int[] removeDuplicatess(int arr[]) {
		int i = 0, j = 1;
		for (i = 1; i < arr.length; i++) {
			if (arr[i - 1] != arr[i])
				arr[j++] = arr[i];
		}
		return arr;
	}

	public static int[] removeDuplicates(int arr[]) {
		Set<Integer> set = new LinkedHashSet<>();
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		return set.stream().mapToInt(i -> i).toArray();

	}

	public static String longestPrefixs(String arr[]) {
		Arrays.sort(arr);
		StringBuilder b = new StringBuilder();
		String first = arr[0];
		String last = arr[arr.length - 1];
		for (int i = 0; i < Math.min(first.length(), last.length()); i++) {
			if (first.charAt(i) != last.charAt(i))
				return b.toString();
			b.append(first.charAt(i));
		}
		return b.toString();

	}

	public static int[] twoSum2(int[] arr, int target) {
		int f = 0, l = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 1; j < arr.length; j++) {
				if (arr[i] + arr[j] == target) {
					f = i;
					l = j;
				}
			}
		}
		return new int[] { f, l };
	}

	public static Boolean arraySortedOrRotated(int arr[]) {
		int count = 0;
		for (int i = 1; i < arr.length; i++) {
			if (arr[i - 1] > arr[i])
				count++;
		}
		if (arr[0] < arr[arr.length - 1])
			count++;

		return count == 1;
	}

	// brute force
	public static Boolean isArraySortedOrRotated(int arr[]) {
		int i = 0;
		for (i = 0; i < arr.length - 1; i++) {
			if (arr[i] > arr[i + 1])
				break;

		}
		System.out.println(i + " -<");
		i++;
		for (; i < arr.length - 1; i++) {
			System.out.println("->" + i);
			if (arr[0] < arr[i] || arr[i] > arr[i + 1])
				return false;
		}
		if (i < arr.length && arr[0] < arr[i])
			return false;
		return true;
	}

	public static int findUnique(int arr[]) {
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {

			ans = ans ^ arr[i];
		}
		return ans;
	}

	public static int count(int arr[], int value) {
		int count = 0;
		for (int i = 0; i < arr.length; i++) {
			if (value == arr[i])
				count++;
		}
		return count;

	}

	public static int uniqueOccurance(int arr[]) {
		int arr1[] = new int[arr.length], k = 0;
		for (int i = 0; i < arr.length; i++) {
			if (!isPreExists(arr[i], arr, i - 1)) {

				int count = count(arr, arr[i]);
				arr1[k++] = count;
				System.out.println("count " + count);
			}
		}
		return findUniqueElement(arr1);
	}

	public static int[] reverse(int arr[], int st, int end) {
		if (end < arr.length)
			while (st < end) {
				int k = arr[st];
				arr[st++] = arr[end];
				arr[end--] = k;
			}
		return arr;
	}

	public static int[] reverseKElements(int arr[], int k) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length; i += k) {

			reverse(arr, i, i + k - 1);
		}
		System.out.println(Arrays.toString(arr));
		return arr;

	}

	public static boolean isPreExists(int value, int arr[], int k) {
		for (int i = k; i >= 0; i--) {
			if (arr[i] == value)
				return true;
		}
		return false;
	}

	public static int findUniqueElement(int arr[]) {
		System.out.println(Arrays.toString(arr));
		for (int i = 0; i < arr.length; i++) {
			int count = 0;
			if (!isPreExists(arr[i], arr, i - 1))
				for (int j = i; j < arr.length; j++) {

					if (arr[i] == arr[j])
						count++;
				}

			if (count == 1) {
				System.out.println("found " + arr[i]);

				return arr[i];
			}
		}
		return 0;
	}

	public static int[] insertionSort(int arr[]) {
		int j = 0;
		for (int i = 0; i < arr.length; i++) {
			int k = arr[i];
			for (j = i - 1; j >= 0; j--) {
				if (arr[j] < k) {
					arr[j + 1] = arr[j];
				} else
					break;
			}
			arr[j + 1] = k;
		}
		return arr;
	}

	public static int[] selectionSortRecu(int arr[], int i, int j, int min) {
		if (i >= arr.length)
			return arr;
		if (j < arr.length) {
			if (arr[min] > arr[j])
				min = j;
			return selectionSortRecu(arr, i, j + 1, min);
		}
		int k = arr[i];
		arr[i] = arr[min];
		arr[min] = k;
		return selectionSortRecu(arr, i + 1, i + 2, i + 1);
	}

	public static int[] mergeTwoSortedArray(int arr[], int arr1[]) {
		int arr3[] = new int[arr.length + arr1.length], k = 0, i = 0, j = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j]) {
				arr3[k++] = arr1[j++];

			} else {
				arr3[k++] = arr[i++];

			}
		}

		while (i < arr.length) {
			arr3[k++] = arr[i++];
		}
		while (j < arr1.length) {
			arr3[k++] = arr1[i++];
		}
		return arr3;
	}

	public static void recursionBubbleSort(int arr[], int i, int j) {
		if (i == arr.length)
			return;
		if (j < arr.length - i - 1 && arr[j] > arr[j + 1]) {

			int k = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = k;
			System.out.println(Arrays.toString(arr));
			recursionBubbleSort(arr, i, j + 1);

		} else {
			System.out.println("----- " + Arrays.toString(arr));
			recursionBubbleSort(arr, i + 1, 0);
		}

	}

	public static void bubbleSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int k = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = k;
				}

			}
		}
	}

	public static List<List<Integer>> threeSum(int arr[]) {
		int i = 0, j = 0, k = arr.length - 1;
		Set<List<Integer>> output = new HashSet<>();
		for (i = 0; i < arr.length; i++) {
			j = i + 1;
			k = arr.length - 1;
			while (j < k) {
				System.out.println(arr[i] + "->" + arr[j] + "->" + arr[k] + "=> " + (arr[i] + arr[j] + arr[k]) + " ( "
						+ i + "," + j + "," + k);
				if (arr[i] + arr[j] + arr[k] == 0) {
					List<Integer> list = new ArrayList<>();
					list.add(arr[i]);
					list.add(arr[j]);

					list.add(arr[k]);
					output.add(list);
				} else if (arr[i] + arr[j] + arr[k] > 0) {
					k--;
					j--;
				}
				j++;

			}
		}

		return output.stream().toList();

	}

	public static String longestPrefix(String s[]) {

		String prefix = "";

		for (int i = 0; i < s.length; i++) {
			for (int j = i + 1; j < s.length; j++) {
				if (s[i].length() > s[j].length()) {
					String temp = s[i];
					s[i] = s[j];
					s[j] = temp;
				}
			}
		}

		String st = s[0];
		boolean isMatched = false;
		for (int j = 0; j < st.length(); j++) {
			char ch = st.charAt(j);

			for (int k = 1; k < s.length; k++) {
				isMatched = false;

				if (ch == s[k].charAt(j)) {
					isMatched = true;
				} else
					break;
			}
			if (isMatched)
				prefix += ch;
			else
				break;

		}
		;
		return prefix;

	}

	public static String nonRepeatingChar(String s) {
		for (int i = 0; i < s.length(); i++) {
			boolean isPresent = false;
			for (int j = 0; j < s.length(); j++) {
				if (i != j && s.charAt(i) == s.charAt(j)) {
					isPresent = true;
					break;
				}
			}
			if (!isPresent) {
				return s.charAt(i) + "";
			}
		}
		return "All Are repated";
	}

	public static Integer romanToInteger(String s) {
		int num = 0;
		Map<String, Integer> romans = new HashMap<>();
		romans.put("M", 1000);
		romans.put("CM", 900);
		romans.put("D", 500);
		romans.put("CD", 400);
		romans.put("C", 100);
		romans.put("XC", 90);
		romans.put("L", 50);
		romans.put("XL", 40);
		romans.put("X", 10);
		romans.put("IX", 9);
		romans.put("V", 5);
		romans.put("IV", 4);
		romans.put("I", 1);
//System.out.println(romans.get("M"));
		if (s.length() < 2)
			return romans.get(s.charAt(0) + "");
		for (int i = 0; i < s.length() - 1; i++) {

			if (romans.get(s.charAt(i) + "").intValue() >= romans.get(s.charAt(i + 1) + "").intValue()) {
				num += romans.get(s.charAt(i) + "");
				System.out.println("num -> " + num);
			} else {

				int sum = romans.get(s.charAt(i + 1) + "") - romans.get(s.charAt(i) + "");
				System.out.println("num    => " + num + "  sum => " + sum);
				num += sum;
				i++;
				System.out.println("--------- " + num);
			}
			if (i == s.length() - 2)
				if (romans.get(s.charAt(i + 1) + "").intValue() <= romans.get(s.charAt(i) + "").intValue()) {
					num += romans.get(s.charAt(i + 1) + "");

				}
		}
		return num;
	}

	public static String integerToRoman(int num) {
		Integer number[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
		String romans[] = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };
		String result = "";
		for (int i = 0; i < number.length; i++) {

			while (num >= number[i]) {
				num -= number[i];
				result += romans[i];
			}
		}
		return result;

	}

	public static int convertToInteger(String s) {
		String st = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {
				st += s.charAt(i);
			} else if (s.charAt(i) == '-')
				st += s.charAt(i);
		}
		System.out.println(Integer.parseInt(st));
		return 0;
	}

	public static int reverserInteger(int n) {
		int rev = 0;
		while (n != 0) {
			int r = n % 10;
			n /= 10;
			rev = rev * 10 + r;
		}
		System.out.println(rev);
		return 0;
	}

	public static int[] mergeSortedArrays(int a1[], int a2[]) {
		int a3[] = new int[a1.length + a2.length], j = 0, k = 0, i = 0;

		Stack<Character> stack = new Stack();
		String s = "a";
		Character c = s.charAt(i);
		System.out.println(c.equals(c));

		while (i < a1.length && j < a2.length) {

			if (a1[i] >= a2[j])
				a3[k++] = a2[j++];
			else
				a3[k++] = a1[i++];

		}
		while (i < a1.length)
			a3[k++] = a1[i++];

		while (j < a2.length)
			a3[k++] = a2[j++];

		return a3;

	}

	public static int[] insertInSortedArray(int arr[], int value) {
		int temp[] = new int[arr.length + 1], j = 0;
		boolean isInserted = false;
		for (int i = 0; i < arr.length; i++) {

			if (!isInserted && arr[i] > value) {
				temp[j++] = value;
				isInserted = true;
			}
			temp[j++] = arr[i];
		}
		if (!isInserted)
			temp[j++] = value;
		return temp;
	}

	public static int[] inserAtNthPos(int arr[], int value, int pos) {
		int j = 0;
		int temp[] = new int[arr.length + 1];
		if (pos < 1)
			return arr;

		for (int i = 0; i < arr.length; i++) {
			if (i == pos - 1)
				temp[j++] = value;

			temp[j++] = arr[i];
		}
		if (pos > arr.length) {
			temp[j++] = value;
		}

//	for(int i=0;i<temp.length;i++)
//		arr[i]=temp[i];
		return temp;
	}

	public static void righRotation(int arr[], int num) {
		int n = arr.length, temp = 0, count = 0;
		while (count++ < num) {
			temp = arr[n - 1];
			for (int i = n - 1; i > 0; i--)
				arr[i] = arr[i - 1];
			arr[0] = temp;
		}

	}

	public static void leftRotation(int arr[], int num) {
		int temp[] = new int[arr.length], n = arr.length, j = 0;

		for (int i = num; i < n; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < num; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < n; i++)
			arr[i] = temp[i];
	}

	public static char[] copyArray(char[] arr) {
		if (arr == null)
			return new char[1];

		char[] a = Arrays.copyOf(arr, arr.length + 1);
		return a;
	}

	public static String zigzapConversion(String s, int num) {
		char[][] arr = new char[num][];
		int k = 0, i = 0, j = 0, t = 0;
		while (k < s.length()) {
			while (i != num - 1) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i++;
			}
			j++;
			while (i != 0) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i--;
			}
			j++;

		}
		for (char[] a : arr) {
			for (char tt : a)
				System.out.print(tt);
			System.out.println();
		}
		return "";
	}

	public static String longestPolindromSubtString(String s) {
		String ans = "";
		if (s.length() < 1)
			return s;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - 1; j >= 0; j--) {
				if (i < j) {
					String sub = s.substring(i, j + 1);
					if (sub.equals(new StringBuilder(sub).reverse().toString())) {
						if (sub.length() > ans.length()) {
							ans = sub;
						}

					}
				}
			}
		}

		return ans;
	}

	public static double medianOfTwoSortedArray(int[] arr1, int[] arr2) {

		int arr3[] = new int[arr1.length + arr2.length], i = 0, j = 0, k = 0;
		while (true) {
			if (i < arr1.length) {
				arr3[k++] = arr1[i++];
			} else if (j < arr2.length) {
				arr3[k++] = arr2[j++];
			} else
				break;

		}
		double ans = 0;
		Arrays.sort(arr3);
		System.out.println(Arrays.toString(arr3));
		if (arr3.length % 2 == 0) {
			int mid = arr3.length / 2;
			ans = (double) (arr3[mid - 1] + arr3[mid]) / 2;
			System.out.println(arr3[mid - 1]);
		} else {
			ans = arr3[arr3.length / 2];
		}

		return ans;
	}
// 4
// 1,1,1,1
// 2,1,1
// 1,1,2
// 2,2

	public static int[] twoSum(int arr[], int target) {
		int f = 0, sec = 0;
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {
				if (arr[i] + arr[j] == target && i != j) {

					f = i;
					sec = j;
				}
			}

		}
		System.out.println(f + " " + sec);
		return new int[] { f, sec };
	}

	public static char[] stringToArrayOfCharacters(String s) {
		char arr[] = new char[s.length()];
		for (int i = 0; i < s.length(); i++) {
			arr[i] = s.charAt(i);
		}
		return arr;
	}

	public static String[] textToWordsArray(String text) {
		List<String> words = new ArrayList<>();
		for (int i = 0; i < text.length(); i++) {

			for (int j = i; j < text.length() - 1; j++) {
				if (i > 0 && text.charAt(i) == ' ' && text.charAt(j + 1) == ' ' && text.charAt(i - 1) != ' ') {
					words.add(text.substring(i + 1, j + 1));
					break;
				} else if (i == 0 && text.charAt(j + 1) == ' ') {
					words.add(text.substring(i, j + 1));
					break;
				} else if (text.charAt(i) == ' ' && j + 1 == text.length() - 1) {
					words.add(text.substring(i + 1, text.length()));
					break;
				}
			}

		}
		String s[] = new String[words.size()];
		int i = 0;
		ListIterator<String> listIterator = words.listIterator();
		while (listIterator.hasNext()) {
			s[i++] = listIterator.next();
		}
		return s;
	}

	public static int wordCount(String s) {
		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0)
				count++;
			else if (s.charAt(i) == ' ')
				for (int j = i; j < s.length() - 1; j++) {
					if (s.charAt(j + 1) == ' ' && s.charAt(i - 1) != ' ') {
						count++;
						System.out.print(s.charAt(i) + " - > " + s.charAt(j) + " = " + count);
						break;
					}
				}
		}
		return count + 1;

	}

	public static void uniqueFromArrays(int arr[], int arr2[]) {

		List<Integer> list1 = List.of(1, 2, 4);
		List<Integer> list2 = List.of(1, 2, 3, 5);
		List<Integer> unique = new ArrayList<>();
		unique.addAll(list1);
		unique.addAll(list2);
		unique = unique.stream().distinct()
				.filter(a -> list1.contains(a) && !list2.contains(a) || !list1.contains(a) && list2.contains(a))
				.collect(Collectors.toList());
		System.out.println(unique);

		int k = 0;
		for (int i = 0; i < arr.length || k < arr2.length; i++, k++) {
			boolean a = false;
			boolean b = false;
			if (i < arr.length)
				for (int j = 0; j < arr2.length; j++) {
					if (arr[i] == arr2[j])
						a = true;
				}
			for (int j = 0; j < arr.length; j++) {
				if (arr2[k] == arr[j])
					b = true;
			}
			if (!a && i < arr.length)
				System.out.println(arr[i]);
			if (!b)
				System.out.println(arr2[k]);
		}
	}

	public static void arraySum(int arr[], int arr2[]) {
		int carry = 0, total = 0, j = 0, k = arr2.length - 1, i;
		List<Integer> sum = new ArrayList<>();

		for (i = arr.length - 1; i >= 0 && k >= 0; i--, k--) {

			total = arr[i] + arr2[k] + carry;
			carry = 0;
			if (total > 9) {
				carry = total % 10;
				total /= 10;
			}
			sum.add(total);

		}

		if (i < 0 && k >= 0) {
			for (int a = k; a >= 0; a--)
				sum.add(arr2[a]);
		}
		if (k < 0 && i >= 0) {
			for (int a = i; a >= 0; a--)
				sum.add(arr[a]);
		}
		Collections.reverse(sum);
		System.out.println(sum);
	}

	public static void arrayRightRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[arr.length - 1];
			for (j = arr.length - 1; j > 0; j--) {
				arr[j] = arr[j - 1];
			}
			count++;
			arr[0] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static void arrayLeftRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[0];
			for (j = 0; j < arr.length - 1; j++) {
				arr[j] = arr[j + 1];
			}
			count++;
			arr[j] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static boolean anagram(String s, String s1) {

		int count = 0;
		boolean b = false;
		for (int i = 0; i < s.length(); i++) {
			char ch = s.charAt(i);
			count = 0;
			b = false;
			for (int k = 0; k < s.length(); k++) {
				if (ch == s.charAt(k))
					count++;
			}

			for (int j = 0; j < s1.length(); j++) {
				if (count > 0 && ch == s1.charAt(j))
					count--;
			}
			if (count == 0)
				b = true;
		}

		System.out.println(b ? "yes" : "no");
		return b;
	}

	public static int count(int i, int arr[]) {
		int count = 0;
		for (int a : arr) {
			if (a == i)
				count++;
		}
		System.out.println(count);
		return count;
	}

	public static void majorityElement(int arr[]) {
		int max = 0, count = 0;
		for (int i = 0; i < arr.length; i++) {
			count = count(arr[i], arr);
			if (count >= max && count > arr.length / 2)
				max = arr[i];

		}
		System.out.println(max);
	}

	public static void longestPolindrom(String s) {

		int first = 0, last = s.length() - 1, max = 0;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - i; j >= 0; j--) {
				if (i < j && j < s.length())
					if (checkPolindrom(i, j + 1, s) && max < s.substring(i, j).length()) {

						max = s.substring(i, j + 1).length();
						first = i;
						last = j + 1;
					}
			}
			System.out.println("------");

		}
		System.out.println(s.substring(first, last));

	}

	public static boolean checkPolindrom(int f, int l, String s) {
		String st = s.substring(f, l);
		System.out.println(st + "444");
		return st.equals(new StringBuffer(st).reverse().toString());

	}

	public void spiralMatrix() throws ClassNotFoundException, NoSuchMethodException, SecurityException,
			InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		int a[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };
		int j = 0, k = 0, count = 0, max = 10 - 1;
		// int max=a.length*a.length-1;
		// System.out.println(a.length);

		for (int i = 0; i < a.length - i; i++) {

			if (count == max)
				break;

			for (j = i; j < a.length - i && count <= max; j++) {
				count++;
				System.out.println(a[k][j]);
			}
			j--;

			k++;
			while (k < a.length - i && count <= max) {
				System.out.println(a[k][j]);
				k++;
				count++;
			}
			k--;
			j--;

			while (j >= 0 && count <= max) {
				count++;
				System.out.println(a[k][j--]);
			}

			// k=i+1;
			if (k == a.length / 2 && j == a.length / 2)
				break;
			j++;
			while (k > i + 1 && count <= max) {
				System.out.println(a[--k][j]);
				count++;
			}

			k = i + 1;
			System.out.println("-----------------");
		}

	}

	public static ArrayList<Integer> findIndexes(int arr[], int sum) {
		boolean a = false;
		int f = 0, l = arr.length, s = 0;
		for (int i = 0; i < arr.length; i++) {
			s = 0;
			if (a)
				break;

			for (int j = i; j < arr.length; j++) {
				s += arr[j];
				if (s == sum) {
					f = i;
					l = j;
					a = true;
					break;
				}

			}
			System.out.println(s);
		}

		return a ? new ArrayList<Integer>(Arrays.asList(f, l)) : new ArrayList<Integer>(Arrays.asList(-1));
	}

	public int count(char a, String s) {
		class A {
			static int a;

			public void main() {
				System.out.println("hello");
			}
		}

		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == a)
				count++;
		}
		return count;
	}

	public static boolean isPresent(char a, int indx, String s) {
		for (int i = indx; i >= 0; i--) {
			if (s.charAt(i) == a)
				return true;
		}
		return false;
	}

	public static boolean isPresent(int a, int indx, int ar[]) {
		for (int i = indx; i >= 0; i--) {
			if (ar[i] == a)
				return true;
		}
		return false;
	}

	public static void fibonacci(int t1, int t2, int n) {
		if (n == 0)
			return;
		else {
			int t3 = t1 + t2;
			t1 = t2;
			t2 = t3;
			System.out.println(t3);
			fibonacci(t1, t2, n - 1);
		}

	}

	public static int factorial(int n) {
		if (n == 1)
			return 1;
		else
			n = n * factorial(n - 1);
		return n;

	}

	public static String removeSpaces(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ')
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static int[] removeDuplicate(int[] a) {
		int arr[] = new int[a.length];
		int j = 0;
		for (int i = 0; i < a.length; i++) {
			if (!isPresent(a[i], i - 1, a))
				arr[j++] = a[i];
		}
		a = new int[j];
		System.out.println(j);
		for (int i = 0; i < j; i++)
			a[i] = arr[i];
		return a;
	}

	class C {
		static int a;
	}
}

class B {
	int a = 10;

	public String toString() {
		System.out.println("askfjal");
		return new String(this.a + "");
	}

	public void hello(int... a) {

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-12-24 23:21:11.017
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-12-24 23:21:11.018
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-12-24 23:21:11.185
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.pract;

import java.lang.reflect.InvocationTargetException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.springframework.jdbc.core.metadata.OracleCallMetaDataProvider;

interface DD {

}

class AB implements Comparable<AB> {
	int id = 0;
	String name = "rohit";

	@Override
	public int compareTo(AB o) {
		if (this.id < o.id)
			return 1;

		return -1;
	}

	@Override
	public String toString() {
		return "AB [id=" + id + ", name=" + name + "]";
	}

}

abstract class kd {

}

class Foodsystem {
	public String count;
	public Map<String, Integer> food = new LinkedHashMap<>();

	public String toString() {
		return count + " =" + food;
	}

}

public class Test {

	public Test(int a) {

	}

	public static void main(String[] args) throws Exception {
		// fibonacci(0,1,20);
		// Class<?> clas = Class.forName("com.pract.Test");

		// Constructor<?> to = clas.getConstructor(int.class);
		// Test t = (Test) to.newInstance();
		var a = new Test(8);

		// System.out.println(Integer.toBinaryString(2));

		// new Random().ints(1,999).limit(20).sorted().forEach(System.out::println);
		// List<Integer> list = List.of(1,2,3,4,5);
		// System.out.println(list.stream().mapToInt(v->v).max().getAsInt());
		// list.stream().max(Integer::compare);

//		
//		longestPolindrom("bcac");
//	
//	majorityElement(new  int []{1,2,3,4,5,5});
//		
//	anagram("abcda","bcdaa");
//	String sp="TEST@$QWES 89";
//	sp = sp.replaceAll("\\d+","");
//	System.out.println(sp);

//arrayLeftRotation(new int[] {1,2,3,4,5},4);
//arrayRightRotation(new int[] {1,2,3,4,5},2);
//arraySum(new int[] {1,2,3,4},new int[] {1,2,3});
//uniqueFromArrays(new int[] {1,2,4},new int[] {1,2,3,5});
//wordCount("Hello what are you doing here you fucking bitch bastard");
//String s[]=textToWordsArray("Hello what are you doing here you fucking bitch bastard ab bcd");

//char arr[]=stringToArrayOfCharacters("hello what");

//twoSum(new int[] {2,7,11,15},9);
//		System.out.println(medianOfTwoSortedArray(new int[] {3},new int[] {-2,-1}));
//		System.out.println(longestPolindromSubtString("cbbd"));
		// zigzapConversion("PAYPALISHIRING",4);
//		Date d = new Date();
//		SimpleDateFormat f = new SimpleDateFormat("dd/MM/yyyy");
//		Date parse = f.parse("12/9/2023");
//		//LocalDate.now().
//		LocalDate l = LocalDate.now();
//		LocalDate l2 = LocalDate.of(2024, 10, 11);
//		Period period = Period.between(l, l2);
//		period.between(l, l2);
//		DayOfWeek dayOfWeek = l2.getDayOfWeek();
//		System.out.println(dayOfWeek.toString());

//		int arr[] = new int[] { 1, 2, 4 };
//		int arr2[] = new int[] { 1, 3, 4 };
		// righRotation(arr, 2);
//inserAtNthPos(arr,3,3);

//arr=insertInSortedArray(arr,6);
//System.out.println(2%5);
//arr=mergeSortedArrays(arr,arr2);
//System.out.println(Arrays.toString(arr))
		// reverserInteger(-1234);
//convertToInteger("  -1234");

		// AB.main(new String[] {"a","b"});
		// AB ab = new AB();
//		ab.hello();
//Comparator<Integer> com = new Comparator<Integer>() {
//
//	@Override
//	public int compare(Integer o1, Integer o2) {
//	   
//		return o1.intValue()>o2.intValue()?o2:o1;
//	}
//	
//};
//com = (c,b) -> c<b?1:-1;
//
//TreeSet<AB>  t = new TreeSet<>(); 
//		AB a1 = new AB();
//		a1.id=10;
//		AB a2 = new AB();
//		a2.id=20;
//		AB a3 = new AB();
//		a3.id=30;
//		AB a4 = new AB();
//		a4.id=40;
//		AB a5 = new AB();
//		a5.id=50;
//		
//		t.add(a1);
//		t.add(a2);
//		t.add(a3);
//		t.add(a4);
//		t.add(a5);
//		System.out.println(t);
		// System.out.println(integerToRoman(400));
		// System.out.println(romanToInteger("D"));
		// System.out.println(nonRepeatingChar("abcabc"));
		// System.out.println(longestPrefix(new String[] {"flow","flowight","flower"}));
//		int arr1[] = { 10, 8, 7, 5, 4, 11, 78 };
//		int arr3[] = { -1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4 };
//		Arrays.sort(arr3);
		// System.out.println(threeSum(arr3));
//		recursionBubbleSort(arr1,0,0);
//		System.out.println(Arrays.toString(arr1));
//		List.of(arr);

//		System.out.println(Arrays.toString(mergeTwoSortedArray(new int[] {1,3,5,7,9},new int[] {2,4,6,7,8})));
//		System.out.println(Arrays.toString(selectionSortRecu(new int[] {7,9,4,3,2,1,54,3},0,1,0)));

//		System.out.println(Arrays.toString(insertionSort(new int[] {9,8,6,5,4,3,5})));
		// System.out.println(uniqueOccurance(new int[] {1,1,1,2,2,2,3,4,4,5,4,5}));;
//		System.out.println(reverseKElements(new int[] {1,2,3,4,5,6,7,8,9},2));

		// System.out.println(isArraySortedOrRotated(new int[] {5,6,7,8,1}));
		// System.out.println(Arrays.toString(twoSum2(new int[] {2 ,7,8,5,2,1},9)));
		// System.out.println(longestPrefixs(new String[] {"ab","aba","ad"}));
		// System.out.println(Arrays.toString(removeDuplicatess(new int[]
		// {1,1,2,2,3,4,4,5,55,5})));
		// System.out.println(firstOccurances("hadbadhad","had"));
		// String s[]= {"aaa","aec","adc","ae"};
//		Arrays.sort(s);
//		System.out.println(lastWordLength("hello world jav   "));
		// System.out.println(Arrays.toString(plusOneOptimized(new int[] {9,9,})));
		// System.out.println(isPolindrom("5?6?7?876?5"));
		// System.out.println(reverseWords("A man, a plan, a canal: Panama"));
//		System.out.println(mostOccurrance("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(mostOccurranceInString("There are many variations of passages of Lorem Ipsum available, but the majority have suffered alteration in some form, by injected humour, or randomised words which don't look even slightly believable. If you are going to use a passage of Lorem Ipsum, you need to be sure there isn't anything embarrassing hidden in the middle of text. All the Lorem Ipsum generators on the Internet tend to repeat predefined chunks as necessary, making this the first true generator on the Internet. It uses a dictionary of over 200 Latin words, combined with a handful of model sentence structures, to generate Lorem Ipsum which looks reasonable. The generated Lorem Ipsum is therefore always free from repetition, injected humour, or non-characteristic words etc."));   // stuck after 30
//		System.out.println(replaceString("a man is one the street"));
//	System.out.println(replaceAllDigitsWithCharacter("a1b2c3"));
		// System.out.println(removeAllSubstring("aabababa","aba"));
//System.out.println(removeAllDuplicates("aabbccdeffghill"));
		// System.out.println(1%2);
//		char ch[]=new char[] {'a','a','a','b','b','a','a'};
//		int n=countLetters(ch);
//		for(int i=0;i<n;i++) {
//			System.out.print(ch[i]+",");
// 		System.out.println(System.currentTimeMillis());
//		}
//		System.out.println(Arrays.toString(mergeSorted(new int[] {1,2,3,4},3,new int[] {2,5,6},2)));
		// int arr[][] = new int[][] { { 1, 2, 3} ,{ 4, 5, 6} ,{7,8,9}};
//		printWave(arr,2,3);
		// System.out.println(reverseVowels("hello"));
//		printSprial(arr);
//		generateMatrix(5);
//		arr = rotateArray90(arr);
//		for(int i=0;i<arr.length;i++) {
//			for(int j=0;j<arr[0].length;j++)
//				System.out.print(arr[i][j]+" ");
//			System.out.println();
//		}

//		int arr []= {1,2};
		// rotateArrayWithK(arr, 3);
//		int arr[][] = {{1,2,3},{4,5,6},{7,8,9}};  
//		List<List<Integer>> shiftGrid = shiftGrid(arr, 2);
//		for(int i =0 ;i<shiftGrid.size();i++) {
//			System.out.println(shiftGrid.get(i));
//		}

//		System.out.println(maximumSumOfTwoSubStringScore("00111"));
//		System.out.println(convertArrayIn2DArray(new int[] {1,2,3,4,5,5,6,200,200}));
//	System.out.println(missingNumber(new int[] {9,6,4,2,3,5,7,0,1}));	
//		System.out.println(unique(new int[] {1,1,2,2,3,3,9}));
		// System.out.println(Arrays.toString(findErrorNums(new int[] {1,2,2,4})));
		//	kajuKatli(10);
		System.out.println(System.currentTimeMillis());
		System.out.println(minOperations("1000"));
		System.out.println(System.currentTimeMillis());
	}

	public static int minOperations(String s) {
		int count[] = new int[2];
		for(int i=0;i<s.length();i++) {
			count[s.charAt(i)-'0']++;
		}
		if(count[0]>count[1]) {
		return	(count[0]-count[1])/2;
		}
		(count[1]-count[0])/2;
		System.out.println(Arrays.toString(count));
		return 0;
	}
	
	
	public static int[] findErrorNums(int[] arr) {
		Set<Integer> value = new HashSet<>();
		int[] ar = new int[2];
		for (int i = 0; i < arr.length; i++) {
			if (value.contains(arr[i])) {
				ar[0] = arr[i];
				arr[1] = arr[i] + 1;
				System.out.println(arr[i] + 1);
				return ar;
			}
			value.add(arr[i]);
		}
		return ar;
	}

	public static int[] selectionSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			int min = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[j] < arr[min])
					min = j;
			}
			int temp = arr[i];
			arr[i] = arr[min];
			arr[min] = temp;

		}
		return arr;
	}

	public static int[] bubbleSortPr(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}

			}
		}
		return arr;
	}

	public static int unique(int arr[]) {
		int xor = 0;
		for (int i = 0; i < arr.length; i++) {
			xor ^= arr[i];
		}
		return xor;
	}

	public static int xorDuplicate(int arr[]) {

		for (int i = 0; i < arr.length; i++) {

		}
		return 0;
	}

	public static int missingNumber(int arr[]) {
		int max = findMaximum(arr);
		int total = max * (max + 1) / 2, sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return total - sum == 0 ? max + 1 : total - sum;
	}

	public static int countNumber(int arr[], int value) {
		int count = 0;

		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == value)
				count++;
			if (count > 2)
				return count;
		}
		return count;
	}

	public static int uniqueElement(int arr[]) {
		Set<Integer> value = Arrays.stream(arr).boxed().collect(Collectors.toSet());
		Iterator<Integer> iterator = value.iterator();
		while (iterator.hasNext()) {
			int va = iterator.next();
			if (count(arr, va) < 2)
				return va;
		}
		return -1;
	}

	public static int findMaximum(int arr[]) {
		int max = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] > max)
				max = arr[i];
		}
		return max;
	}

	public static List<List<Integer>> convertArrayIn2DArray(int arr[]) {
		// int max = findMaximum(arr);
		int count[] = new int[201];
		for (int i = 0; i < arr.length; i++)
			count[arr[i]]++;
//		System.out.println(Arrays.toString(count));
		int max = findMaximum(count);
		List<List<Integer>> response = new ArrayList<>();
		for (int i = 0; i < max; i++) {
			List<Integer> list = new ArrayList<>();
			for (int j = 0; j < count.length; j++) {
				if (count[j] > 0) {
					list.add(j);
					count[j]--;
				}
			}
			response.add(list);
		}

		return response;
	}

	public static int count(char arr[], int st, int end, char ch) {
		int count = 0;
		while (st <= end) {
			if (arr[st] == ch)
				count++;
			st++;
		}

		return count;
	}

	public static int maximumSumOfTwoSubStringScore(String s) {
		char[] arr = s.toCharArray();
		int i = 0, j = i + 1, max = 0;
		while (i < j && j < arr.length) {
			int cou = count(arr, i, j - 1, '0') + count(arr, j, arr.length - 1, '1');

			if (cou > max)
				max = cou;
			j++;
		}
		return max;
	}

	public static List<List<Integer>> shiftGrid(int arr[][], int k) {
		int row = arr.length, col = arr[0].length, j = row * col - 1, count = 0;
		while (count++ < k) {
			int ele = arr[arr.length - 1][arr[0].length - 1];
			for (j = row * col - 1; j > 0; j--) {
				arr[j / col][j % col] = arr[(j - 1) / col][(j - 1) % col];
			}
			arr[0][0] = ele;

		}
		List<List<Integer>> ar = new ArrayList<>();
		for (int i = 0; i < arr.length; i++) {
			List<Integer> ro = new ArrayList<>();
			for (j = 0; j < arr[0].length; j++) {
				ro.add(arr[i][j]);
			}
			ar.add(ro);

		}
		return ar;
	}

	public static boolean binarySearch2DInSortedRow(int arr[][], int target) {
		int row = 0, col = arr[0].length - 1;

		while (col >= 0 && row <= arr.length - 1) {
			if (arr[row][col] == target)
				return true;
			if (arr[row][col] < target)
				row++;
			else
				col--;
		}
		return false;
	}

	public static boolean binarySearchIn2D(int arr[][], int target) {
		int row = arr.length;
		int col = arr[0].length;
		int st = 0;
		int end = row * col - 1;

		while (st <= end) {
			int mid = st + (end - st) / 2;
			int element = arr[mid / col][mid % col];
			if (element == target)
				return true;
			if (element < target)
				st = mid + 1;
			else
				end = mid - 1;

		}
		return false;

	}

	public static void rotateArrayWithK(int arr[], int k) {
		int arr2[] = new int[arr.length], l = 0;
		int kIndex = arr.length - k;

		if (k >= arr.length) {
			int count = 0;
			while (count++ <= k) {
				int temp = arr[arr.length - 1];
				System.out.println(Arrays.toString(arr));
				for (int j = arr.length - 1; j > 0; j--) {
					arr[j] = arr[j - 1];
				}
				arr[0] = temp;
			}
			return;
		}

		if (kIndex < 0)
			return;
		for (int i = kIndex; i < arr.length; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < kIndex; i++)
			arr2[l++] = arr[i];

		for (int i = 0; i < arr.length; i++)
			arr[i] = arr2[i];

	}

	public static int[][] rotateArray90(int arr[][]) {
		int arr3[][] = new int[arr.length][arr[0].length], k = 0;
		for (int col = 0; col < arr[0].length; col++) {
			k = 0;
			for (int row = arr.length - 1; row >= 0; row--) {
				arr3[col][k++] = arr[row][col];
			}

		}
		return arr3;
	}

	public static int[][] generateMatrix(int n) {
		int row = n;
		int col = n;
		int total = n * n;
		int startingCol = 0;
		int startingRow = 0;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int arr[][] = new int[n][n];
		int count = 0;
		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				arr[startingRow][i] = ++count;
			}

			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				arr[i][endingCol] = ++count;
			}

			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				arr[endingRow][i] = ++count;
			}

			endingRow--;

			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				arr[i][startingCol] = ++count;
			}
			startingCol++;

		}
		return arr;
	}

	public static void printSprial(int arr[][]) {
		int startingCol = 0;
		int startingRow = 0;
		int row = arr.length;
		int col = arr[0].length;
		int endingRow = row - 1;
		int endingCol = col - 1;
		int count = 0;
		int total = row * col;

		while (count < total) {
			// first row
			for (int i = startingCol; count < total && i <= endingCol; i++) {
				System.out.print(arr[startingRow][i]);
				count++;
			}
			System.out.println();
			startingRow++;
			// second row
			for (int i = startingRow; count < total && i <= endingRow; i++) {
				System.out.print(arr[i][endingCol]);
				count++;
			}

			System.out.println();
			endingCol--;
			// third row
			for (int i = endingCol; count < total && i >= startingCol; i--) {
				System.out.print(arr[endingRow][i]);
				count++;
			}

			endingRow--;
			System.out.println();
			// fourth row
			for (int i = endingRow; count < total && i >= startingRow; i--) {
				System.out.print(arr[i][startingCol]);
				count++;
			}
			startingCol++;
			System.out.println();
		}
	}

	public static boolean isVowel(char ch) {
		ch = Character.toLowerCase(ch);
		if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
			return true;
		return false;
	}

	public static String reverseVowels(String s) {

		char[] arr = s.toCharArray();
		int i = 0, j = arr.length - 1;
		while (i < j) {
			if (isVowel(arr[i]) && isVowel(arr[j])) {
				char t = arr[i];
				arr[i] = arr[j];
				arr[j] = t;
				i++;
				j--;
			} else if (isVowel(arr[i]))
				j--;
			else
				i++;
		}
		return new String(arr);
	}

	public static void printWave(int arr[][], int row, int col) {
		for (int j = 0; j < col; j++) {

			for (int i = 0; i < row; i++) {
				System.out.print(arr[i][j]);
			}

			System.out.println();
			j++;
			for (int i = row - 1; i >= 0 && j < col; i--) {
				System.out.print(arr[i][j]);
			}
			System.out.println();

		}
	}

	public static int[] mergeSorted(int arr[], int m, int arr1[], int n) {
		int arr3[] = new int[m + n], i = 0, j = 0, k = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j] && n > 0) {
				arr3[k++] = arr1[j++];
				n--;
			} else if (m > 0) {
				arr3[k++] = arr[i++];
				m--;
			} else
				break;

		}
		System.out.println(Arrays.toString(arr3));
		while (m > 0 && i < arr.length) {
			arr3[k++] = arr[i++];
			m--;
		}
		while (n > 0 && j < arr1.length) {
			arr3[k++] = arr1[j++];
			n--;
		}
		return arr3;
	}

	public static List<Foodsystem> system = new ArrayList<>();

	public void enterData() {
		String food[] = { "kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi" };
		String country[] = { "korean", "japanese", "japanese", "greek", "japanese", "korean" };
		int arr[] = { 9, 12, 8, 15, 14, 7 };
		for (int i = 0; i < country.length; i++) {
			Map<String, Integer> fs = new LinkedHashMap<>();
			Foodsystem s = new Foodsystem();
			s.count = country[i];
			s.food.put(food[i], arr[i]);
			this.add(s);
		}
		System.out.println(system);

	}

	public void add(Foodsystem o) {
		for (int i = 0; i < this.system.size(); i++) {
			if (system.get(i).count.equals(o.count)) {
				system.get(i).food.putAll(o.food);
				return;
			}

		}
		this.system.add(o);
	}

	public void changeRating(String food, int rating) {
		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem f = system.get(i);
			if (f.food.containsKey(food)) {
				f.food.put(food, rating);
				return;
			}

		}

	}

	public String highestRating(String country) {
		String city = "";

		for (int i = 0; i < this.system.size(); i++) {
			Foodsystem s = system.get(i);
			if (s.count.equals(country)) {
				int max = 0;
				Set<Entry<String, Integer>> entrySet = s.food.entrySet();
				System.out.println(entrySet);
				for (Entry<String, Integer> e : entrySet) {
					if (e.getValue() > max) {
						max = e.getValue();
						city = e.getKey();

					}
					if (e.getValue() == max) {
						s.food.put(e.getKey(), e.getValue());
					}
				}
			}

		}

		return city;
	}

	public static int countLetters(char[] s) {
		int k = 0;
		for (int i = 0; i < s.length;) {
			char ch = s[i];
			int j = i + 1, count = 1;

			while (j < s.length && s[j] == ch) {
				count++;
				j++;
			}
			System.out.println(ch + " " + count + " " + j);
			if (count > 1) {
				s[k++] = ch;
				for (char c : Integer.toString(count).toCharArray()) {
					if (k < s.length)
						s[k++] = c;
					else
						return k;
				}
			} else {
				s[k++] = ch;
			}
			i = j;
		}
		return k;
	}

	public static String removeAllDuplicates(String s) {
		StringBuilder sb = new StringBuilder();
		int count[] = new int[26];
		for (int i = 0; i < s.length(); i++) {
			int num = s.charAt(i) - 'a';
			count[num]++;
		}

		for (int i = 0; i < s.length(); i++) {
			if (count[(s.charAt(i) - 'a')] < 2)
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static String removeAllSubstring(String s, String part) {
		while (s.length() != 0 && s.contains(part))
			s = s.replaceFirst(part, "");

		return s;
	}

	public static String replaceAllDigitsWithCharacter(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
				sb.append((char) (s.charAt(i - 1) + (s.charAt(i) - 48)));
			else
				sb.append(s.charAt(i));
		}
		return sb.toString();

	}

	public static String replaceString(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == ' ')
				sb.append("@40");
			else
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static char mostOccurranceInString(String s) {
		int arr[] = new int[26]; // storing occurance of every letter according to index
		s = s.toLowerCase();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {
				int num = s.charAt(i) - 'a';
				arr[num]++;
			}
		}

		// finding max
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < arr.length; i++) {
			if (max < arr[i]) {
				max = arr[i];
				ch = (char) i;
			}

		}
		return (char) (ch + 'a');

	}

	// brute force
	public static char mostOccurrance(String s) {
		int max = 0;
		char ch = ' ';
		for (int i = 0; i < s.length(); i++) {
			int count = 0;
			for (int j = i + 1; j < s.length(); j++) {
				if (s.charAt(i) == s.charAt(j) && s.charAt(i) != ' ')
					count++;
			}

			if (count > max) {
				ch = s.charAt(i);
				max = count;
			}
		}
		return ch;
	}

	public static int climbStairs(int n) {

		if (n < 0)
			return 0;
		if (n == 0)
			return 1;
		return climbStairs(n - 1) + climbStairs(n - 2);
	}

	public static void reverseString(char[] ch, int st, int end) {

		while (st < end) {
			char temp = ch[st];
			ch[st] = ch[end];
			ch[end] = temp;
			st++;
			end--;
		}

	}

	public static char[] reverseWords(String s) {
		char ch[] = s.toCharArray();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ' && s.charAt(i) != ',') {
				int j = i + 1;
				for (; j < s.length(); j++) {
					if (s.charAt(j) == ' ' || s.charAt(j) == ',')
						break;
				}
				reverseString(ch, i, j - 1);
				i = j;
			}
		}
		return ch;
	}

	public static boolean isAlphaNumeric(char c) {
		if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9')
			return true;
		return false;
	}

	public static boolean isPolinromValidAlgo(String s) {
		StringBuilder b = new StringBuilder();
		// remove special characters only left alphanumeric
		for (int i = 0; i < s.length(); i++) {
			if (isAlphaNumeric(s.charAt(i)))
				b.append(s.charAt(i));

		}

		// to lower case
		String str = b.toString().toLowerCase();
		int st = 0, end = str.length() - 1;
		while (st < end) {
			if (str.charAt(st) != str.charAt(end))
				return false;
			st++;
			end--;
		}
		return true;

	}

	public static boolean isPolindrom(String s) {
		int st = 0, end = s.length() - 1;
		while (st < end) {
			if (s.charAt(st) >= '0' && s.charAt(st) <= '9') {
				if (s.charAt(end) >= '0' && s.charAt(end) <= '9') {

					if (s.charAt(st) != s.charAt(end))
						return false;
					else {
						st++;
						end--;
					}
				} else
					end--;
			} else
				st++;
		}
		return true;
	}

	// optimized
	public static int[] plusOneOptimized(int arr[]) {
		for (int i = arr.length - 1; i >= 0; i--) {
			if (arr[i] < 9) {
				arr[i]++;
				return arr;
			}
			arr[i] = 0;
		}
		arr = new int[arr.length + 1];
		arr[0] = 1;
		return arr;
	}

	// brute force
	public static int[] plusOne(int arr[]) {
		if (arr.length < 1)
			return arr;
		int carry = 1;
		for (int i = arr.length - 1; i >= 0; i--) {
			arr[i] = arr[i] + carry;
			carry = 0;
			if (arr[i] > 9) {
				arr[i] = 0;
				carry = 1;
			} else
				break;
		}

		if (carry != 0) {
			int ar[] = new int[arr.length + 1];
			ar[0] = carry;
			for (int i = 1; i < ar.length - 1; i++)
				ar[i] = arr[i];
			return ar;
		}
		return arr;
	}

	public static int countLastWordLength(String s, int index) {
		int count = 0;
		for (; index >= 0; index--) {
			if (s.charAt(index) != ' ')
				count++;
			else
				break;
		}
		return count;
	}

	public static int lastWordLength(String s) {
		for (int i = s.length() - 1; i >= 0; i--) {
			if (s.charAt(i) != ' ')
				return countLastWordLength(s, i);
		}
		return 0;
	}

	public static int firstOccurances(String s, String value) {
		if (s.contains(value)) {
			return s.indexOf(value);
		}
		return -1;
	}

	public static boolean isMatched(String s, String value) {
		if (s.length() < value.length())
			return false;
		for (int i = 0; i < value.length(); i++) {
			if (s.charAt(i) != value.charAt(i))
				return false;
		}
		return true;
	}

	public static int firstOccurance(String s, String value) {
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == value.charAt(0)) {
				if (isMatched(s.substring(i), value))
					return i;
			}
		}
		return -1;
	}

	public static int[] removeDuplicatess(int arr[]) {
		int i = 0, j = 1;
		for (i = 1; i < arr.length; i++) {
			if (arr[i - 1] != arr[i])
				arr[j++] = arr[i];
		}
		return arr;
	}

	public static int[] removeDuplicates(int arr[]) {
		Set<Integer> set = new LinkedHashSet<>();
		for (int i = 0; i < arr.length; i++) {
			set.add(arr[i]);
		}
		return set.stream().mapToInt(i -> i).toArray();

	}

	public static String longestPrefixs(String arr[]) {
		Arrays.sort(arr);
		StringBuilder b = new StringBuilder();
		String first = arr[0];
		String last = arr[arr.length - 1];
		for (int i = 0; i < Math.min(first.length(), last.length()); i++) {
			if (first.charAt(i) != last.charAt(i))
				return b.toString();
			b.append(first.charAt(i));
		}
		return b.toString();

	}

	public static int[] twoSum2(int[] arr, int target) {
		int f = 0, l = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 1; j < arr.length; j++) {
				if (arr[i] + arr[j] == target) {
					f = i;
					l = j;
				}
			}
		}
		return new int[] { f, l };
	}

	public static Boolean arraySortedOrRotated(int arr[]) {
		int count = 0;
		for (int i = 1; i < arr.length; i++) {
			if (arr[i - 1] > arr[i])
				count++;
		}
		if (arr[0] < arr[arr.length - 1])
			count++;

		return count == 1;
	}

	// brute force
	public static Boolean isArraySortedOrRotated(int arr[]) {
		int i = 0;
		for (i = 0; i < arr.length - 1; i++) {
			if (arr[i] > arr[i + 1])
				break;

		}
		System.out.println(i + " -<");
		i++;
		for (; i < arr.length - 1; i++) {
			System.out.println("->" + i);
			if (arr[0] < arr[i] || arr[i] > arr[i + 1])
				return false;
		}
		if (i < arr.length && arr[0] < arr[i])
			return false;
		return true;
	}

	public static int findUnique(int arr[]) {
		int ans = 0;
		for (int i = 0; i < arr.length; i++) {

			ans = ans ^ arr[i];
		}
		return ans;
	}

	public static int count(int arr[], int value) {
		int count = 0;
		for (int i = 0; i < arr.length; i++) {
			if (value == arr[i])
				count++;
		}
		return count;

	}

	public static int uniqueOccurance(int arr[]) {
		int arr1[] = new int[arr.length], k = 0;
		for (int i = 0; i < arr.length; i++) {
			if (!isPreExists(arr[i], arr, i - 1)) {

				int count = count(arr, arr[i]);
				arr1[k++] = count;
				System.out.println("count " + count);
			}
		}
		return findUniqueElement(arr1);
	}

	public static int[] reverse(int arr[], int st, int end) {
		if (end < arr.length)
			while (st < end) {
				int k = arr[st];
				arr[st++] = arr[end];
				arr[end--] = k;
			}
		return arr;
	}

	public static int[] reverseKElements(int arr[], int k) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length; i += k) {

			reverse(arr, i, i + k - 1);
		}
		System.out.println(Arrays.toString(arr));
		return arr;

	}

	public static boolean isPreExists(int value, int arr[], int k) {
		for (int i = k; i >= 0; i--) {
			if (arr[i] == value)
				return true;
		}
		return false;
	}

	public static int findUniqueElement(int arr[]) {
		System.out.println(Arrays.toString(arr));
		for (int i = 0; i < arr.length; i++) {
			int count = 0;
			if (!isPreExists(arr[i], arr, i - 1))
				for (int j = i; j < arr.length; j++) {

					if (arr[i] == arr[j])
						count++;
				}

			if (count == 1) {
				System.out.println("found " + arr[i]);

				return arr[i];
			}
		}
		return 0;
	}

	public static int[] insertionSort(int arr[]) {
		int j = 0;
		for (int i = 0; i < arr.length; i++) {
			int k = arr[i];
			for (j = i - 1; j >= 0; j--) {
				if (arr[j] < k) {
					arr[j + 1] = arr[j];
				} else
					break;
			}
			arr[j + 1] = k;
		}
		return arr;
	}

	public static int[] selectionSortRecu(int arr[], int i, int j, int min) {
		if (i >= arr.length)
			return arr;
		if (j < arr.length) {
			if (arr[min] > arr[j])
				min = j;
			return selectionSortRecu(arr, i, j + 1, min);
		}
		int k = arr[i];
		arr[i] = arr[min];
		arr[min] = k;
		return selectionSortRecu(arr, i + 1, i + 2, i + 1);
	}

	public static int[] mergeTwoSortedArray(int arr[], int arr1[]) {
		int arr3[] = new int[arr.length + arr1.length], k = 0, i = 0, j = 0;

		while (i < arr.length && j < arr1.length) {
			if (arr[i] > arr1[j]) {
				arr3[k++] = arr1[j++];

			} else {
				arr3[k++] = arr[i++];

			}
		}

		while (i < arr.length) {
			arr3[k++] = arr[i++];
		}
		while (j < arr1.length) {
			arr3[k++] = arr1[i++];
		}
		return arr3;
	}

	public static void recursionBubbleSort(int arr[], int i, int j) {
		if (i == arr.length)
			return;
		if (j < arr.length - i - 1 && arr[j] > arr[j + 1]) {

			int k = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = k;
			System.out.println(Arrays.toString(arr));
			recursionBubbleSort(arr, i, j + 1);

		} else {
			System.out.println("----- " + Arrays.toString(arr));
			recursionBubbleSort(arr, i + 1, 0);
		}

	}

	public static void bubbleSort(int arr[]) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int k = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = k;
				}

			}
		}
	}

	public static List<List<Integer>> threeSum(int arr[]) {
		int i = 0, j = 0, k = arr.length - 1;
		Set<List<Integer>> output = new HashSet<>();
		for (i = 0; i < arr.length; i++) {
			j = i + 1;
			k = arr.length - 1;
			while (j < k) {
				System.out.println(arr[i] + "->" + arr[j] + "->" + arr[k] + "=> " + (arr[i] + arr[j] + arr[k]) + " ( "
						+ i + "," + j + "," + k);
				if (arr[i] + arr[j] + arr[k] == 0) {
					List<Integer> list = new ArrayList<>();
					list.add(arr[i]);
					list.add(arr[j]);

					list.add(arr[k]);
					output.add(list);
				} else if (arr[i] + arr[j] + arr[k] > 0) {
					k--;
					j--;
				}
				j++;

			}
		}

		return output.stream().toList();

	}

	public static String longestPrefix(String s[]) {

		String prefix = "";

		for (int i = 0; i < s.length; i++) {
			for (int j = i + 1; j < s.length; j++) {
				if (s[i].length() > s[j].length()) {
					String temp = s[i];
					s[i] = s[j];
					s[j] = temp;
				}
			}
		}

		String st = s[0];
		boolean isMatched = false;
		for (int j = 0; j < st.length(); j++) {
			char ch = st.charAt(j);

			for (int k = 1; k < s.length; k++) {
				isMatched = false;

				if (ch == s[k].charAt(j)) {
					isMatched = true;
				} else
					break;
			}
			if (isMatched)
				prefix += ch;
			else
				break;

		}
		;
		return prefix;

	}

	public static String nonRepeatingChar(String s) {
		for (int i = 0; i < s.length(); i++) {
			boolean isPresent = false;
			for (int j = 0; j < s.length(); j++) {
				if (i != j && s.charAt(i) == s.charAt(j)) {
					isPresent = true;
					break;
				}
			}
			if (!isPresent) {
				return s.charAt(i) + "";
			}
		}
		return "All Are repated";
	}

	public static Integer romanToInteger(String s) {
		int num = 0;
		Map<String, Integer> romans = new HashMap<>();
		romans.put("M", 1000);
		romans.put("CM", 900);
		romans.put("D", 500);
		romans.put("CD", 400);
		romans.put("C", 100);
		romans.put("XC", 90);
		romans.put("L", 50);
		romans.put("XL", 40);
		romans.put("X", 10);
		romans.put("IX", 9);
		romans.put("V", 5);
		romans.put("IV", 4);
		romans.put("I", 1);
//System.out.println(romans.get("M"));
		if (s.length() < 2)
			return romans.get(s.charAt(0) + "");
		for (int i = 0; i < s.length() - 1; i++) {

			if (romans.get(s.charAt(i) + "").intValue() >= romans.get(s.charAt(i + 1) + "").intValue()) {
				num += romans.get(s.charAt(i) + "");
				System.out.println("num -> " + num);
			} else {

				int sum = romans.get(s.charAt(i + 1) + "") - romans.get(s.charAt(i) + "");
				System.out.println("num    => " + num + "  sum => " + sum);
				num += sum;
				i++;
				System.out.println("--------- " + num);
			}
			if (i == s.length() - 2)
				if (romans.get(s.charAt(i + 1) + "").intValue() <= romans.get(s.charAt(i) + "").intValue()) {
					num += romans.get(s.charAt(i + 1) + "");

				}
		}
		return num;
	}

	public static String integerToRoman(int num) {
		Integer number[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
		String romans[] = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };
		String result = "";
		for (int i = 0; i < number.length; i++) {

			while (num >= number[i]) {
				num -= number[i];
				result += romans[i];
			}
		}
		return result;

	}

	public static int convertToInteger(String s) {
		String st = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {
				st += s.charAt(i);
			} else if (s.charAt(i) == '-')
				st += s.charAt(i);
		}
		System.out.println(Integer.parseInt(st));
		return 0;
	}

	public static int reverserInteger(int n) {
		int rev = 0;
		while (n != 0) {
			int r = n % 10;
			n /= 10;
			rev = rev * 10 + r;
		}
		System.out.println(rev);
		return 0;
	}

	public static int[] mergeSortedArrays(int a1[], int a2[]) {
		int a3[] = new int[a1.length + a2.length], j = 0, k = 0, i = 0;

		Stack<Character> stack = new Stack();
		String s = "a";
		Character c = s.charAt(i);
		System.out.println(c.equals(c));

		while (i < a1.length && j < a2.length) {

			if (a1[i] >= a2[j])
				a3[k++] = a2[j++];
			else
				a3[k++] = a1[i++];

		}
		while (i < a1.length)
			a3[k++] = a1[i++];

		while (j < a2.length)
			a3[k++] = a2[j++];

		return a3;

	}

	public static int[] insertInSortedArray(int arr[], int value) {
		int temp[] = new int[arr.length + 1], j = 0;
		boolean isInserted = false;
		for (int i = 0; i < arr.length; i++) {

			if (!isInserted && arr[i] > value) {
				temp[j++] = value;
				isInserted = true;
			}
			temp[j++] = arr[i];
		}
		if (!isInserted)
			temp[j++] = value;
		return temp;
	}

	public static int[] inserAtNthPos(int arr[], int value, int pos) {
		int j = 0;
		int temp[] = new int[arr.length + 1];
		if (pos < 1)
			return arr;

		for (int i = 0; i < arr.length; i++) {
			if (i == pos - 1)
				temp[j++] = value;

			temp[j++] = arr[i];
		}
		if (pos > arr.length) {
			temp[j++] = value;
		}

//	for(int i=0;i<temp.length;i++)
//		arr[i]=temp[i];
		return temp;
	}

	public static void righRotation(int arr[], int num) {
		int n = arr.length, temp = 0, count = 0;
		while (count++ < num) {
			temp = arr[n - 1];
			for (int i = n - 1; i > 0; i--)
				arr[i] = arr[i - 1];
			arr[0] = temp;
		}

	}

	public static void leftRotation(int arr[], int num) {
		int temp[] = new int[arr.length], n = arr.length, j = 0;

		for (int i = num; i < n; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < num; i++)
			temp[j++] = arr[i];
		for (int i = 0; i < n; i++)
			arr[i] = temp[i];
	}

	public static char[] copyArray(char[] arr) {
		if (arr == null)
			return new char[1];

		char[] a = Arrays.copyOf(arr, arr.length + 1);
		return a;
	}

	public static String zigzapConversion(String s, int num) {
		char[][] arr = new char[num][];
		int k = 0, i = 0, j = 0, t = 0;
		while (k < s.length()) {
			while (i != num - 1) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i++;
			}
			j++;
			while (i != 0) {
				arr[i] = copyArray(arr[i]);
				arr[i][j] = s.charAt(k++);
				i--;
			}
			j++;

		}
		for (char[] a : arr) {
			for (char tt : a)
				System.out.print(tt);
			System.out.println();
		}
		return "";
	}

	public static String longestPolindromSubtString(String s) {
		String ans = "";
		if (s.length() < 1)
			return s;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - 1; j >= 0; j--) {
				if (i < j) {
					String sub = s.substring(i, j + 1);
					if (sub.equals(new StringBuilder(sub).reverse().toString())) {
						if (sub.length() > ans.length()) {
							ans = sub;
						}

					}
				}
			}
		}

		return ans;
	}

	public static double medianOfTwoSortedArray(int[] arr1, int[] arr2) {

		int arr3[] = new int[arr1.length + arr2.length], i = 0, j = 0, k = 0;
		while (true) {
			if (i < arr1.length) {
				arr3[k++] = arr1[i++];
			} else if (j < arr2.length) {
				arr3[k++] = arr2[j++];
			} else
				break;

		}
		double ans = 0;
		Arrays.sort(arr3);
		System.out.println(Arrays.toString(arr3));
		if (arr3.length % 2 == 0) {
			int mid = arr3.length / 2;
			ans = (double) (arr3[mid - 1] + arr3[mid]) / 2;
			System.out.println(arr3[mid - 1]);
		} else {
			ans = arr3[arr3.length / 2];
		}

		return ans;
	}
// 4
// 1,1,1,1
// 2,1,1
// 1,1,2
// 2,2

	public static int[] twoSum(int arr[], int target) {
		int f = 0, sec = 0;
		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {
				if (arr[i] + arr[j] == target && i != j) {

					f = i;
					sec = j;
				}
			}

		}
		System.out.println(f + " " + sec);
		return new int[] { f, sec };
	}

	public static char[] stringToArrayOfCharacters(String s) {
		char arr[] = new char[s.length()];
		for (int i = 0; i < s.length(); i++) {
			arr[i] = s.charAt(i);
		}
		return arr;
	}

	public static String[] textToWordsArray(String text) {
		List<String> words = new ArrayList<>();
		for (int i = 0; i < text.length(); i++) {

			for (int j = i; j < text.length() - 1; j++) {
				if (i > 0 && text.charAt(i) == ' ' && text.charAt(j + 1) == ' ' && text.charAt(i - 1) != ' ') {
					words.add(text.substring(i + 1, j + 1));
					break;
				} else if (i == 0 && text.charAt(j + 1) == ' ') {
					words.add(text.substring(i, j + 1));
					break;
				} else if (text.charAt(i) == ' ' && j + 1 == text.length() - 1) {
					words.add(text.substring(i + 1, text.length()));
					break;
				}
			}

		}
		String s[] = new String[words.size()];
		int i = 0;
		ListIterator<String> listIterator = words.listIterator();
		while (listIterator.hasNext()) {
			s[i++] = listIterator.next();
		}
		return s;
	}

	public static int wordCount(String s) {
		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0)
				count++;
			else if (s.charAt(i) == ' ')
				for (int j = i; j < s.length() - 1; j++) {
					if (s.charAt(j + 1) == ' ' && s.charAt(i - 1) != ' ') {
						count++;
						System.out.print(s.charAt(i) + " - > " + s.charAt(j) + " = " + count);
						break;
					}
				}
		}
		return count + 1;

	}

	public static void uniqueFromArrays(int arr[], int arr2[]) {

		List<Integer> list1 = List.of(1, 2, 4);
		List<Integer> list2 = List.of(1, 2, 3, 5);
		List<Integer> unique = new ArrayList<>();
		unique.addAll(list1);
		unique.addAll(list2);
		unique = unique.stream().distinct()
				.filter(a -> list1.contains(a) && !list2.contains(a) || !list1.contains(a) && list2.contains(a))
				.collect(Collectors.toList());
		System.out.println(unique);

		int k = 0;
		for (int i = 0; i < arr.length || k < arr2.length; i++, k++) {
			boolean a = false;
			boolean b = false;
			if (i < arr.length)
				for (int j = 0; j < arr2.length; j++) {
					if (arr[i] == arr2[j])
						a = true;
				}
			for (int j = 0; j < arr.length; j++) {
				if (arr2[k] == arr[j])
					b = true;
			}
			if (!a && i < arr.length)
				System.out.println(arr[i]);
			if (!b)
				System.out.println(arr2[k]);
		}
	}

	public static void arraySum(int arr[], int arr2[]) {
		int carry = 0, total = 0, j = 0, k = arr2.length - 1, i;
		List<Integer> sum = new ArrayList<>();

		for (i = arr.length - 1; i >= 0 && k >= 0; i--, k--) {

			total = arr[i] + arr2[k] + carry;
			carry = 0;
			if (total > 9) {
				carry = total % 10;
				total /= 10;
			}
			sum.add(total);

		}

		if (i < 0 && k >= 0) {
			for (int a = k; a >= 0; a--)
				sum.add(arr2[a]);
		}
		if (k < 0 && i >= 0) {
			for (int a = i; a >= 0; a--)
				sum.add(arr[a]);
		}
		Collections.reverse(sum);
		System.out.println(sum);
	}

	public static void arrayRightRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[arr.length - 1];
			for (j = arr.length - 1; j > 0; j--) {
				arr[j] = arr[j - 1];
			}
			count++;
			arr[0] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static void arrayLeftRotation(int arr[], int n) {
		int j = 0, count = 0;
		for (int i = 0; i < arr.length && count < n; i++) {
			int temp = arr[0];
			for (j = 0; j < arr.length - 1; j++) {
				arr[j] = arr[j + 1];
			}
			count++;
			arr[j] = temp;
		}
		for (int a : arr)
			System.out.print(a + ",");
	}

	public static boolean anagram(String s, String s1) {

		int count = 0;
		boolean b = false;
		for (int i = 0; i < s.length(); i++) {
			char ch = s.charAt(i);
			count = 0;
			b = false;
			for (int k = 0; k < s.length(); k++) {
				if (ch == s.charAt(k))
					count++;
			}

			for (int j = 0; j < s1.length(); j++) {
				if (count > 0 && ch == s1.charAt(j))
					count--;
			}
			if (count == 0)
				b = true;
		}

		System.out.println(b ? "yes" : "no");
		return b;
	}

	public static int count(int i, int arr[]) {
		int count = 0;
		for (int a : arr) {
			if (a == i)
				count++;
		}
		System.out.println(count);
		return count;
	}

	public static void majorityElement(int arr[]) {
		int max = 0, count = 0;
		for (int i = 0; i < arr.length; i++) {
			count = count(arr[i], arr);
			if (count >= max && count > arr.length / 2)
				max = arr[i];

		}
		System.out.println(max);
	}

	public static void longestPolindrom(String s) {

		int first = 0, last = s.length() - 1, max = 0;
		for (int i = 0; i < s.length(); i++) {

			for (int j = s.length() - i; j >= 0; j--) {
				if (i < j && j < s.length())
					if (checkPolindrom(i, j + 1, s) && max < s.substring(i, j).length()) {

						max = s.substring(i, j + 1).length();
						first = i;
						last = j + 1;
					}
			}
			System.out.println("------");

		}
		System.out.println(s.substring(first, last));

	}

	public static boolean checkPolindrom(int f, int l, String s) {
		String st = s.substring(f, l);
		System.out.println(st + "444");
		return st.equals(new StringBuffer(st).reverse().toString());

	}

	public void spiralMatrix() throws ClassNotFoundException, NoSuchMethodException, SecurityException,
			InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		int a[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };
		int j = 0, k = 0, count = 0, max = 10 - 1;
		// int max=a.length*a.length-1;
		// System.out.println(a.length);

		for (int i = 0; i < a.length - i; i++) {

			if (count == max)
				break;

			for (j = i; j < a.length - i && count <= max; j++) {
				count++;
				System.out.println(a[k][j]);
			}
			j--;

			k++;
			while (k < a.length - i && count <= max) {
				System.out.println(a[k][j]);
				k++;
				count++;
			}
			k--;
			j--;

			while (j >= 0 && count <= max) {
				count++;
				System.out.println(a[k][j--]);
			}

			// k=i+1;
			if (k == a.length / 2 && j == a.length / 2)
				break;
			j++;
			while (k > i + 1 && count <= max) {
				System.out.println(a[--k][j]);
				count++;
			}

			k = i + 1;
			System.out.println("-----------------");
		}

	}

	public static ArrayList<Integer> findIndexes(int arr[], int sum) {
		boolean a = false;
		int f = 0, l = arr.length, s = 0;
		for (int i = 0; i < arr.length; i++) {
			s = 0;
			if (a)
				break;

			for (int j = i; j < arr.length; j++) {
				s += arr[j];
				if (s == sum) {
					f = i;
					l = j;
					a = true;
					break;
				}

			}
			System.out.println(s);
		}

		return a ? new ArrayList<Integer>(Arrays.asList(f, l)) : new ArrayList<Integer>(Arrays.asList(-1));
	}

	public int count(char a, String s) {
		class A {
			static int a;

			public void main() {
				System.out.println("hello");
			}
		}

		int count = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == a)
				count++;
		}
		return count;
	}

	public static boolean isPresent(char a, int indx, String s) {
		for (int i = indx; i >= 0; i--) {
			if (s.charAt(i) == a)
				return true;
		}
		return false;
	}

	public static boolean isPresent(int a, int indx, int ar[]) {
		for (int i = indx; i >= 0; i--) {
			if (ar[i] == a)
				return true;
		}
		return false;
	}

	public static void fibonacci(int t1, int t2, int n) {
		if (n == 0)
			return;
		else {
			int t3 = t1 + t2;
			t1 = t2;
			t2 = t3;
			System.out.println(t3);
			fibonacci(t1, t2, n - 1);
		}

	}

	public static int factorial(int n) {
		if (n == 1)
			return 1;
		else
			n = n * factorial(n - 1);
		return n;

	}

	public static String removeSpaces(String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != ' ')
				sb.append(s.charAt(i));

		}
		return sb.toString();
	}

	public static int[] removeDuplicate(int[] a) {
		int arr[] = new int[a.length];
		int j = 0;
		for (int i = 0; i < a.length; i++) {
			if (!isPresent(a[i], i - 1, a))
				arr[j++] = a[i];
		}
		a = new int[j];
		System.out.println(j);
		for (int i = 0; i < j; i++)
			a[i] = arr[i];
		return a;
	}

	class C {
		static int a;
	}
}

class B {
	int a = 10;

	public String toString() {
		System.out.println("askfjal");
		return new String(this.a + "");
	}

	public void hello(int... a) {

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-12-24 23:21:11.187
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-12-24 23:21:11.188
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2023-12-25 00:20:11.878
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2023-12-25 00:27:19.575
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2023-12-25 00:37:30.208
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2023-12-26 23:09:25.130 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2023-12-26 23:09:34.614
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-12-26 23:09:58.747
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-12-26 23:10:39.119
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-26 23:10:39.119
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-26 23:10:39.119
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-12-26 23:11:06.717
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-12-26 23:11:43.948
!MESSAGE executing callback sts4.classpath.KUpXGztL FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2023-12-26 23:11:43.949
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-12-29 23:01:32.519 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4 -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4 -data C:\sts-4.17.1.RELEASE\javaPrograms -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2023-12-29 23:01:34.765
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-12-29 23:01:38.766
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-12-29 23:01:46.288
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-29 23:01:46.288
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-29 23:01:46.288
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-12-29 23:02:09.080
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-12-29 23:02:30.137
!MESSAGE executing callback sts4.classpath.lHQIXYkU FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2023-12-29 23:02:30.139
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.resources 4 2 2023-12-29 23:37:21.660
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 1
org.eclipse.core.runtime.CoreException: aquire container failed
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1018)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1026)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.execute(MavenBuilder.java:84)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder.build(MavenBuilder.java:196)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.RuntimeException: Aquire container failed!
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:621)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1005)
	... 16 more
Caused by: org.eclipse.core.runtime.CoreException: Could not read maven project
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.readProjectWithDependencies(ProjectRegistryManager.java:857)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.lambda$1(MavenProjectCache.java:190)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.getProject(MavenProjectCache.java:189)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache.getMavenProject(MavenProjectCache.java:104)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.lambda$22(ProjectRegistryManager.java:1044)
	at java.base/java.util.Map.computeIfAbsent(Map.java:1054)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.getMavenProject(ProjectRegistryManager.java:1043)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.getMavenProject(MavenProjectFacade.java:280)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:611)
	... 17 more
!SUBENTRY 1 org.eclipse.m2e.core 4 0 2023-12-29 23:37:21.662
!MESSAGE aquire container failed
!STACK 0
java.lang.RuntimeException: Aquire container failed!
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:621)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1005)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1026)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.execute(MavenBuilder.java:84)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder.build(MavenBuilder.java:196)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Could not read maven project
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.readProjectWithDependencies(ProjectRegistryManager.java:857)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.lambda$1(MavenProjectCache.java:190)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.getProject(MavenProjectCache.java:189)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache.getMavenProject(MavenProjectCache.java:104)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.lambda$22(ProjectRegistryManager.java:1044)
	at java.base/java.util.Map.computeIfAbsent(Map.java:1054)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.getMavenProject(ProjectRegistryManager.java:1043)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.getMavenProject(MavenProjectFacade.java:280)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:611)
	... 17 more
!SUBENTRY 1 org.eclipse.m2e.core 4 0 2023-12-29 23:37:21.662
!MESSAGE aquire container failed
!STACK 0
java.lang.RuntimeException: Aquire container failed!
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:621)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1005)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1026)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.execute(MavenBuilder.java:84)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder.build(MavenBuilder.java:196)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Could not read maven project
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.readProjectWithDependencies(ProjectRegistryManager.java:857)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.lambda$1(MavenProjectCache.java:190)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.getProject(MavenProjectCache.java:189)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache.getMavenProject(MavenProjectCache.java:104)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.lambda$22(ProjectRegistryManager.java:1044)
	at java.base/java.util.Map.computeIfAbsent(Map.java:1054)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.getMavenProject(ProjectRegistryManager.java:1043)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.getMavenProject(MavenProjectFacade.java:280)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:611)
	... 17 more
!SESSION 2023-12-30 23:15:44.083 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4 -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4 -data C:\sts-4.17.1.RELEASE\javaPrograms -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2023-12-30 23:15:46.282
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-12-30 23:15:50.090
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-12-30 23:15:54.638
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-30 23:15:54.638
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-30 23:15:54.638
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-12-30 23:16:13.281
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-12-30 23:16:39.490
!MESSAGE executing callback sts4.classpath.czuHhYOy FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2023-12-30 23:16:39.494
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui 4 0 2023-12-31 00:04:16.939
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Graphic is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4918)
	at org.eclipse.swt.SWT.error(SWT.java:4833)
	at org.eclipse.swt.SWT.error(SWT.java:4804)
	at org.eclipse.swt.graphics.Font.getFontData(Font.java:195)
	at org.eclipse.swt.custom.CTabFolderRenderer.getChevronFont(CTabFolderRenderer.java:1668)
	at org.eclipse.swt.custom.CTabFolderRenderer.computeSize(CTabFolderRenderer.java:307)
	at org.eclipse.e4.ui.workbench.renderers.swt.CTabRendering.computeSize(CTabRendering.java:225)
	at org.eclipse.swt.custom.CTabFolder.createButtonImage(CTabFolder.java:729)
	at org.eclipse.swt.custom.CTabFolder.updateChevronImage(CTabFolder.java:2661)
	at org.eclipse.swt.custom.CTabFolder.setButtonBounds(CTabFolder.java:2566)
	at org.eclipse.swt.custom.CTabFolder.updateItems(CTabFolder.java:3875)
	at org.eclipse.swt.custom.CTabFolder.updateItems(CTabFolder.java:3798)
	at org.eclipse.swt.custom.CTabFolder.onResize(CTabFolder.java:2120)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:339)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.sendResize(Control.java:3048)
	at org.eclipse.swt.widgets.Composite.sendResize(Composite.java:1018)
	at org.eclipse.swt.widgets.Composite.setBoundsInPixels(Composite.java:1067)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3217)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3213)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3289)
	at org.eclipse.swt.widgets.Control.setBounds(Control.java:3285)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.setRectangle(SashLayout.java:315)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.tileSubNodes(SashLayout.java:260)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.tileSubNodes(SashLayout.java:303)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.tileSubNodes(SashLayout.java:303)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.layout(SashLayout.java:178)
	at org.eclipse.swt.widgets.Composite.updateLayout(Composite.java:1335)
	at org.eclipse.swt.widgets.Composite.sendResize(Composite.java:1022)
	at org.eclipse.swt.widgets.Composite.setBoundsInPixels(Composite.java:1067)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3217)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3213)
	at org.eclipse.swt.widgets.Control.setBounds(Control.java:3208)
	at org.eclipse.swt.layout.FillLayout.layout(FillLayout.java:216)
	at org.eclipse.swt.widgets.Composite.updateLayout(Composite.java:1335)
	at org.eclipse.swt.widgets.Composite.WM_SIZE(Composite.java:1736)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4820)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Scrollable.callWindowProc(Scrollable.java:91)
	at org.eclipse.swt.widgets.Control.WM_WINDOWPOSCHANGED(Control.java:5675)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4833)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.SetWindowPos(Native Method)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3256)
	at org.eclipse.swt.widgets.Composite.setBoundsInPixels(Composite.java:1061)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3217)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3213)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3289)
	at org.eclipse.swt.widgets.Control.setBounds(Control.java:3285)
	at org.eclipse.swt.custom.StackLayout.layout(StackLayout.java:124)
	at org.eclipse.swt.widgets.Composite.updateLayout(Composite.java:1335)
	at org.eclipse.swt.widgets.Composite.WM_SIZE(Composite.java:1736)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4820)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Scrollable.callWindowProc(Scrollable.java:91)
	at org.eclipse.swt.widgets.Control.WM_WINDOWPOSCHANGED(Control.java:5675)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4833)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.SetWindowPos(Native Method)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3256)
	at org.eclipse.swt.widgets.Composite.setBoundsInPixels(Composite.java:1061)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3217)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3213)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3289)
	at org.eclipse.swt.widgets.Control.setBounds(Control.java:3285)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.setRectangle(SashLayout.java:315)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.tileSubNodes(SashLayout.java:260)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.tileSubNodes(SashLayout.java:303)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.layout(SashLayout.java:178)
	at org.eclipse.swt.widgets.Composite.updateLayout(Composite.java:1335)
	at org.eclipse.swt.widgets.Composite.WM_SIZE(Composite.java:1736)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4820)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Scrollable.callWindowProc(Scrollable.java:91)
	at org.eclipse.swt.widgets.Control.WM_WINDOWPOSCHANGED(Control.java:5675)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4833)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.SetWindowPos(Native Method)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3256)
	at org.eclipse.swt.widgets.Composite.setBoundsInPixels(Composite.java:1061)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3217)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3213)
	at org.eclipse.swt.widgets.Control.setBounds(Control.java:3208)
	at org.eclipse.swt.layout.FillLayout.layout(FillLayout.java:216)
	at org.eclipse.swt.widgets.Composite.updateLayout(Composite.java:1335)
	at org.eclipse.swt.widgets.Composite.WM_SIZE(Composite.java:1736)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4820)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Scrollable.callWindowProc(Scrollable.java:91)
	at org.eclipse.swt.widgets.Control.WM_WINDOWPOSCHANGED(Control.java:5675)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4833)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.EndDeferWindowPos(Native Method)
	at org.eclipse.swt.widgets.Composite.resizeChildren(Composite.java:993)
	at org.eclipse.swt.widgets.Composite.resizeChildren(Composite.java:970)
	at org.eclipse.swt.widgets.Composite.setResizeChildren(Composite.java:1166)
	at org.eclipse.swt.widgets.Composite.WM_SIZE(Composite.java:1740)
	at org.eclipse.swt.widgets.Canvas.WM_SIZE(Canvas.java:444)
	at org.eclipse.swt.widgets.Decorations.WM_SIZE(Decorations.java:1644)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4820)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2284)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.WM_WINDOWPOSCHANGED(Control.java:5675)
	at org.eclipse.swt.widgets.Canvas.WM_WINDOWPOSCHANGED(Canvas.java:451)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4833)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2284)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.SetMenu(Native Method)
	at org.eclipse.swt.widgets.Decorations.setMenuBar(Decorations.java:1037)
	at org.eclipse.swt.widgets.Menu.releaseParent(Menu.java:959)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:829)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:428)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.disposeWidget(SWTPartRenderer.java:183)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$0(WorkbenchWindow.java:329)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4785)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setWidget(UIElementImpl.java:267)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.unbindWidget(SWTPartRenderer.java:158)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.lambda$0(SWTPartRenderer.java:147)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:814)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:428)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.swt.widgets.Display.release(Display.java:3698)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:324)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3247)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4844)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2284)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3637)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:609)
	at org.eclipse.ui.internal.SaveablesList.promptForSaving(SaveablesList.java:722)
	at org.eclipse.ui.internal.SaveablesList.promptForSaving(SaveablesList.java:629)
	at org.eclipse.ui.internal.SaveablesList.promptForSavingIfNecessary(SaveablesList.java:608)
	at org.eclipse.ui.internal.SaveablesList.preCloseParts(SaveablesList.java:550)
	at org.eclipse.ui.internal.SaveablesList.preCloseParts(SaveablesList.java:484)
	at org.eclipse.ui.internal.WorkbenchWindow$2.saveParts(WorkbenchWindow.java:776)
	at org.eclipse.ui.internal.Workbench.saveAllParts(Workbench.java:1325)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1051)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1391)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1391)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1367)
	at org.eclipse.ui.internal.Workbench.lambda$16(Workbench.java:2733)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4248)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3253)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4844)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2284)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3637)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2023-12-31 14:41:36.395 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2023-12-31 14:41:47.082
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY org.eclipse.core.resources 2 10035 2023-12-31 14:42:02.507
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY ch.qos.logback.classic 1 0 2023-12-31 14:42:11.447
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-12-31 14:42:41.867
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-31 14:42:41.867
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-31 14:42:41.867
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-12-31 14:43:02.439
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-12-31 14:44:06.747
!MESSAGE executing callback sts4.classpath.haRVAQfY FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2023-12-31 14:44:06.748
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 4 0 2023-12-31 14:44:32.228
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaCompletionProposalComputer.asJavaProposals(LSJavaCompletionProposalComputer.java:87)
	at org.eclipse.lsp4e.jdt.LSJavaCompletionProposalComputer.computeCompletionProposals(LSJavaCompletionProposalComputer.java:55)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:348)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:378)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:377)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1760)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.lsp4e 2 0 2023-12-31 14:44:46.942
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jst.jsp.core 4 4 2023-12-31 14:45:05.299
!MESSAGE A workspace crash was detected. The previous session did not exit normally. Not using saved taglib indexes.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-12-31 14:45:41.961
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-12-31 14:45:41.969
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.lsp4e 2 0 2023-12-31 14:46:18.976
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-12-31 14:46:26.835
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-12-31 14:46:26.841
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-12-31 14:46:27.275
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-12-31 14:46:27.309
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-12-31 14:46:54.592
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-12-31 14:46:54.600
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.lsp4e 2 0 2024-01-01 00:59:09.672
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-01 01:14:08.533
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-01 01:14:35.987
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-01-01 12:05:36.248 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-01-01 12:05:50.204
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2024-01-01 12:06:14.276
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-01-01 12:06:46.236
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-01 12:06:46.236
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-01 12:06:46.236
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-01-01 12:07:04.648
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-01-01 12:07:50.574
!MESSAGE executing callback sts4.classpath.JLosknPG FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-01-01 12:07:50.576
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-01 12:14:45.892
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-01 12:45:45.133
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-01 13:00:57.489
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-01 13:07:30.622
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-01 13:12:14.890
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-01 14:15:28.478
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-01 14:24:43.240
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-01 14:30:41.436
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-01-07 12:34:11.255 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-01-07 12:34:19.130
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2024-01-07 12:35:03.409
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-01-07 12:35:31.297
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-07 12:35:31.298
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-07 12:35:31.298
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-01-07 12:35:50.254
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 2 2 2024-01-07 12:36:21.060
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-01-07 12:36:33.079
!MESSAGE executing callback sts4.classpath.Finfwjak FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-01-07 12:36:33.080
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui 4 0 2024-01-07 12:36:34.619
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException: Widget has the wrong parent
	at org.eclipse.swt.SWT.error(SWT.java:4899)
	at org.eclipse.swt.SWT.error(SWT.java:4833)
	at org.eclipse.swt.SWT.error(SWT.java:4804)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:450)
	at org.eclipse.swt.widgets.MenuItem.setMenu(MenuItem.java:842)
	at org.eclipse.jface.action.ActionContributionItem.lambda$9(ActionContributionItem.java:1260)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-07 12:36:49.740
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder$FindInSource.findMain(MainTypeFinder.java:203)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder.internalGuessMainTypes(MainTypeFinder.java:128)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder.guessMainTypes(MainTypeFinder.java:71)
	at org.springframework.ide.eclipse.boot.launch.BootLaunchShortcut$1.run(BootLaunchShortcut.java:87)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.ui.internal.progress.ProgressMonitorJobsDialog.run(ProgressMonitorJobsDialog.java:230)
	at org.eclipse.ui.internal.progress.ProgressManager.run(ProgressManager.java:999)
	at org.springframework.ide.eclipse.boot.launch.BootLaunchShortcut.findTypes(BootLaunchShortcut.java:83)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaLaunchShortcut.searchAndLaunch(JavaLaunchShortcut.java:115)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaLaunchShortcut.launch(JavaLaunchShortcut.java:281)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchShortcutExtension.launch(LaunchShortcutExtension.java:430)
	at org.eclipse.debug.internal.ui.actions.LaunchShortcutAction.runInternal(LaunchShortcutAction.java:88)
	at org.eclipse.debug.internal.ui.actions.LaunchShortcutAction.runWithEvent(LaunchShortcutAction.java:135)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.jface.action.ActionContributionItem.lambda$8(ActionContributionItem.java:1206)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3642)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-07 12:36:49.791
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder$FindInSource.findMain(MainTypeFinder.java:203)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder.internalGuessMainTypes(MainTypeFinder.java:128)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder.guessMainTypes(MainTypeFinder.java:71)
	at org.springframework.ide.eclipse.boot.launch.BootLaunchShortcut$1.run(BootLaunchShortcut.java:87)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.ui.internal.progress.ProgressMonitorJobsDialog.run(ProgressMonitorJobsDialog.java:230)
	at org.eclipse.ui.internal.progress.ProgressManager.run(ProgressManager.java:999)
	at org.springframework.ide.eclipse.boot.launch.BootLaunchShortcut.findTypes(BootLaunchShortcut.java:83)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaLaunchShortcut.searchAndLaunch(JavaLaunchShortcut.java:115)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaLaunchShortcut.launch(JavaLaunchShortcut.java:281)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchShortcutExtension.launch(LaunchShortcutExtension.java:430)
	at org.eclipse.debug.internal.ui.actions.LaunchShortcutAction.runInternal(LaunchShortcutAction.java:88)
	at org.eclipse.debug.internal.ui.actions.LaunchShortcutAction.runWithEvent(LaunchShortcutAction.java:135)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.jface.action.ActionContributionItem.lambda$8(ActionContributionItem.java:1206)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3642)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-07 12:36:49.793
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder$FindInSource.findMain(MainTypeFinder.java:203)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder.internalGuessMainTypes(MainTypeFinder.java:128)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder.guessMainTypes(MainTypeFinder.java:71)
	at org.springframework.ide.eclipse.boot.launch.BootLaunchShortcut$1.run(BootLaunchShortcut.java:87)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.ui.internal.progress.ProgressMonitorJobsDialog.run(ProgressMonitorJobsDialog.java:230)
	at org.eclipse.ui.internal.progress.ProgressManager.run(ProgressManager.java:999)
	at org.springframework.ide.eclipse.boot.launch.BootLaunchShortcut.findTypes(BootLaunchShortcut.java:83)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaLaunchShortcut.searchAndLaunch(JavaLaunchShortcut.java:115)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaLaunchShortcut.launch(JavaLaunchShortcut.java:281)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchShortcutExtension.launch(LaunchShortcutExtension.java:430)
	at org.eclipse.debug.internal.ui.actions.LaunchShortcutAction.runInternal(LaunchShortcutAction.java:88)
	at org.eclipse.debug.internal.ui.actions.LaunchShortcutAction.runWithEvent(LaunchShortcutAction.java:135)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.jface.action.ActionContributionItem.lambda$8(ActionContributionItem.java:1206)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3642)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-07 12:36:49.795
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder$FindInSource.findMain(MainTypeFinder.java:203)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder.internalGuessMainTypes(MainTypeFinder.java:128)
	at org.springsource.ide.eclipse.commons.frameworks.core.maintype.MainTypeFinder.guessMainTypes(MainTypeFinder.java:71)
	at org.springframework.ide.eclipse.boot.launch.BootLaunchShortcut$1.run(BootLaunchShortcut.java:87)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:470)
	at org.eclipse.ui.internal.progress.ProgressMonitorJobsDialog.run(ProgressMonitorJobsDialog.java:230)
	at org.eclipse.ui.internal.progress.ProgressManager.run(ProgressManager.java:999)
	at org.springframework.ide.eclipse.boot.launch.BootLaunchShortcut.findTypes(BootLaunchShortcut.java:83)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaLaunchShortcut.searchAndLaunch(JavaLaunchShortcut.java:115)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaLaunchShortcut.launch(JavaLaunchShortcut.java:281)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchShortcutExtension.launch(LaunchShortcutExtension.java:430)
	at org.eclipse.debug.internal.ui.actions.LaunchShortcutAction.runInternal(LaunchShortcutAction.java:88)
	at org.eclipse.debug.internal.ui.actions.LaunchShortcutAction.runWithEvent(LaunchShortcutAction.java:135)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.jface.action.ActionContributionItem.lambda$8(ActionContributionItem.java:1206)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3642)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-07 12:45:29.348
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-07 12:45:34.719
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-01-12 23:36:16.404 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-01-12 23:36:22.789
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2024-01-12 23:36:55.163
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-01-12 23:37:49.768
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-12 23:37:49.768
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-12 23:37:49.768
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-01-12 23:38:10.704
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-01-12 23:39:01.519
!MESSAGE executing callback sts4.classpath.yGtLtaow FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-01-12 23:39:01.520
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-01-17 23:44:41.782 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-01-17 23:44:48.686
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2024-01-17 23:45:46.032
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-01-17 23:46:18.808
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-17 23:46:18.808
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-17 23:46:18.808
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-01-17 23:46:35.773
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 2 2 2024-01-17 23:47:24.057
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-01-17 23:47:30.452
!MESSAGE executing callback sts4.classpath.ykjoiZcX FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-01-17 23:47:30.453
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2024-01-17 23:49:32.178
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2024-01-17 23:49:32.187
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2024-01-17 23:49:33.782
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2024-01-17 23:49:33.824
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2024-01-17 23:49:59.648
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2024-01-17 23:49:59.659
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2024-01-17 23:50:24.533
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2024-01-17 23:50:24.539
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jdt.core 4 0 2024-01-17 23:56:32.655
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-17 23:56:32.699
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-17 23:56:32.704
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-17 23:56:32.708
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-18 00:10:33.443
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-18 00:37:06.081
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-18 00:37:14.753
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-01-18 22:48:44.299 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-01-18 22:48:50.087
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2024-01-18 23:57:15.577
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-01-18 23:57:48.179
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-18 23:57:48.179
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-18 23:57:48.179
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-01-18 23:58:05.146
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-01-18 23:59:27.464
!MESSAGE executing callback sts4.classpath.JNDOPnPz FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-01-18 23:59:27.465
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui 2 2 2024-01-19 00:18:50.733
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-19 00:22:29.490
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-19 00:22:29.540
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-19 00:22:29.542
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-19 00:22:29.547
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SESSION 2024-01-19 22:38:08.572 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-01-19 22:38:16.593
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2024-01-19 22:38:30.522
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-01-19 22:39:01.835
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-19 22:39:01.835
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-19 22:39:01.836
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-01-19 22:39:20.499
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.lsp4e 2 0 2024-01-19 22:39:35.711
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 4 0 2024-01-19 22:40:08.213
!MESSAGE org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Internal error.
!STACK 0
java.util.concurrent.ExecutionException: org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Internal error.
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:396)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2073)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.lambda$12(LSPTextHover.java:203)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.lambda$11(LSPTextHover.java:212)
	at java.base/java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:646)
	at java.base/java.util.concurrent.CompletableFuture$Completion.exec(CompletableFuture.java:483)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Internal error.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponse(RemoteEndpoint.java:209)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:193)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$3(LanguageServerWrapper.java:288)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-01-19 22:40:16.762
!MESSAGE executing callback sts4.classpath.dJCWXGYG FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-01-19 22:40:16.763
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 4 0 2024-01-19 23:16:00.112
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaCompletionProposalComputer.asJavaProposals(LSJavaCompletionProposalComputer.java:87)
	at org.eclipse.lsp4e.jdt.LSJavaCompletionProposalComputer.computeCompletionProposals(LSJavaCompletionProposalComputer.java:55)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:348)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:378)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:377)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1760)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-19 23:24:25.275
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.core.resources 2 10035 2024-01-20 00:24:20.331
!MESSAGE The workspace will exit with unsaved changes in this session.
!SESSION 2024-01-21 22:15:30.348 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-01-21 22:15:37.567
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY org.eclipse.core.resources 2 10035 2024-01-21 22:15:49.356
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY ch.qos.logback.classic 1 0 2024-01-21 22:15:56.836
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-01-21 22:16:32.911
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-21 22:16:32.911
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-21 22:16:32.911
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-01-21 22:16:51.343
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-01-21 22:17:44.006
!MESSAGE executing callback sts4.classpath.JDcGxrdv FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-01-21 22:17:44.007
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui 2 2 2024-01-21 22:19:40.717
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-21 22:20:38.674
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-21 22:20:38.704
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-21 22:20:38.707
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-01-21 22:20:38.709
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-21 22:20:57.244
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-21 22:22:47.652
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-21 22:26:16.138
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-21 23:22:10.811
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-01-21 23:57:53.700 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-01-21 23:58:02.624
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY org.eclipse.core.resources 2 10035 2024-01-21 23:58:12.926
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY ch.qos.logback.classic 1 0 2024-01-21 23:58:23.733
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-01-21 23:59:12.480
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-21 23:59:12.480
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-21 23:59:12.480
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-01-21 23:59:36.168
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-01-22 00:00:40.323
!MESSAGE executing callback sts4.classpath.lNfFYAQn FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-01-22 00:00:40.325
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-22 00:04:54.884
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-22 00:04:58.256
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-01-22 00:05:01.446
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-01-22 22:26:11.882 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-01-22 22:26:21.933
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2024-01-22 22:28:23.494
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-01-22 22:29:01.422
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-22 22:29:01.422
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-22 22:29:01.422
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-01-22 22:29:19.480
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.lsp4e 2 0 2024-01-22 22:29:26.888
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-01-22 22:30:09.878
!MESSAGE executing callback sts4.classpath.QrUCrYBz FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-01-22 22:30:09.880
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.resources 4 2 2024-01-22 22:56:44.701
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 1
org.eclipse.core.runtime.CoreException: aquire container failed
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1018)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1026)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.execute(MavenBuilder.java:84)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder.build(MavenBuilder.java:196)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.RuntimeException: Aquire container failed!
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:621)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1005)
	... 16 more
Caused by: org.eclipse.core.runtime.CoreException: Could not read maven project
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.readProjectWithDependencies(ProjectRegistryManager.java:857)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.lambda$1(MavenProjectCache.java:190)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.getProject(MavenProjectCache.java:189)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache.getMavenProject(MavenProjectCache.java:104)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.lambda$22(ProjectRegistryManager.java:1044)
	at java.base/java.util.Map.computeIfAbsent(Map.java:1054)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.getMavenProject(ProjectRegistryManager.java:1043)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.getMavenProject(MavenProjectFacade.java:280)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:611)
	... 17 more
!SUBENTRY 1 org.eclipse.m2e.core 4 0 2024-01-22 22:56:44.703
!MESSAGE aquire container failed
!STACK 0
java.lang.RuntimeException: Aquire container failed!
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:621)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1005)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1026)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.execute(MavenBuilder.java:84)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder.build(MavenBuilder.java:196)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Could not read maven project
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.readProjectWithDependencies(ProjectRegistryManager.java:857)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.lambda$1(MavenProjectCache.java:190)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.getProject(MavenProjectCache.java:189)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache.getMavenProject(MavenProjectCache.java:104)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.lambda$22(ProjectRegistryManager.java:1044)
	at java.base/java.util.Map.computeIfAbsent(Map.java:1054)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.getMavenProject(ProjectRegistryManager.java:1043)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.getMavenProject(MavenProjectFacade.java:280)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:611)
	... 17 more
!SUBENTRY 1 org.eclipse.m2e.core 4 0 2024-01-22 22:56:44.704
!MESSAGE aquire container failed
!STACK 0
java.lang.RuntimeException: Aquire container failed!
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:621)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1005)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.createExecutionContext(ProjectRegistryManager.java:1026)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.execute(MavenBuilder.java:84)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder.build(MavenBuilder.java:196)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:1020)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:247)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:392)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:395)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:506)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:454)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:536)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:161)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:255)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Could not read maven project
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.readProjectWithDependencies(ProjectRegistryManager.java:857)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.lambda$1(MavenProjectCache.java:190)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache$CacheLine.getProject(MavenProjectCache.java:189)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectCache.getMavenProject(MavenProjectCache.java:104)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.lambda$22(ProjectRegistryManager.java:1044)
	at java.base/java.util.Map.computeIfAbsent(Map.java:1054)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.getMavenProject(ProjectRegistryManager.java:1043)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.getMavenProject(MavenProjectFacade.java:280)
	at org.eclipse.m2e.core.internal.project.registry.MavenProjectFacade.createExecutionContext(MavenProjectFacade.java:611)
	... 17 more
!SESSION 2024-02-13 21:51:46.480 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-02-13 21:51:57.286
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2024-02-13 21:52:19.922
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-02-13 21:52:48.693
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-02-13 21:52:48.693
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-02-13 21:52:48.693
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-02-13 21:53:06.732
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 2 2 2024-02-13 21:53:45.529
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.jface.text 4 0 2024-02-13 21:54:11.671
!MESSAGE java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
!STACK 0
java.util.concurrent.CompletionException: java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1159)
	at java.base/java.util.concurrent.CompletableFuture$Completion.exec(CompletableFuture.java:483)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150)
	... 6 more

!ENTRY org.eclipse.jface.text 4 0 2024-02-13 21:54:11.687
!MESSAGE java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
!STACK 0
java.util.concurrent.CompletionException: java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1159)
	at java.base/java.util.concurrent.CompletableFuture$Completion.exec(CompletableFuture.java:483)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150)
	... 6 more

!ENTRY org.eclipse.jface.text 4 0 2024-02-13 21:54:11.691
!MESSAGE java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
!STACK 0
java.util.concurrent.CompletionException: java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1159)
	at java.base/java.util.concurrent.CompletableFuture$Completion.exec(CompletableFuture.java:483)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150)
	... 6 more

!ENTRY org.eclipse.jface.text 4 0 2024-02-13 21:54:11.692
!MESSAGE java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
!STACK 0
java.util.concurrent.CompletionException: java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1159)
	at java.base/java.util.concurrent.CompletableFuture$Completion.exec(CompletableFuture.java:483)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.NullPointerException: Cannot invoke "java.util.concurrent.CompletionStage.toCompletableFuture()" because the return value of "java.util.function.Function.apply(Object)" is null
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150)
	... 6 more

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-02-13 21:54:16.497
!MESSAGE executing callback sts4.classpath.eKWYRWyB FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-02-13 21:54:16.500
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-02-13 22:35:48.671 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-02-13 22:35:53.657
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY org.eclipse.core.resources 2 10035 2024-02-13 22:36:12.462
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY ch.qos.logback.classic 1 0 2024-02-13 22:36:17.204
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-02-13 22:36:39.573
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-02-13 22:36:39.573
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-02-13 22:36:39.573
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-02-13 22:36:55.845
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-02-13 22:37:36.880
!MESSAGE executing callback sts4.classpath.KfMPwZcZ FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-02-13 22:37:36.885
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-13 22:39:23.213
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-13 22:49:43.193
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-14 00:04:09.420
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-02-14 22:41:07.428 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-02-14 22:41:12.267
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2024-02-14 22:42:08.462
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-02-14 22:42:40.873
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-02-14 22:42:40.873
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-02-14 22:42:40.873
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-02-14 22:42:54.251
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-02-14 22:43:39.267
!MESSAGE executing callback sts4.classpath.gHtoyzyh FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-02-14 22:43:39.269
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 4 0 2024-02-14 22:49:51.374
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaCompletionProposalComputer.asJavaProposals(LSJavaCompletionProposalComputer.java:87)
	at org.eclipse.lsp4e.jdt.LSJavaCompletionProposalComputer.computeCompletionProposals(LSJavaCompletionProposalComputer.java:55)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:348)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:378)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:377)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1760)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-14 22:56:59.695
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-14 23:05:59.707
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-14 23:59:22.228
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-15 00:03:08.361
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-15 00:15:17.555
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-15 00:19:02.467
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-15 00:19:08.799
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-15 00:19:33.235
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-15 00:23:34.857
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-15 00:32:31.684
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-15 00:33:54.151
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-02-15 22:32:55.091 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-02-15 22:33:02.380
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2024-02-15 22:33:50.654
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-02-15 22:34:21.768
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-02-15 22:34:21.768
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-02-15 22:34:21.768
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-02-15 22:34:36.700
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-02-15 22:35:22.058
!MESSAGE executing callback sts4.classpath.yAzaKRVA FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-02-15 22:35:22.059
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui 2 2 2024-02-15 22:46:51.432
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 4 0 2024-02-15 23:39:38.998
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaCompletionProposalComputer.asJavaProposals(LSJavaCompletionProposalComputer.java:87)
	at org.eclipse.lsp4e.jdt.LSJavaCompletionProposalComputer.computeCompletionProposals(LSJavaCompletionProposalComputer.java:55)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:348)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:378)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:377)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1760)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
!SESSION 2024-02-16 22:25:33.773 -----------------------------------------------
eclipse.buildId=4.17.1.202301011401
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY ch.qos.logback.classic 1 0 2024-02-16 22:25:49.033
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2024-02-16 22:26:40.665
!MESSAGE Logback config file: C:\sts-4.17.1.RELEASE\javaPrograms\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2024-02-16 22:27:19.594
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-02-16 22:27:19.594
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-02-16 22:27:19.594
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-02-16 22:27:32.898
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Hp'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2024-02-16 22:28:17.767
!MESSAGE executing callback sts4.classpath.NPhjaQwu FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2024-02-16 22:28:17.769
!MESSAGE TimeoutException
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:37)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-16 22:39:12.532
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 2 2 2024-02-16 23:07:30.878
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-16 23:17:07.237
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 0 2024-02-16 23:17:31.343
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-02-16 23:17:31.394
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-02-16 23:17:31.397
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-02-16 23:17:31.399
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-16 23:33:43.881
!MESSAGE Unable to compute end of document
!STACK 0
org.eclipse.jface.text.BadLocationException
	at org.eclipse.jface.text.TreeLineTracker.fail(TreeLineTracker.java:1054)
	at org.eclipse.jface.text.TreeLineTracker.lineByOffset(TreeLineTracker.java:268)
	at org.eclipse.jface.text.TreeLineTracker.getLineNumberOfOffset(TreeLineTracker.java:1122)
	at org.eclipse.jface.text.AbstractLineTracker.getLineNumberOfOffset(AbstractLineTracker.java:246)
	at org.eclipse.jface.text.AbstractDocument.getLineOfOffset(AbstractDocument.java:872)
	at org.eclipse.core.internal.filebuffers.SynchronizableDocument.getLineOfOffset(SynchronizableDocument.java:334)
	at org.eclipse.lsp4e.LSPEclipseUtils.toPosition(LSPEclipseUtils.java:166)
	at org.eclipse.lsp4e.operations.inlayhint.InlayHintProvider.provideCodeMinings(InlayHintProvider.java:44)
	at org.eclipse.lsp4e.operations.inlayhint.InlayHintProvider.provideCodeMinings(InlayHintProvider.java:85)
	at org.eclipse.jface.internal.text.codemining.CodeMiningManager.lambda$2(CodeMiningManager.java:189)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:992)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)
	at org.eclipse.jface.internal.text.codemining.CodeMiningManager.getCodeMinings(CodeMiningManager.java:195)
	at org.eclipse.jface.internal.text.codemining.CodeMiningManager.updateCodeMinings(CodeMiningManager.java:140)
	at org.eclipse.jface.internal.text.codemining.CodeMiningManager.run(CodeMiningManager.java:129)
	at org.eclipse.jface.text.source.SourceViewer.updateCodeMinings(SourceViewer.java:1313)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaCodeMiningReconciler.reconciled(JavaCodeMiningReconciler.java:51)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.reconciled(CompilationUnitEditor.java:1681)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconciled(JavaReconcilingStrategy.java:228)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconciled(JavaCompositeReconcilingStrategy.java:171)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:115)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-16 23:37:46.593
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-16 23:37:51.699
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-16 23:37:57.592
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-16 23:42:36.761
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-16 23:45:37.776
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-16 23:46:17.199
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-16 23:57:35.509
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-02-16 23:58:51.860
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 0 2024-02-17 00:00:53.969
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-02-17 00:00:53.990
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:99)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:220)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-02-17 00:00:53.993
!MESSAGE Wrong format
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.getMetaIndex(IndexManager.java:1729)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:42)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

!ENTRY org.eclipse.jdt.core 4 0 2024-02-17 00:00:53.995
!MESSAGE Error filtering index locations based on qualifier.
!STACK 0
java.io.IOException: Wrong format
	at org.eclipse.jdt.internal.core.index.DiskIndex.initialize(DiskIndex.java:409)
	at org.eclipse.jdt.internal.core.index.Index.<init>(Index.java:120)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.loadMetaIndexIfNeeded(IndexManager.java:1664)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.findMatchingIndexNames(IndexManager.java:1575)
	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:310)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:160)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:186)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.getIndexes(SubTypeSearchJob.java:52)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:109)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:333)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:129)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:106)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:166)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
